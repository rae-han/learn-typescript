# 10장 타입스크립트 및 React

리액트는 최근 몇 년간 매우 인기를 끈 자바스크립트 라이브러리다. 간단한 컴포넌트 구성과 접근 방식 덕분에 프런트엔드 애플리케이션 구현 방식을 바꿨으며, JSX라는 자바스크립트 구문 확장자를 사용하여 선언적으로 UI 코드를 작성할 수 있다.

타입스크립트는 완벽한 JSX 컴파일러다. 추가 번들링이나 도구를 사용하지 않는 프로젝트에서는 타입스크립트만으로 리액트 앱을 실행할 수 있다. 하지만 리액트 팀은 Flow라는 자체 정적 형식 검사기를 사용하므로, `@types/react`는 커뮤니티가 관리한다. 따라서 몇 가지 격차가 존재한다.

이 장에서는 이러한 격차를 해결할 가이드를 제공하며, 다양한 개발 패턴과 그 장점을 확인한다.

> **2025 업데이트**: React 19가 2024년 12월에 정식 출시되었다. 이 장의 많은 패턴은 여전히 유효하지만, 일부 새로운 기능(ref를 일반 prop으로 전달, use() 훅 등)이 추가되었다. 각 절에서 관련 업데이트를 확인할 수 있다.

---

## 10.1 프록시 컴포넌트 작성하기

**문제** 표준 HTML 컴포넌트를 많이 사용하는데, 이때 필요한 모든 프로퍼티를 항상 설정하는 작업이 번거롭다.

**해결** 시나리오에 사용할 수 있도록 프록시 컴포넌트를 만들고 몇 가지 패턴을 적용한다.

**논의** 대부분 웹 애플리케이션은 버튼을 사용한다. 버튼은 `type` 프로퍼티(기본값은 `submit`)를 포함한다. 사이트에 대화형 요소만 있다면 `submit`보다는 `button`이 더 적합한 형식이다.

```tsx
<button type="button">Click me!</button>
```

프록시 컴포넌트는 HTML 요소를 흉내 내며, 몇 가지 프로퍼티를 미리 설정한다.

```tsx
function Button(props) {
  return <button type="button" {...props} />;
}
```

### JSX.IntrinsicElements 사용

JSX에서 사용할 수 있는 모든 HTML 요소는 JSX 네임스페이스의 내부 요소로 정의한다.

```tsx
type ButtonProps = JSX.IntrinsicElements['button'];

function Button(props: ButtonProps) {
  return <button type="button" {...props} />;
}
```

> **추가 설명**: `JSX.IntrinsicElements`는 HTML 요소의 모든 속성을 가져오는 가장 간단한 방법이다. 이는 React 뿐만 아니라 Preact, Solid 등 다른 JSX 기반 프레임워크와도 호환된다.

### Omit으로 특정 키 제거

재정의하지 말아야 할 키는 `Omit<T, K>` 헬퍼 형식으로 삭제한다:

```tsx
type ButtonProps = Omit<JSX.IntrinsicElements['button'], 'type'>;

function Button(props: ButtonProps) {
  return <button type="button" {...props} />;
}

const aButton = <Button type="button">Hi</Button>;
// 오류: 'IntrinsicAttributes & ButtonProps' 형식에 'type' 속성이 없습니다.
```

### 스타일 버튼 확장

디자인 시스템을 고수하면서 스타일을 관리할 수 있다:

```tsx
type StyledButton = Omit<JSX.IntrinsicElements['button'], 'type' | 'className' | 'style'> & {
  type: 'primary' | 'secondary';
};

function StyledButton({ type, ...allProps }: StyledButton) {
  return <button type="button" className={`btn-${type}`} {...allProps} />;
}
```

### MakeRequired 헬퍼 형식

선택형 플래그를 제거하여 필수로 만드는 헬퍼:

```tsx
type MakeRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;

type ImgProps = MakeRequired<JSX.IntrinsicElements['img'], 'alt' | 'src'>;

export function Img(props: ImgProps) {
  return <img {...props} />;
}

const anImage = <Img />;
// 오류: '{}' 형식에 'alt', 'src' 속성이 없습니다.
```

> **실무 팁**: 접근성(a11y)을 위해 이미지의 `alt` 속성을 필수로 만드는 것은 좋은 습관이다. 스크린 리더 사용자를 위해 항상 의미 있는 대체 텍스트를 제공하자.

---

## 10.2 제어 컴포넌트 구현하기

**문제** `input`과 같은 양식 요소의 상태를 브라우저와 리액트 중 어디에서 관리할지 결정해야 하므로 상황이 복잡해진다.

**해결** 런타임에 비제어(uncontrolled)에서 제어(controlled)로 전환되지 않도록 구별된 유니온과 선택형 `never` 기법을 사용하는 프록시 컴포넌트를 구현한다.

**논의** 리액트는 폼 요소를 제어되는 컴포넌트와 비제어 컴포넌트로 구분한다.

- **비제어**: `defaultValue`를 사용하여 브라우저가 상태 관리
- **제어**: `value`와 `onChange`를 사용하여 리액트가 상태 관리

### 비제어 컴포넌트

```tsx
function Input({ value = '', ...allProps }: Props) {
  return <input defaultValue={value} {...allProps} />;
}
```

### 제어 컴포넌트

```tsx
type ControlledProps = Omit<JSX.IntrinsicElements['input'], 'value'> & {
  value: string;
};

function Input({ value = '', onChange, ...allProps }: ControlledProps) {
  return <input value={value} {...allProps} onChange={onChange} />;
}

function AComponentUsingInput() {
  const [val, setVal] = useState('');
  return <Input value={val} onChange={(e) => setVal(e.target.value)} />;
}
```

### 구별된 유니온으로 혼합 방지

리액트는 런타임에 비제어에서 제어로 전환될 때 경고를 표시한다. 구별된 유니온과 선택형 `never` 기법으로 이를 방지한다:

```tsx
import React, { useState } from 'react';

// 몇몇 프로퍼티를 필수로 설정하는 헬퍼 형식
type OnlyRequired<T, K extends keyof T = keyof T> = Required<Pick<T, K>> & Partial<Omit<T, K>>;

// 분기 1: "value", "onChange"를 필수로 설정하고, 'defaultValue' 제거
type ControlledProps = OnlyRequired<JSX.IntrinsicElements['input'], 'value' | 'onChange'> & {
  defaultValue?: never;
};

// 분기 2: value, onChange를 제거하고, 'defaultValue'를 필수로 설정
type UncontrolledProps = Omit<JSX.IntrinsicElements['input'], 'value' | 'onChange'> & {
  defaultValue: string;
  value?: never;
  onChange?: never;
};

type InputProps = ControlledProps | UncontrolledProps;

function Input({ ...allProps }: InputProps) {
  return <input {...allProps} />;
}

function Controlled() {
  const [val, setVal] = useState('');
  return <Input value={val} onChange={(e) => setVal(e.target.value)} />;
}

function Uncontrolled() {
  return <Input defaultValue="Hello" />;
}
```

> **주의**: 제어/비제어 혼합은 리액트에서 흔한 실수다. `value`가 `undefined`에서 정의된 값으로 바뀌면 경고가 발생한다. 이 패턴을 사용하면 컴파일 타임에 이 문제를 방지할 수 있다.

---

## 10.3 사용자 정의 훅 형식 정의하기

**문제** 사용자 정의 훅을 정의하고 적절한 형식을 얻으려 한다.

**해결** 튜플 형식이나 `const` 컨텍스트를 사용한다.

**논의** 리액트에서 사용자 정의 훅을 만들고 평범한 리액트 훅처럼 명명규칙(비구조화할 수 있는 배열이나 튜플을 반환하는 규칙)을 준수한다.

```tsx
const [state, setState] = useState(0);
```

### 문제: 배열 형식 추론

```tsx
export const useToggle = (initialValue: boolean) => {
  const [value, setValue] = useState(initialValue);
  const toggleValue = () => setValue(!value);
  return [value, toggleValue];
};
```

이 훅을 사용하면 오류가 발생한다:

```tsx
export const Body = () => {
  const [isVisible, toggleVisible] = useToggle(false);
  return (
    <>
      <button onClick={toggleVisible}></button>
      {/* 오류: 'boolean | (() => void)' 형식은
          'MouseEventHandler<HTMLButtonElement>' 형식에 할당할 수 없습니다. */}
      {isVisible && <div>World</div>}
    </>
  );
};
```

> **추가 설명**: 왜 이런 오류가 날까? 타입스크립트가 `[value, toggleValue]`를 배열로 추론하기 때문이다. 배열은 길이가 정해지지 않으므로 각 요소가 `boolean | (() => void)` 형식이 된다. `onClick`은 함수만 기대하는데, 타입스크립트 입장에서는 `boolean`도 가능하므로 오류가 발생한다.

### 방법 1: 명시적 반환 형식

```tsx
export const useToggle = (initialValue: boolean): [boolean, () => void] => {
  const [value, setValue] = useState(initialValue);
  const toggleValue = () => setValue(!value);
  return [value, toggleValue];
};
```

### 방법 2: const 컨텍스트

```tsx
export const useToggle = (initialValue: boolean) => {
  const [value, setValue] = useState(initialValue);
  const toggleValue = () => setValue(!value);
  return [value, toggleValue] as const;
};
```

이제 반환 형식은 `readonly [boolean, () => void]`다. `as const`는 값을 변경할 수 없는 상수가 되도록 보장한다.

> **실무 팁**: 커스텀 훅을 만들 때는 `as const`를 사용하는 것이 더 간편하다. 다만 반환값이 `readonly`가 되므로, 반환된 배열을 직접 수정하려는 코드가 있다면 주의해야 한다.

---

## 10.4 제네릭 forwardRef 컴포넌트 형식화하기

**문제** 컴포넌트에 `forwardRef`를 사용하는데, 이를 제네릭으로 만들어야 한다.

**해결** 다양한 방법으로 이 문제를 해결할 수 있다.

**논의** 리액트로 컴포넌트 라이브러리와 디자인 시스템을 만든다면, 컴포넌트 내부의 DOM 요소를 가리키는 포워드 ref가 이미 존재할 수 있다.

### 기본 forwardRef 사용

```tsx
type ButtonProps = JSX.IntrinsicElements['button'];

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => (
  <button type="button" {...props} ref={ref}>
    {props.children}
  </button>
));

// 사용법
const reference = React.createRef<HTMLButtonElement>();
<Button className="primary" ref={reference}>
  Hello
</Button>;
```

### 제네릭 컴포넌트의 문제

제네릭 프로퍼티를 허용하는 컴포넌트가 있다면 상황이 복잡해진다:

```tsx
type ClickableListProps<T> = {
  items: T[];
  onSelect: (item: T) => void;
};

function ClickableList<T>(props: ClickableListProps<T>) {
  return (
    <ul>
      {props.items.map((item, idx) => (
        <li key={idx}>
          <button onClick={() => props.onSelect(item)}>Choose</button>
          {item}
        </li>
      ))}
    </ul>
  );
}
```

### 해결 방법 1: 형식 어서션

```tsx
function ClickableListInner<T>(props: ClickableListProps<T>, ref: React.ForwardedRef<HTMLUListElement>) {
  return (
    <ul ref={ref}>
      {props.items.map((item, i) => (
        <li key={i}>
          <button onClick={() => props.onSelect(item)}>Select</button>
          {item}
        </li>
      ))}
    </ul>
  );
}

const ClickableList = React.forwardRef(ClickableListInner) as <T>(
  props: ClickableListProps<T> & { ref?: React.ForwardedRef<HTMLUListElement> },
) => ReturnType<typeof ClickableListInner>;
```

### 해결 방법 2: 사용자 정의 참조

```tsx
type ClickableListProps<T> = {
  items: T[];
  onSelect: (item: T) => void;
  mRef?: React.Ref<HTMLUListElement> | null;
};

export function ClickableList<T>(props: ClickableListProps<T>) {
  return (
    <ul ref={props.mRef}>
      {props.items.map((item, i) => (
        <li key={i}>
          <button onClick={() => props.onSelect(item)}>Select</button>
          {item}
        </li>
      ))}
    </ul>
  );
}
```

### 해결 방법 3: forwardRef 재선언

```tsx
// forwardRef 재선언
declare module 'react' {
  function forwardRef<T, P = {}>(
    render: (props: P, ref: React.Ref<T>) => React.ReactElement | null,
  ): (props: P & React.RefAttributes<T>) => React.ReactElement | null;
}

// 기존과 같이 컴포넌트를 구현한다!
export const ClickableList = React.forwardRef(ClickableListInner);
```

> **2025 업데이트**: React 19에서는 `ref`가 일반 prop으로 전달될 수 있다! 더 이상 `forwardRef`가 필요하지 않다:
>
> ```tsx
> function ClickableList<T>({ ref, items, onSelect }: ClickableListProps<T> & { ref?: React.Ref<HTMLUListElement> }) {
>   return <ul ref={ref}>{/* ... */}</ul>;
> }
> ```

---

## 10.5 컨텍스트 API에 형식 제공하기

**문제** 앱 전역에서 컨텍스트 API를 사용하고 싶지만, 형식 정의를 처리하는 가장 좋은 방법을 모르겠다.

**해결** 컨텍스트에 사용할 기본 프로퍼티를 설정하고 형식을 유추할 수 있게 하거나, 제네릭 형식 매개변수를 명시적으로 인스턴스화한다. 헬퍼 함수를 만들어 기본값이 없는 상태에서 모든 프로퍼티를 제공하도록 강제한다.

**논의** 리액트의 컨텍스트 API를 사용하면 전역 수준에서 데이터를 공유할 수 있다.

### 기본값으로 형식 추론

```tsx
import React from 'react';

const AppContext = React.createContext({
  authenticated: true,
  lang: 'en',
  theme: 'dark',
});
```

이렇게 하면 `authenticated`, `lang`, `theme` 프로퍼티의 형식이 자동으로 추론된다.

### 공급자 사용

```tsx
function App() {
  return (
    <AppContext.Provider
      value={{
        authenticated: true,
        lang: 'de',
        theme: 'light',
      }}
    >
      <Header />
    </AppContext.Provider>
  );
}
```

### 소비자 사용

```tsx
function Header() {
  const { authenticated } = useContext(AppContext);
  if (authenticated) {
    return <h1>Logged in!</h1>;
  }
  return <h1>You need to sign in</h1>;
}
```

### Partial 형식 사용

기본값이 없거나 프로퍼티를 더 유연하게 조정해야 할 때:

```tsx
type ContextProps = {
  authenticated: boolean;
  lang: string;
  theme: string;
};

const AppContext = React.createContext<Partial<ContextProps>>({});
```

> **주의**: `Partial`을 사용하면 모든 프로퍼티가 선택 사항이 된다. 소비자에서 사용할 때 `undefined` 체크가 필요하다.

### 헬퍼 함수로 안전한 컨텍스트 생성

기본값 없이 모든 프로퍼티를 제공하도록 강제하는 헬퍼:

```tsx
function createContext<Props extends {}>() {
  const ctx = React.createContext<Props | undefined>(undefined);

  function useInnerCtx() {
    const c = useContext(ctx);
    if (c === undefined) {
      throw new Error('Context must be consumed within a Provider');
    }
    return c;
  }

  return [useInnerCtx, ctx.Provider as React.Provider<Props>] as const;
}

// 사용법
const [useAppContext, AppContextProvider] = createContext<ContextProps>();

function App() {
  return (
    <AppContextProvider value={{ lang: 'en', theme: 'dark', authenticated: true }}>
      <Header />
    </AppContextProvider>
  );
}
```

> **실무 팁**: 이 패턴은 많은 프로덕션 코드에서 사용된다. `Context`가 `Provider` 외부에서 사용되면 명확한 오류 메시지를 제공하여 디버깅이 훨씬 쉬워진다.

---

## 10.6 고차 컴포넌트 형식화하기

**문제** 다른 컴포넌트의 몇 가지 프로퍼티를 미리 설정할 수 있도록 고차(higher-order) 컴포넌트를 구현 중인데, 형식을 어떻게 정의해야 할지 모르겠다.

**해결** `@types/react`의 `React.ComponentType<P>` 형식을 이용해 설정된 속성을 확장하는 컴포넌트를 정의한다.

**논의** 리액트는 함수형 프로그래밍의 영향을 받았다. 고차 컴포넌트는 고차 함수에서 영감을 얻었으며, 하나 이상의 컴포넌트를 받아 다른 컴포넌트를 반환한다.

### 기본 예제

```tsx
type CardProps = {
  title: string;
  content: string;
};

function Card({ title, content }: CardProps) {
  return (
    <>
      <h2>{title}</h2>
      <div>{content}</div>
    </>
  );
}

// 고차 컴포넌트 사용
const Info = withInjectedProps({ title: 'Info' }, Card);
<Info content="Your task has been processed" />; // 동작함
<Info content="Your task has been processed" title="Warning" />; // 오류 발생
```

### withInjectedProps 구현

```tsx
function withInjectedProps<T extends {}, U extends T>(injected: T, Component: React.ComponentType<U>) {
  return function (props: Omit<U, keyof T>) {
    const newProps = { ...injected, ...props } as U;
    return <Component {...newProps} />;
  };
}
```

- `T`: 이미 주입한 프로퍼티 (`{}`에서 확장)
- `U`: 컴포넌트의 모든 프롭스 (`T`를 확장)
- `Omit<U, keyof T>`: 미리 채워진 속성을 다시 설정하지 못하도록 함

### 파생 고차 함수

특정 용도에 맞는 고차 함수를 파생할 수 있다:

```tsx
function withTitle<U extends { title: string }>(title: string, Component: React.ComponentType<U>) {
  return withInjectedProps({ title }, Component);
}
```

> **추가 설명**: 고차 컴포넌트(HOC)는 리액트 훅이 등장하기 전에 많이 사용되었다. 지금은 훅이 더 선호되지만, 레거시 코드나 특정 상황에서는 여전히 HOC가 유용하다.

> **2025 업데이트**: 현대 리액트에서는 HOC보다 커스텀 훅이 더 권장된다. 하지만 라이브러리를 만들거나 기존 코드를 유지보수할 때는 HOC 패턴을 이해하는 것이 중요하다.

### 같은 문제를 커스텀 훅으로 해결하기

HOC 대신 커스텀 훅과 컴포넌트 조합으로 같은 문제를 해결할 수 있다:

```tsx
// 1. 카드 타입 설정을 제공하는 커스텀 훅
function useCardConfig<T extends Partial<CardProps>>(defaults: T) {
  return function mergeProps<P extends Omit<CardProps, keyof T>>(props: P) {
    return { ...defaults, ...props } as CardProps;
  };
}

// 2. 기본 Card 컴포넌트는 그대로 유지
type CardProps = {
  title: string;
  content: string;
};

function Card({ title, content }: CardProps) {
  return (
    <>
      <h2>{title}</h2>
      <div>{content}</div>
    </>
  );
}

// 3. 훅을 사용해서 props 주입
function InfoCard({ content }: { content: string }) {
  const getProps = useCardConfig({ title: "Info" });
  return <Card {...getProps({ content })} />;
}

function WarningCard({ content }: { content: string }) {
  const getProps = useCardConfig({ title: "Warning" });
  return <Card {...getProps({ content })} />;
}

// 사용법
<InfoCard content="Your task has been processed" />
<WarningCard content="Something went wrong" />
```

**더 간단한 방법 - 그냥 래퍼 컴포넌트:**

```tsx
// 실무에서는 이게 더 직관적이고 많이 쓰임
function InfoCard({ content }: { content: string }) {
  return <Card title="Info" content={content} />;
}

function WarningCard({ content }: { content: string }) {
  return <Card title="Warning" content={content} />;
}
```

> **실무 팁**: HOC vs 훅 vs 래퍼 컴포넌트 선택 기준:
>
> - **래퍼 컴포넌트**: 단순히 props 기본값만 설정할 때 (가장 직관적)
> - **커스텀 훅**: 상태나 로직 재사용이 필요할 때
> - **HOC**: 여러 컴포넌트에 동일한 props 주입이 필요하고, 레거시 코드와 호환해야 할 때

---

## 10.7 리액트의 합성 이벤트 시스템에서 콜백 형식화하기

**문제** 리액트의 모든 브라우저 이벤트에 사용할 좋은 형식을 얻고, 형식 시스템이 콜백을 호환 가능한 요소로 제한하도록 하려 한다.

**해결** `@types/react`의 이벤트 형식을 사용하고 제네릭 형식 매개변수로 컴포넌트를 특화한다.

**논의** 웹 애플리케이션은 사용자 상호 작용으로 살아 움직인다. 모든 사용자 상호 작용은 이벤트를 일으킨다.

### 브라우저 네이티브 이벤트 vs 리액트 합성 이벤트

```tsx
type ButtonProps = {
  onClick: (event: MouseEvent) => void; // 브라우저 네이티브 - 오류!
} & WithChildren;

function Button({ onClick, children }: ButtonProps) {
  return <button onClick={onClick}>{children}</button>;
  // 오류: 'MouseEvent<HTMLButtonElement, MouseEvent>' 형식에 'MouseEvent' 형식의
  // offsetX, offsetY, x, y 외 14개 속성이 없습니다.
}
```

리액트는 합성 이벤트(SyntheticEvent)라는 자체 이벤트 시스템을 사용한다:

```tsx
import React from 'react';

type WithChildren<T = {}> = T & { children?: React.ReactNode };

type ButtonProps = {
  onClick: (event: React.MouseEvent) => void; // 리액트 합성 이벤트
} & WithChildren;

function Button({ onClick, children }: ButtonProps) {
  return <button onClick={onClick}>{children}</button>;
}
```

### 네이티브 이벤트 프로퍼티 접근

`nativeEvent` 프로퍼티를 통해 원래 이벤트에 접근할 수 있다:

```tsx
function handleClick(event: React.MouseEvent) {
  console.log(event.nativeEvent.offsetX, event.nativeEvent.offsetY);
}
```

### 지원되는 이벤트 형식

`AnimationEvent`, `ChangeEvent`, `ClipboardEvent`, `CompositionEvent`, `DragEvent`, `FocusEvent`, `FormEvent`, `KeyboardEvent`, `MouseEvent`, `PointerEvent`, `TouchEvent`, `TransitionEvent`, `WheelEvent`, 그리고 모든 이벤트의 기본인 `SyntheticEvent`.

### 제네릭 형식 매개변수로 요소 제한

잘못된 요소에 이벤트 핸들러를 사용하지 못하게 할 수 있다:

```tsx
type WithChildren<T = {}> = T & { children?: React.ReactNode };

type ButtonProps = {
  onClick: (event: React.MouseEvent<HTMLButtonElement>) => void;
} & WithChildren;

function Button({ onClick, children }: ButtonProps) {
  return <button onClick={onClick}>{children}</button>;
}

// handleClick은 HTMLButtonElement나 HTMLAnchorElement로부터 이벤트를 받는다
function handleClick(event: React.MouseEvent<HTMLButtonElement | HTMLAnchorElement>) {
  console.log(event.currentTarget.tagName);
}

let button = <Button onClick={handleClick}>Works</Button>;
let link = (
  <a href="/" onClick={handleClick}>
    Works
  </a>
);
let broken = <div onClick={handleClick}>Does not work</div>;
// 오류: 'HTMLDivElement' 형식은 'HTMLButtonElement | HTMLAnchorElement' 형식에
// 할당할 수 없습니다.
```

> **실무 팁**: 이 패턴은 접근성(a11y)에도 도움이 된다. `div`에 `onClick`을 추가하는 것은 접근성 문제를 일으킬 수 있다. 타입스크립트로 이를 방지하면 더 접근성 높은 앱을 만들 수 있다.

---

## 10.8 다형성 컴포넌트 형식화하기

**문제** 다양한 HTML 요소 중 하나로 동작하는 프록시 컴포넌트를 만드는데, 올바른 형식을 정의하기가 어렵다.

**해결** 전달된 프로퍼티를 `any`로 어서션하거나 직접 JSX 팩토리 `React.createElement`를 사용한다.

**논의** 리액트에서는 보통 미리 동작이 정의되며 다양한 요소로 사용할 수 있는 다형적(또는 `as`) 컴포넌트를 정의한다.

```tsx
<Cta as="a" href="https://typescript-cookbook.com">
  Hey hey
</Cta>
<Cta as="button" type="button" onClick={(e) => { /* do something */ }}>
  My my
</Cta>
```

### 기본 구현 (형식 없이)

```tsx
function Cta({ as: Component, ...props }) {
  return <Component {...props} />;
}
```

### CtaProps 형식 정의

```tsx
type CtaElements = 'a' | 'button';

type CtaProps<T extends CtaElements> = {
  as: T;
} & JSX.IntrinsicElements[T];
```

### LibraryManagedAttributes 문제

JSX를 사용하면 `LibraryManagedAttributes` 형식을 평가할 때 복잡한 오류가 발생할 수 있다.

### 해결 방법 1: any 어서션

```tsx
function Cta<T extends CtaElements>({ as: Component, ...props }: CtaProps<T>) {
  return <Component {...(props as any)} />;
}
```

### 해결 방법 2: React.createElement 사용

모든 JSX 호출은 JSX 팩토리 호출의 문법적 설탕이다:

```tsx
<h1 className="headline">Hello World</h1>;
// 다음처럼 변환된다:
React.createElement('h1', { className: 'headline' }, ['Hello World']);
```

`React.createElement`를 직접 사용하면 전역 JSX 네임스페이스에 의존하지 않는다:

```tsx
type WithChildren<T = {}> = T & { children?: React.ReactNode };

type CtaProps<T extends CtaElements> = WithChildren<
  {
    as: T;
  } & JSX.IntrinsicElements[T]
>;

function Cta<T extends CtaElements>({ as: Component, children, ...props }: CtaProps<T>) {
  return React.createElement(Component, props, children);
}
```

> **추가 설명**: 다형성 컴포넌트는 디자인 시스템에서 매우 유용하다. 예를 들어, `Button` 컴포넌트가 상황에 따라 `<button>`, `<a>`, 또는 `<Link>`(라우터)가 될 수 있다.

> **실무 팁**: 다형성 컴포넌트를 만들 때는 접근성을 항상 고려해야 한다. `<a>`와 `<button>`은 의미론적으로 다르므로, 사용자가 올바른 요소를 선택하도록 안내하는 것이 중요하다.

> **2025 업데이트**: 현대 UI 라이브러리(예: Radix UI, Headless UI)에서는 다형성 컴포넌트 패턴이 널리 사용된다. 이런 라이브러리들은 이미 잘 형식화된 다형성 컴포넌트를 제공하므로, 직접 구현하기보다 이를 활용하는 것도 좋은 선택이다.
