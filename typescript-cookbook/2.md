# 2장 기본 형

## 2.1 애너테이션 효과적으로 사용하기
**문제** 모든 곳에 형식을 써 넣기엔 번거롭고, 어디까지 적어야 할지 혼란스럽다.

**해결** 함수 매개변수와 외부로 드러나는 경계에만 형식 애너테이션을 집중하고, 나머지는 타입스크립트의 추론 능력에 맡긴다.

타입스크립트는 구조적 형식 시스템이므로 반환값과 지역 변수는 대부분 자동으로 추론된다. 대신 API 표면—특히 함수 인수와 반환 형식—에는 명시적으로 애너테이션을 달아 계약을 고정한다.

```ts
type Person = {
  name: string;
  age: number;
};

function createPerson() {
  return { name: "Stefan", age: 39 }; // 반환형은 자동 추론
}

const me = createPerson();

function printPerson(person: Person) {
  console.log(person.name, person.age);
}

printPerson(me); // 구조적 호환성으로 안전하게 호출
```

실무에서는 다음 원칙을 기억하면 불필요한 애너테이션 피로도를 줄일 수 있다.

- **경계에 집중**: 함수 인수, 반환값, 클래스 공개 프로퍼티처럼 외부와 맞닿는 지점에 형식을 선언한다. 내부 구현은 타입 추론이 담당하게 두면 리팩터링 시 수정 범위가 줄어든다.
- **변수는 상황별로 선택**: 한 번만 할당하는 값이라면 `const` 선언에 타입 애너테이션을 생략해도 괜찮다. 반복적으로 재할당하는 `let` 변수는 앞으로 들어올 값의 집합을 명시하는 편이 안전하다.
- **추론 결과 검증**: `const person = createPerson();`에 마우스를 올려 편집기가 추론한 타입을 확인한다. 의도와 다르면 애너테이션을 추가하거나 반환 타입을 수정해야 한다는 신호다.
- **의도 표현에 활용**: `as const`나 리터럴 타입을 이용해 불변 데이터의 형태를 고정하면, 나중에 유니온 타입이나 매핑 타입으로 재활용하기 쉬워진다.

> **2025 업데이트**: TypeScript 5.x의 `satisfies` 연산자를 활용하면 타입 애너테이션 없이도 값이 특정 타입을 만족하는지 검사할 수 있다. 추론된 타입을 유지하면서 타입 안전성을 확보하는 강력한 방법이다.

```ts
const config = {
  theme: "dark",
  timeout: 3000,
} satisfies Record<string, string | number>;
// config.theme은 여전히 "dark" 리터럴 타입으로 추론됨
```

> **팁**: 반환 타입을 명시하면 함수 내부에서 실수로 잘못된 값을 반환했을 때 즉시 발견할 수 있다. 특히 공개 API나 라이브러리 코드에서는 반환 타입을 명시하는 것이 좋다.

즉, "타입 추론을 기본값으로 두고, 문서로 삼고 싶은 계약만 명시적으로 작성한다"는 사고방식이 핵심이다.

## 2.2 any와 unknown 활용하기
**문제** 형식 시스템을 일시적으로 우회하려면 `any`와 `unknown` 중 무엇을 써야 할지 모르겠다.

**해결** 마이그레이션 중 형식 검사를 완전히 끊고 싶을 때는 `any`를, 값을 전달하되 사용 전 검증이 필요할 때는 `unknown`을 사용한다.

`any`는 모든 연산을 허용하지만 형식 안전성을 잃는다. `unknown`은 어떤 연산도 허용하지 않으며, 사용 전 타입 가드를 강제한다. `noImplicitAny`로 묵시적 `any`를 막고, `unknown`을 좁히는 유틸리티 함수를 준비해두면 점진적 전환이 수월해진다.

```ts
function unsafeParse(json: string): any {
  return JSON.parse(json); // any: 형식 검사를 완전히 생략
}

function safeParse(json: string): unknown {
  return JSON.parse(json); // unknown: 이후 분기에서 좁히기
}

const result = safeParse('{"age":40}');
if (typeof result === "object" && result && "age" in result) {
  const age = (result as { age: number }).age; // 좁힌 뒤 접근
  console.log(age);
}
```

| 특성 | `any` | `unknown` |
|------|-------|-----------|
| 모든 값 할당 | ✅ | ✅ |
| 다른 타입에 할당 | ✅ | ❌ (좁히기 필요) |
| 프로퍼티 접근 | ✅ | ❌ (좁히기 필요) |
| 타입 안전성 | ❌ | ✅ |
| 권장 용도 | 마이그레이션 | 외부 입력 처리 |

`any`와 `unknown`을 구분할 때는 다음 체크리스트를 활용한다.

- `any`는 타입 안전성에서 완전히 벗어나고 싶을 때만 사용한다. `noImplicitAny`를 켜면 의도하지 않은 `any`가 생기면 컴파일러가 경고한다.
- `unknown`은 "아직 모르는 값"을 표현하는 기본 선택지다. 값을 사용하기 전에 `typeof`, `Array.isArray`, 커스텀 타입 가드 등으로 좁히도록 강제한다.
- 반복적으로 쓰는 검증 로직은 타입 가드 함수로 추출한다. 예를 들어 `function isPerson(value: unknown): value is Person { ... }`처럼 작성하면 좁힌 뒤에는 `value`가 곧바로 `Person`으로 동작한다.
- 외부 라이브러리나 JSON 파싱 결과처럼 "입력은 불특정, 출력은 확실"한 코드 경계에서 `unknown`을 반환하고, 바깥에서 검증한 뒤 내부 도메인 타입으로 변환한다.

> **2025 업데이트**: Zod, Valibot 같은 런타임 검증 라이브러리를 사용하면 `unknown` 값을 타입 안전하게 파싱할 수 있다. 스키마에서 TypeScript 타입을 자동으로 추론하므로 `as` 단언이 필요 없다.

```ts
import { z } from 'zod';
const PersonSchema = z.object({ name: z.string(), age: z.number() });
type Person = z.infer<typeof PersonSchema>;

const result = PersonSchema.safeParse(JSON.parse(json));
if (result.success) {
  console.log(result.data.name); // 타입 안전
}
```

> **팁**: `any`가 코드베이스에 퍼지는 것을 막으려면 ESLint의 `@typescript-eslint/no-explicit-any` 규칙을 활성화하고, 예외적으로 필요한 곳에만 `// eslint-disable-next-line`을 사용하자.

이 원칙을 지키면 `any`가 프로젝트 전체로 번지는 것을 막으면서도 현실적인 마이그레이션 속도를 유지할 수 있다.

## 2.3 올바른 객체 선택하기
**문제** 빈 객체를 표현할 때 `{}`, `Object`, `object` 중 무엇을 사용해야 할지 헷갈린다.

**해결** 일반적인 객체·배열·함수 등 복합 값을 표현할 땐 소문자 `object`를 사용하고, 나머지 값 전체를 허용해야 할 때만 `{}` 또는 `Object`를 고려한다.

`object`는 원시형을 제외한 모든 복합 값을 나타낸다. `{}`나 `Object`는 `null`/`undefined`를 제외한 거의 모든 값을 허용하므로 타입 안전성이 떨어진다. 상황에 맞춰 명시적으로 선택하면 코드 의도가 분명해진다.

```ts
let anything: {};      // null/undefined만 제외
let onlyObjects: object; // 원시형 제외

anything = 42;           // 가능
// onlyObjects = 42;     // 오류: 원시형은 허용되지 않음

onlyObjects = { name: "Stefan" };
onlyObjects = () => console.log("hi");
```

| 타입 | 허용하는 값 | 제외하는 값 | 권장 용도 |
|------|------------|------------|----------|
| `{}` | 거의 모든 값 | `null`, `undefined` | 사용 비권장 |
| `Object` | 거의 모든 값 | `null`, `undefined` | 사용 비권장 |
| `object` | 객체, 배열, 함수 | 원시형 | 복합 값 표현 |
| `Record<string, unknown>` | 문자열 키 객체 | 배열, 함수 등 | 딕셔너리 표현 |

추가로 다음 상황을 염두에 두자.

- `Record<string, unknown>` 같은 유틸리티 타입은 "키가 문자열인 임의의 객체"를 보다 명확히 표현할 때 유용하다. 소문자 `object`보다 구체적인 구조가 필요한 경우에 사용한다.
- 빈 객체 리터럴 `{}`는 얇은 의미만 담고 있어서, 실수로 숫자나 문자열을 허용해도 컴파일러가 막지 못한다. 특별한 이유가 없다면 피하는 편이 낫다.
- `Object` 타입은 JavaScript의 원시형을 박싱한 래퍼(`new Number(0)` 등)까지 포함하므로 현대 코드에서는 거의 사용하지 않는다.

> **팁**: "원시형 제외"가 목적이면 `object`, "키가 문자열이어야 함"이 목적이면 `Record<string, unknown>`처럼 의도를 드러내는 타입을 선택하자. ESLint의 `@typescript-eslint/ban-types` 규칙으로 `{}`, `Object` 사용을 금지할 수 있다.

## 2.4 튜플 형식 사용하기
**문제** 배열에 서로 다른 타입의 데이터를 위치 기반으로 담았는데, 순서가 바뀌면 오류가 난다.

**해결** 튜플을 사용해 각 인덱스의 형식을 고정한다.

튜플은 길이와 각 요소 타입이 고정된 배열이다. `readonly`로 불변성을 부여할 수 있으며, 구조 분해 시 타입이 정확히 따라온다. 객체로 전환할 때도 `Record`나 매핑 타입과 함께 쓰기 좋다.

```ts
type LatLng = readonly [number, number]; // [위도, 경도]

const home: LatLng = [37.5665, 126.9780];
const [lat, lng] = home; // lat: number, lng: number

// home[0] = 0; // readonly라서 수정 불가
```

> **2025 업데이트**: TypeScript 4.0부터 튜플에 레이블을 붙일 수 있다. `type LatLng = [lat: number, lng: number]`처럼 선언하면 IDE에서 각 위치의 의미를 바로 확인할 수 있어 가독성이 크게 향상된다.

```ts
type LatLng = [lat: number, lng: number];
type Response = [data: string, status: number, headers?: Record<string, string>];
```

튜플을 사용할 때 알아두면 좋은 규칙들:

- **의미 있는 위치 이름 붙이기**: 레이블이 있는 튜플을 사용하거나, 타입 별칭 내에서 주석을 달아 `[위도, 경도]` 같은 의미를 명시하면 유지보수가 쉬워진다.
- **선택적 요소와 나머지 요소**: `type Result = [number, number?, ...string[]];`처럼 마지막에 `...`을 써서 가변 길이를 허용할 수 있다. 단, 순서와 길이에 따라 타입이 달라지는 만큼 사용 패턴을 명확히 문서화해야 한다.
- **불변 데이터**: `readonly`를 붙이면 구조 분해는 허용하되 직접 인덱스로 값을 수정할 수 없다. React 훅 반환값처럼 변경을 막고 싶은 데이터에 적합하다.
- **객체와 상호 변환**: 튜플을 객체로 매핑하려면 `type LatLngObj = { lat: LatLng[0]; lng: LatLng[1]; };`처럼 인덱스 접근 타입을 활용한다. 위치 기반 데이터를 키 기반 데이터로 안전하게 옮길 수 있다.

> **팁**: React의 `useState` 반환값(`[state, setState]`)이 대표적인 튜플 활용 사례다. 구조 분해 할당 시 원하는 이름을 자유롭게 지정할 수 있어 객체보다 간결하다.

튜플은 "작은 배열에 의미 있는 위치를 부여"하려는 상황에서 강력한 도구가 된다.

## 2.5 인터페이스와 형식 별칭의 차이 이해하기
**문제** 객체를 정의할 때 `interface`와 `type` 중 무엇을 선택해야 할지 모르겠다.

**해결** 확장성과 선언 병합이 필요하면 `interface`를, 유니온·교차 등 복합 타입을 조합해야 하면 `type`을 사용한다.

`interface`는 동일한 이름으로 여러 번 선언해도 병합되며 클래스를 구현할 때 자연스럽다. 반면 `type`은 유니온, 조건부 타입 등 고급 기능과 잘 맞는다. 두 키워드는 대부분 상호 교환 가능하지만, 프로젝트 규칙을 정해 일관성 있게 사용하면 좋다.

```ts
interface Person {
  name: string;
}

interface Person {
  age: number; // 선언 병합으로 속성이 추가됨
}

type Staff = Person & { title: string }; // 교차 타입

const employee: Staff = {
  name: "Stefan",
  age: 40,
  title: "Manager"
};
```

| 특성 | `interface` | `type` |
|------|-------------|--------|
| 선언 병합 | ✅ | ❌ |
| `extends` 확장 | ✅ | ❌ (& 사용) |
| 유니온 타입 | ❌ | ✅ |
| 조건부 타입 | ❌ | ✅ |
| 매핑 타입 | ❌ | ✅ |
| 클래스 implements | ✅ | ✅ |

두 키워드를 선택할 때 고려할 사항:

- `interface`는 `extends` 문법으로 다른 인터페이스를 확장하거나 클래스의 `implements` 절에서 바로 사용할 수 있다. 라이브러리 공개 API처럼 확장이 예상되는 구조라면 인터페이스가 편하다.
- `type`은 유니온(`|`), 교차(`&`), 조건부 타입 등 고급 기능과 자연스럽게 결합된다. 복잡한 제네릭 조합이나 튜플, 매핑 타입을 정의할 때 주로 사용한다.
- 이름이 겹치면 `interface`는 병합되지만 `type`은 오류가 난다. 이 특성을 활용해 외부 라이브러리가 제공한 인터페이스를 프로젝트에서 확장할 수도 있다(예: `declare module "express" { interface Request { user?: User } }`).
- 팀 규칙을 정할 때는 "기본은 `type`, 병합이 필요할 때만 `interface`" 혹은 그 반대처럼 방향성을 미리 합의해 두면 혼란을 줄일 수 있다.

> **2025 업데이트**: TypeScript 팀은 성능 면에서 `interface`가 약간 유리하다고 밝힌 바 있다. 다만 일반적인 프로젝트에서 체감할 정도는 아니므로, 팀 컨벤션과 가독성을 우선시하는 것이 좋다.

> **팁**: 객체 형태의 타입을 정의할 때는 `interface`를, 유니온이나 유틸리티 타입을 조합할 때는 `type`을 사용하는 것이 일반적인 권장 사항이다.

결국 두 문법은 상호 보완적이므로, 상황에 맞춰 장점을 취하면 된다.

## 2.6 함수 오버로드 정의하기
**문제** 하나의 함수가 서로 다른 인수 조합을 지원해야 한다.

**해결** 오버로드 시그니처를 위에 나열하고, 구현부에서는 가장 넓은 타입을 다루면서 분기한다.

타입스크립트는 런타임 오버로드를 직접 지원하지 않으므로, 여러 시그니처를 선언한 뒤 구현 함수 하나를 작성한다. 구현부에서는 타입 가드로 분기해 올바른 값을 반환해야 한다.

```ts
function format(value: number): string;
function format(value: Date): string;
function format(value: number | Date) {
  if (value instanceof Date) {
    return value.toISOString();
  }
  return value.toFixed(2);
}

format(3.14);
format(new Date());
```

오버로드를 정의할 때는 다음 규칙을 기억하자.

- 선언 순서가 중요하다. 가장 구체적인 시그니처를 위에, 가장 넓은 시그니처(구현부와 동일한 시그니처)는 마지막에 둔다. 호출부에서 타입을 추론할 때 위에서부터 매칭을 시도하기 때문이다.
- 구현 함수에는 실제로 가능한 모든 인수 조합을 처리하는 로직이 들어가야 하며, 반환 타입도 오버로드 시그니처 중 가장 넓은 타입을 반환해야 한다.
- `export interface Formatter { (value: number): string; (value: Date): string; }`처럼 호출 시그니처를 가진 인터페이스를 별도로 정의해 재사용할 수도 있다.
- 오버로드가 너무 많아지면 "discriminated union + 조건부 반환" 구조로 바꾸는 것도 고려한다. 예를 들어 `type Formattable = number | Date;`를 받아 내부에서 분기하면 API가 단순해질 수 있다.

> **팁**: 오버로드 대신 제네릭과 조건부 타입을 조합하면 더 유연한 타입 추론이 가능한 경우가 많다. 오버로드는 시그니처가 2-3개일 때 가독성이 좋고, 그 이상이면 제네릭 패턴을 고려하자.

```ts
// 조건부 타입을 활용한 대안
function format<T extends number | Date>(
  value: T
): T extends Date ? string : string {
  // ...
}
```

명세가 복잡할수록 주석으로 각 시그니처의 의미를 남겨 두면 호출자가 오버로드 의도를 쉽게 이해할 수 있다.

## 2.7 this 매개 변수의 형식 정의하기
**문제** 객체 메서드를 독립 함수로 넘기면 `this`가 `any`가 되어버린다.

**해결** 함수 첫 인자로 `this: 타입`을 선언해 호출 컨텍스트를 명시한다.

ES 함수 표현식의 첫 매개변수에 `this`를 선언하면 타입스크립트가 올바른 컨텍스트를 검사한다. 화살표 함수는 자신만의 `this`를 갖지 않으므로 이 기법이 적용되지 않는다.

```ts
interface Timer {
  label: string;
  start(this: Timer): void;
}

const timer: Timer = {
  label: "build",
  start(this: Timer) {
    console.log(`${this.label} 시작`);
  }
};

const start = timer.start;
// start(); // 오류: this가 Timer가 아님을 경고
start.call(timer); // 안전한 호출
```

`this` 매개변수를 활용할 때의 팁:

- 첫 번째 매개변수 이름은 반드시 `this`여야 하며, 함수 시그니처에서만 사용할 수 있다. 이 매개변수는 런타임에는 존재하지 않지만 타입 검사에는 반영된다.
- 전역 함수나 콜백에서도 `this`를 명시할 수 있다. 예를 들어 DOM 이벤트 핸들러에서 `function handleClick(this: HTMLButtonElement, event: MouseEvent)`처럼 선언하면 내부에서 `this`가 버튼 요소임을 보장받는다.
- 객체 리터럴의 메서드를 화살표 함수로 작성하면 `this`가 상위 스코프를 가리키므로, `this` 매개변수가 필요한 경우 반드시 일반 함수 표현식(또는 메서드 축약 문법)을 사용한다.

> **팁**: `noImplicitThis` 옵션을 켜면 `this` 타입이 추론되지 않는 상황에서 컴파일러가 경고한다. `strict: true`에 포함되어 있으므로 strict 모드를 사용한다면 자동으로 활성화된다.

## 2.8 심볼 사용하기
**문제** 객체 키가 충돌하지 않도록 고유한 식별자가 필요하다.

**해결** `Symbol`을 사용해 전역적으로 유일한 키를 만들고, 타입 시스템에서도 심볼 속성을 다룰 수 있도록 선언한다.

심볼은 객체 프로퍼티 키로 사용할 수 있고, `unique symbol` 타입을 이용하면 상수 심볼마다 다른 타입으로 구분된다. 전역 심볼 레지스트리를 이용하면 여러 모듈이 동일한 키를 공유할 수도 있다.

```ts
const ID = Symbol("id");
const CREATED_AT: unique symbol = Symbol("createdAt");

type Entity = {
  [ID]: number;
  [CREATED_AT]: Date;
  name: string;
};

const user: Entity = {
  [ID]: 1,
  [CREATED_AT]: new Date(),
  name: "Stefan"
};
```

심볼을 사용할 때는 다음 사항을 체크하자.

- 같은 설명이라도 `Symbol("id")`는 매번 새로운 값을 만든다. 여러 모듈에서 동일한 심볼을 공유하려면 `Symbol.for("id")`를 사용해 전역 심볼 레지스트리에 저장한다.
- 타입 단에서 `unique symbol`로 선언하면 해당 상수마다 고유 타입이 생성된다. 이를 이용해 API가 요구하는 특정 심볼을 강제할 수 있다(예: `declare const ITERATOR: unique symbol`).
- 객체 리터럴에서 심볼 키를 사용할 때는 반드시 대괄호 표기법을 사용한다. `entity[ID]` 접근은 타입 검사에서도 올바르게 인식된다.
- 라이브러리가 제공하는 well-known symbol(`Symbol.iterator`, `Symbol.toStringTag` 등)을 타입 선언에 포함시키면 사용자 정의 객체도 표준 프로토콜을 따르는 것으로 인식된다.

> **팁**: 심볼은 `JSON.stringify()`에서 무시되므로, 직렬화하면 안 되는 메타데이터를 저장하는 데 유용하다. 예를 들어 캐시 키나 내부 상태를 심볼 프로퍼티로 관리할 수 있다.

이 특성을 활용하면 이름 충돌 걱정 없이 메타데이터를 저장하거나, 외부 코드가 임의로 접근하지 못하게 캡슐화된 필드를 만들 수 있다.

## 2.9 값과 형식 네임스페이스 이해하기
**문제** 같은 이름이 값과 타입에서 충돌하거나 헷갈린다.

**해결** 타입스크립트는 값과 타입 네임스페이스를 분리하므로, 각각의 역할을 구분해 선언하고 필요하면 `typeof`나 `enum` 등을 활용한다.

타입 선언(`interface`, `type`, `class`의 타입 부분)은 타입 공간에서만 존재하고, 변수나 함수는 값 공간에 존재한다. `typeof`를 사용하면 값에서 타입을 끌어올 수 있다. 네임스페이스를 이해하면 선언 순서를 명확히 하여 충돌을 피할 수 있다.

```ts
const settings = {
  theme: "dark",
  retries: 3
};

type Settings = typeof settings; // 값에서 타입 추출

function updateSettings(next: Settings) {
  // ...
}

updateSettings({ theme: "light", retries: 5 });
```

| 선언 방식 | 값 공간 | 타입 공간 |
|----------|--------|----------|
| `const`, `let`, `function` | ✅ | ❌ |
| `type`, `interface` | ❌ | ✅ |
| `class` | ✅ (생성자) | ✅ (인스턴스 타입) |
| `enum` | ✅ | ✅ |
| `namespace` | ✅ | ✅ |

값 공간과 타입 공간을 구분할 때 기억해야 할 개념:

- **이름 공유**: `class Foo {}`는 값(생성자)과 타입(인스턴스 형태) 두 공간 모두에 진입한다. 따라서 `typeof Foo`는 생성자 타입, `Foo` 자체는 인스턴스 타입을 의미한다.
- **`typeof` 활용**: 값에서 타입을 끌어올 때는 `typeof`를 사용한다. 반대로 타입에서 값을 생성하는 일은 불가능하므로, enum이나 `as const` 객체를 활용해 필요한 상수를 미리 정의한다.
- **선언 순서**: 타입 선언은 호이스팅되지 않는다. 값이나 타입을 참조할 때는 선언 위치를 고려해야 한다. 특히 순환 참조가 발생하지 않도록 주의한다.
- **네임스페이스 통합**: 타입스크립트의 `namespace`는 값과 타입을 동시에 내보낼 수 있다. 최근에는 ES 모듈과의 호환을 위해 자주 쓰이진 않지만, 기존 코드와 상호 운용할 때 나눠져 있는 네임스페이스 규칙을 이해하고 있으면 도움이 된다.

> **2025 업데이트**: `import type`과 `export type` 구문을 사용하면 타입 전용 import/export임을 명시할 수 있다. TypeScript 5.x의 `verbatimModuleSyntax` 옵션과 함께 사용하면 번들 크기 최적화와 명확한 의도 표현에 도움이 된다.

```ts
import type { User } from './types';  // 타입만 가져옴 (런타임에서 제거됨)
import { createUser } from './utils'; // 값을 가져옴
```

> **팁**: 클래스의 정적 멤버 타입이 필요할 때는 `typeof ClassName`을, 인스턴스 타입이 필요할 때는 `ClassName`을 사용한다. `InstanceType<typeof ClassName>`과 `ClassName`은 동일한 타입이다.

이렇게 두 공간을 명확히 구분하면 "왜 값으로 가져온 심볼이 타입 위치에서 사용되지 않는가?" 같은 의문을 빠르게 해소할 수 있다.
