# 9장 표준 라이브러리 및 외부 형식 정의

타입스크립트의 수석 아키텍트인 아네르스 하일스베르(Anders Hejlsberg)는 "타입스크립트가 자바스크립트의 스위스가 되길 바란다"라고 말한 적이 있다. 이는 타입스크립트가 특정 프레임워크와의 호환성만 선호하는 것이 아니라 모든 자바스크립트 프레임워크와 기능을 수용하려고 노력한다는 의미다.

하지만 타입스크립트가 모든 자바스크립트 개발자를 만족시키려고 많은 노력을 기울인다 해도, 여전히 할 수 없거나 하지 않을 일이 존재한다. 특정 기능의 용도가 너무 특별해서 틈새 시장에서만 유용할 수도 있고, 어떤 결정이 너무 많은 개발자에게 큰 영향을 미쳐서일 수도 있다.

이런 이유로 타입스크립트는 기본적으로 확장 가능하도록 설계되었다. 네임스페이스, 모듈, 인터페이스와 같은 타입스크립트의 많은 기능은 선언 합치기를 허용하므로 원하는 대로 형식 정의를 추가할 수 있다.

이 장에서는 타입스크립트가 모듈, 배열, 객체와 같은 표준 자바스크립트 기능을 어떻게 처리하는지 살펴본다. 몇 가지 제한 사항을 살펴보고, 제한 사항의 원인을 분석하고, 합리적인 해결 방법을 제시한다.

## 9.1 Object.keys로 객체 반복하기

**문제** 객체의 키로 객체를 반복하면서 프로퍼티에 접근할 때 타입스크립트는 "'string'을 인덱스 형식에 사용할 수 없습니다"라는 경고와 함께 물결선을 보여준다.

**해결** `Object.keys` 대신 `for-in` 루프를 사용하고 제네릭 형식 매개변수로 형식을 잠근다.

**논의** 키로 객체를 반복하면서 객체 프로퍼티에 접근하려고 하면 예상하지 못한 문제가 자주 일어난다. 자바스크립트에서는 아주 평범한 동작이지만, 타입스크립트는 이러한 동작을 수행하지 못하도록 막으려는 느낌이 든다.

```ts
Object.keys(person).map((k) => person[k]);
```

그러면 타입스크립트는 물결선으로 경고("'string' 형식의 식을 'Person' 인덱스 형식에 사용할 수 없으므로 요소에 암시적으로 'any' 형식이 있습니다")를 보내며, 개발자들을 당황하게 한다.

### Object.keys가 string[]을 반환하는 이유

```ts
type Person = {
  name: string;
  age: number;
};

function printPerson(p: Person) {
  Object.keys(p).forEach((k) => {
    console.log(k, p[k]);
    // 'string' 형식의 식을 'Person' 인덱스 형식에
    // 사용할 수 없으므로 요소에 암시적으로 'any' 형식이 있습니다.
  });
}
```

`Object.keys(p)`는 `string[]`을 반환하는데, 이는 범위가 너무 넓어서 `Person`이라는 객체에 접근하도록 허용할 수 없다.

왜 그럴까? `Object.keys`를 이용했으므로 오직 존재하는 키만 접근하는데 뭐가 문제일까? 이때 `Person`의 하위 형식 객체도 전달할 수 있어야 하는데, `Person`의 하위 객체는 더 많은 프로퍼티를 포함할 수 있다. 즉 하위 타입의 추가 키 때문에 다른 객체에 안전하게 접근할 수 없기 때문이다.

```ts
const me = {
  name: 'Stefan',
  age: 40,
  website: 'https://fettblog.eu',
};

printPerson(me); // 동작함!
```

`Object.keys(p)`가 `keyof Person[]`를 반환한다고 생각해 보자. 다음과 같은 함수를 쉽게 구현할 수 있다:

```ts
function printPerson(p: Person) {
  const you: Person = {
    name: 'Reader',
    age: NaN,
  };
  Object.keys(p).forEach((k) => {
    console.log(k, you[k]); // undefined 출력 가능!
  });
}

const me = {
  name: 'Stefan',
  age: 40,
  website: 'https://fettblog.eu',
};

printPerson(me);
```

`Object.keys(p)`가 `keyof Person[]` 형식의 배열을 반환한다면 `Person`의 다른 객체에도 접근할 수 있다. 따라서 예상하지 못한 결과가 나올 수 있다. 예제에서는 `undefined`를 출력한다. 이 값으로 어떤 동작을 수행하면 런타임에 오류가 발생한다.

핵심은 `p`의 키로 `p`가 아닌 다른 객체(`you`)에 접근할 수 있다는 점이다. TypeScript는 `Object.keys(p)`에서 얻은 키가 어디에 사용될지 추적하지 않으므로, 보수적으로 `string[]`을 반환해서 다른 객체에 안전하게 접근하지 못하도록 막는다.

### 형식 가드로 해결

```ts
function isKey<T>(x: T, k: PropertyKey): k is keyof T {
  return k in x;
}

function printPerson(p: Person) {
  Object.keys(p).forEach((k) => {
    if (isKey(p, k)) console.log(k, p[k]);
  });
}
```

하지만 이때 필요 없는 과정이 추가된다:

- **런타임 검사가 논리적으로 불필요**: `Object.keys(p)`는 이미 `p` 객체에 존재하는 키만 반환하므로 `k in x` 검사는 항상 `true`다. 타입스크립트를 만족시키기 위해 실제로는 의미 없는 런타임 검사를 수행하는 셈이다.
- **매 반복마다 함수 호출 오버헤드**: 각 키에 대해 `isKey()` 함수를 호출해야 한다.
- **추가 조건문**: `if`문이 추가되어 코드가 복잡해진다.

### for-in 루프와 제네릭으로 해결

```ts
function printPerson<T extends Person>(p: T) {
  for (let k in p) {
    console.log(k, p[k]); // 동작함!
  }
}
```

`p`를 `Person` 형식으로 설정해서 `Person`의 모든 하위 형식과 호환되도록 하는 대신, `Person`의 하위 형식인 새로운 제네릭 형식 매개변수 `T`를 추가했다. 이 함수 시그니처와 호환되는 모든 형식을 이용할 수 있지만, `p`를 사용하는 순간 `Person`의 넓은 상위 형식이 아니라 구체적인 하위 형식을 다룬다.

`T`를 `Person`과 호환되는 형식으로 치환할 때 타입스크립트는 이 형식이 충분히 구체적 형식이므로 오류를 일으킬 필요가 없다고 판단한다.

형식 가드 방식과 달리 이 방법은 **런타임 오버헤드 없이 컴파일 타임에만 해결**된다. 추가 함수 호출이나 조건문 없이 제네릭으로 타입을 "잠그는" 것만으로 문제가 해결되므로 더 효율적이다.

이 기법은 특정 프로퍼티를 빠뜨린 형식에 접근하지 못하도록 한다:

```ts
function printPerson<T extends Person>(p: T) {
  const you: Person = {
    name: 'Reader',
    age: NaN,
  };
  for (let k in p) {
    console.log(k, you[k]);
    // 'Extract<keyof T, string>' 형식을 인덱스 형식
    // 'Person'에 사용할 수 없습니다. ts(2536)
  }
}
```

`keyof T`로 `Person`에 접근할 수 없다. 둘이 서로 같다는 보장이 없기 때문이다. `T`는 `Person`의 하위 형식이므로 정확한 프로퍼티명을 안다면 여전히 프로퍼티를 할당할 수 있다.

```ts
p.age = you.age;
```

> **팁**: 타입스크립트가 형식과 관련해 보수적인 태도를 보여주는데, 처음에는 이 동작이 이상하게 느껴질 수 있다. 하지만 실제로는 예상하지도 못한 시나리오에서 오류가 발생하는 일을 막아준다.

## 9.2 형식 어서션과 unknown으로 안전하지 않은 동작을 명시적으로 표시하기

**문제** JSON 동작으로 임의의 데이터를 파싱할 때 데이터가 올바르지 않으면 문제가 발생할 수 있다. 타입스크립트의 기본 기능에는 안전하지 않은 동작을 방지하는 장치가 없다.

**해결** `unknown`으로 강제하고, 형식 애너테이션 대신 형식 어서션으로 안전하지 않은 동작을 표시한다.

**논의** fetch API를 사용해 백엔드에서 JSON 데이터를 가져올 때 형식 애너테이션을 사용하는 방법이 있다:

```ts
type Person = {
  name: string;
  age: number;
};

const ppl: Person[] = await fetch('/api/people').then((res) => res.json());
```

`res.json()`은 `any`를 반환하며 `any`는 형식 어서션을 통해 다른 모든 형식으로 바뀔 수 있다. 따라서 결과가 실제 `Person[]`이라는 보장이 없다.

형식 애너테이션 대신 형식 어서션을 사용하는 방법도 있다:

```ts
const ppl = (await fetch('/api/people').then((res) => res.json())) as Person[];
```

### 안전하지 않은 동작이란?

형식 시스템에서 안전하지 않은 동작이란, 어떤 값이 특정 형식이라고 형식 시스템에 단언하지만, 형식 시스템 내에서 이 단언이 실제로 참이라고 보장할 수 없는 상황을 의미한다. 이는 주로 애플리케이션의 경계에서 발생하며, 외부에서 데이터를 로드하거나 사용자 입력을 처리하거나 내장된 메서드로 데이터를 파싱할 때 발생한다.

형식 시스템에는 안전하지 않은 동작을 표현하는 데 사용하는 몇 가지 키워드가 있다:

- 형식 어서션 (`as`)
- 형식 찬반 (`is`)
- 어서션 시그니처 (`asserts`)

### Body 인터페이스 패치하기

`lib.dom.d.ts`의 `Body` 인터페이스에서 문제가 발생한다:

```ts
interface Body {
  readonly body: ReadableStream<Uint8Array> | null;
  readonly bodyUsed: boolean;
  arrayBuffer(): Promise<ArrayBuffer>;
  blob(): Promise<Blob>;
  formData(): Promise<FormData>;
  json(): Promise<any>; // any가 문제!
  text(): Promise<string>;
}
```

`json()`는 `Promise<any>`를 반환하며 `any`는 타입스크립트 형식 검사를 무력화한다. 선언 합치기를 이용해 `Body` 형식 정의를 덮어쓸 수 있다:

```ts
interface Body {
  json(): Promise<unknown>;
}
```

이제 형식 애너테이션을 추가하는 순간 타입스크립트는 `unknown`을 `Person[]`에 할당할 수 없음을 알려준다:

```ts
const ppl: Person[] = await fetch('/api/people').then((res) => res.json());
// 'unknown' 형식을 'Person[]' 형식에 할당할 수 없습니다. ts(2322)
```

하지만 형식 어서션을 수행하면 오류가 사라진다:

```ts
const ppl = (await fetch('/api/people').then((res) => res.json())) as Person[];
```

이렇게 어서션을 이용해 안전하지 않은 동작을 명시적으로 표현할 수 있다.

> **팁**: `unknown`은 `any`와 비슷하지만 더 안전하다. `any`는 형식 검사를 완전히 무력화하지만, `unknown`은 사용하기 전에 형식을 좁혀야 한다.

## 9.3 defineProperty 사용하기

**문제** `Object.defineProperty`를 사용해 프로퍼티를 즉석에서 정의했는데, 타입스크립트는 이 변화를 인식하지 못한다.

**해결** 래퍼 함수를 만들고 어서션 시그니처를 사용해 객체의 형식을 바꾼다.

**논의** 자바스크립트에서는 `Object.defineProperty`로 객체 프로퍼티를 즉석에서 정의할 수 있다. 특히 프로퍼티를 읽기 전용으로 만들 때 유용하다:

```ts
const storage = {
  currentValue: 0,
};

Object.defineProperty(storage, 'maxValue', {
  value: 9001,
  writable: false,
});

console.log(storage.maxValue); // 9001
storage.maxValue = 2;
console.log(storage.maxValue); // 여전히 9001
```

타입스크립트의 `defineProperty`에는 문제가 있다:

```ts
const storage = {
  currentValue: 0,
};

Object.defineProperty(storage, 'maxValue', {
  value: 9001,
  writable: false,
});

console.log(storage.maxValue);
// '{ currentValue: number; }' 형식에 'maxValue' 속성이 없습니다. ts(2339)
```

### 어서션 시그니처로 해결

어서션 시그니처는 조건 기반 흐름 제어를 사용하지 않았음에도 형식 찬반형처럼 동작한다:

```ts
function assertIsNumber(val: any): asserts val is number {
  if (typeof val !== 'number') {
    throw new AssertionError('Not a number!');
  }
}

function multiply(x: unknown, y: unknown) {
  assertIsNumber(x);
  assertIsNumber(y);
  // 이제 타입스크립트도 x와 y가 숫자임을 안다.
  return x * y;
}
```

### defineProperty 래퍼 함수

```ts
type InferValue<Prop extends PropertyKey, Desc> = Desc extends { get(): any; value: any }
  ? never
  : Desc extends { value: infer T }
  ? Record<Prop, T>
  : Desc extends { get(): infer T }
  ? Record<Prop, T>
  : never;

type DefineProperty<Prop extends PropertyKey, Desc extends PropertyDescriptor> = Desc extends {
  writable: any;
  set(val: any): any;
}
  ? never
  : Desc extends { writable: any; get(): any }
  ? never
  : Desc extends { writable: false }
  ? Readonly<InferValue<Prop, Desc>>
  : Desc extends { writable: true }
  ? InferValue<Prop, Desc>
  : Readonly<InferValue<Prop, Desc>>;

function defineProperty<Obj extends object, Key extends PropertyKey, PDesc extends PropertyDescriptor>(
  obj: Obj,
  prop: Key,
  val: PDesc,
): asserts obj is Obj & DefineProperty<Key, PDesc> {
  Object.defineProperty(obj, prop, val);
}
```

세 개의 제네릭을 사용했다:

- `Obj`: 바꾸려는 객체. `object`의 하위 형식이다.
- `Key`: `PropertyKey`(내장, `string | number | symbol`)의 상위 형식.
- `PDesc`: `PropertyDescriptor`(내장)의 상위 형식. 이를 이용해 모든 기능(쓰기, 열거, 재설정)을 포함하는 프로퍼티를 정의한다.

### 사용 예시

```ts
const storage = {
  currentValue: 0,
};

defineProperty(storage, 'maxValue', {
  writable: false,
  value: 9001,
});

storage.maxValue; // number
storage.maxValue = 2; // 오류! 읽기 전용

const storageName = 'My Storage';
defineProperty(storage, 'name', {
  get() {
    return storageName;
  },
});

storage.name; // string
```

> **노트**: `Object.defineProperty`를 사용할 때 타입스크립트에서 객체 변경을 지원하지 않을 수도 있지만, 향후에는 이런 상황에 사용하도록 형식이나 특수 동작을 추가할 가능성이 있다.

## 9.4 Array.prototype.includes의 형식 확장하기

**문제** 타입스크립트는 아주 좁은 튜플이나 배열에서 `string`이나 `number` 같은 넓은 형식의 요소를 찾지 못한다.

**해결** 형식 매개변수 간의 관계를 바꾸는 형식 찬반형으로 제네릭 헬퍼 함수를 만든다.

**논의** 실행하려는 작업의 집합을 포함하는 `actions` 배열을 만든다:

```ts
// actions: string[]
const actions = ['CREATE', 'READ', 'UPDATE', 'DELETE'];

function execute(action: string) {
  if (actions.includes(action)) {
    // action으로 뭔가 수행함
  }
}
```

`as const`로 const 컨텍스트를 추가하면 `actions`를 더 구체적인 형식으로 줄일 수 있다:

```ts
// actions: readonly ["CREATE", "READ", "UPDATE", "DELETE"]
const actions = ['CREATE', 'READ', 'UPDATE', 'DELETE'] as const;

function execute(action: string) {
  if (actions.includes(action)) {
    // 'string' 형식의 인수는 '"CREATE" | "READ" | "UPDATE" | "DELETE"'
    // 형식의 매개변수에 할당될 수 없습니다. ts(2345)
  }
}
```

`ReadonlyArray<T>`의 `includes`를 살펴보자:

```ts
interface ReadonlyArray<T> {
  includes(searchElement: T, fromIndex?: number): boolean;
}
```

찾으려는 요소(`searchElement`)는 배열 자체와 같은 형식이어야 한다. 따라서 `ReadonlyArray<"CREATE" | "READ" | "UPDATE" | "DELETE">`가 있다면 오직 그 네 문자열 중 하나만 찾을 수 있다.

### 방법 1: ReadonlyArray 재선언

선언 합치기를 이용해 `ReadonlyArray` 구현을 바꿀 수 있다:

```ts
interface ReadonlyArray<T> {
  includes(searchElement: any, fromIndex?: number): searchElement is T;
}
```

```ts
const actions = ['CREATE', 'READ', 'UPDATE', 'DELETE'] as const;

function execute(action: string) {
  if (actions.includes(action)) {
    // action: "CREATE" | "READ" | "UPDATE" | "DELETE"
  }
}
```

하지만 한 가지 문제가 있다. `searchElement`를 `any`로 바꾸면서 형식 검사가 무력화된다. `action`을 `number`로 바꿔도 오류가 발생하지 않는다.

> **팁**: 표준 라이브러리에서 동작을 바꿔 형식 패치를 수행할 때는 전역이 아닌 모듈 범위로 지정해야 한다.

### 방법 2: 형식 어서션을 이용한 헬퍼

헬퍼 함수를 이용해 형식 매개변수 간의 관계를 바꿀 수 있다:

```ts
function includes<T extends U, U>(coll: ReadonlyArray<T>, el: U): el is T {
  return coll.includes(el as T);
}
```

`includes` 함수는 `ReadonlyArray<T>`를 인수로 받아 형식이 `U`인 요소를 검색한다. 제네릭 바운드를 통해 `T`가 `U`를 확장(`T extends U`)하는지, 즉 `U`가 `T`의 상위 집합인지 확인한다.

```ts
function execute(action: number) {
  if (includes(actions, action)) {
    // 'readonly ["CREATE", "READ", "UPDATE", "DELETE"]' 형식의 인수는
    // 'readonly number[]' 형식의 매개변수에 할당될 수 없습니다.
  }
}
```

이렇게 원하는 기능을 구현했다. 타입스크립트는 우리가 찾는 요소가 아니라 배열을 바꾸도록 권장한다는 점이 핵심이다.

> **팁**: `Array.prototype.indexOf`에서 발생하는 비슷한 문제에도 이 해결 방법을 적용할 수 있다.

## 9.5 널 종류의 값 거르기

**문제** 배열에서 널 종류의 값(nullish)을 거르는 `Boolean` 생성자를 사용하려 하는데 타입스크립트는 여전히 `null`과 `undefined`를 포함한 같은 형식을 반환한다.

**해결** 선언 합치기로 `Array`의 `filter` 메서드를 오버로드한다.

**논의** 때로 컬렉션은 널 종류의 값(`undefined`나 `null`)을 포함한다:

```ts
// const array: (number | null | undefined)[]
const array = [1, 2, 3, undefined, 4, null];
```

`Boolean` 생성자로 값을 전달해 진실성(truthy)을 확인할 수 있다:

```ts
// const array: (number | null | undefined)[]
const filtered = array.filter(Boolean);
```

안타깝게도 이 코드는 형식을 바꾸지 않는다. 필터링을 수행한 결과는 여전히 `null`과 `undefined` 형식을 포함한다.

### Array 인터페이스 확장

```ts
interface Array<T> {
  filter(predicate: BooleanConstructor): NonNullable<T>[];
}

interface ReadonlyArray<T> {
  filter(predicate: BooleanConstructor): NonNullable<T>[];
}
```

이렇게 하면 널 종류의 값을 제거해 배열 콘텐츠 형식을 더 명확하게 만들 수 있다:

```ts
// const filtered: number[]
const filtered = array.filter(Boolean);
```

### Truthy 형식으로 확장

`BooleanConstructor`는 널 값뿐만 아니라 거짓으로 평가되는 값(falsy)도 거른다. `NonNullable<T>`를 반환할 뿐만 아니라 진실성을 검사하는 형식을 이용해야 올바른 요소를 얻을 수 있다:

```ts
type Truthy<T> = T extends '' | false | 0 | 0n ? never : T;

interface Array<T> {
  filter(predicate: BooleanConstructor): Truthy<NonNullable<T>>[];
}

interface ReadonlyArray<T> {
  filter(predicate: BooleanConstructor): Truthy<NonNullable<T>>[];
}
```

```ts
const array = [0, 1, 2, 3, '', -0, 0n, false, undefined, null] as const;
// const filtered: (1 | 2 | 3)[]
const filtered = array.filter(Boolean);

const nullOrOne: Array<0 | 1> = [0, 1, 0, 1];
// const onlyOnes: 1[]
const onlyOnes = nullOrOne.filter(Boolean);
```

> **노트**: `0n`은 BigInt 형식의 0이다. 이 형식은 ECMAScript 2020 이상에서만 사용할 수 있다.

## 9.6 모듈 확장하기

**문제** 프리액트나 리액트처럼 HTML 요소의 자체 뷰를 제공하는 라이브러리를 사용 중이다. 하지만 이들의 형식 정의가 최신 기능을 포함하지 않을 때가 있어서 패치하고 싶다.

**해결** 모듈과 인터페이스 수준에서 선언 합치기를 사용한다.

**논의** JSX는 자바스크립트의 확장 문법으로, XML과 비슷한 방식으로 컴포넌트를 설명하고 중첩하는 기능을 제공한다:

```tsx
<button onClick={() => alert('YES')}>Click me</button>;
// 다음으로 트랜스파일됨
React.createElement('button', { onClick: () => alert('YES') }, 'Click me');
```

### 이미지의 lazy loading 속성 추가

크롬의 최신 이미지 기능을 사용하는 상황에서 이미지를 게으르게 불러오고 싶다고 가정해 보자:

```tsx
<img src="/awesome.jpg" loading="lazy" alt="What an awesome image" />
```

타입스크립트 JSX 코드에서는 오류가 발생한다:

```tsx
function Image({ src, alt }) {
  // 'loading' 프로퍼티는 존재하지 않음
  return <img src={src} alt={alt} loading="lazy" />;
}
```

### React 형식 확장

`@types` 폴더를 만들고 안에 `jsx.d.ts` 파일을 추가한다:

```ts
import 'react';

declare module 'react' {
  interface ImgHTMLAttributes<T> extends HTMLAttributes<T> {
    loading?: 'lazy' | 'eager' | 'auto';
    alt: string; // alt도 필수로 만든다
  }
}
```

타입스크립트 설정에서 추가 형식을 허용하도록 컴파일러 옵션을 설정한다:

```json
{
  "compilerOptions": {
    "types": ["@types/**"]
  }
}
```

타입스크립트는 원래 정의를 가져와 선언을 합친다. 자동 완성 기능은 사용 가능한 모든 옵션을 제공한다. 그리고 대체 텍스트를 깜빡 잊으면 오류가 발생한다.

### Preact 형식 확장

프리액트를 이용하면 상황이 더 복잡해진다. 원래 HTML 형식은 리액트 형식만큼 구체적이지 않다:

```ts
declare namespace JSX {
  interface IntrinsicElements {
    img: HTMLAttributes & {
      alt: string;
      src: string;
      loading?: 'lazy' | 'eager' | 'auto';
    };
  }
}
```

선언 합치기는 네임스페이스, 인터페이스 및 모듈 수준에서 동작한다.

## 9.7 전역 네임스페이스에 추가하기

**문제** `ResizeObserver`와 같은 브라우저 기능을 사용했는데, 현재 타입스크립트 설정에서 해당 기능을 사용할 수 없음을 확인했다.

**해결** 전역 네임스페이스에 사용자 정의 형식 정의를 추가한다.

**논의** 타입스크립트는 `lib.dom.d.ts`에 모든 DOM API 형식을 저장한다. 이들 파일은 웹 IDL(Web Interface Definition Language) 파일을 통해 자동 생성된다.

사양이 충분히 완성되고 모든 주요 브라우저에서 지원되기 시작하면, 사람들은 새로운 리소스를 추가하고 곧 출시될 타입스크립트 버전에서 변경 사항을 확인할 수 있다. 따라서 `lib.dom.d.ts`에 `ResizeObserver`이 추가되는 것은 시간 문제일 뿐이다.

기다릴 수 없다면 현재 작업 중인 프로젝트에만 직접 형식을 추가할 수 있다.

### ResizeObserver 형식 정의

`resize-observer.d.ts`라는 파일에 형식을 저장한다:

```ts
type ResizeObserverBoxOptions = 'border-box' | 'content-box' | 'device-pixel-content-box';

interface ResizeObserverOptions {
  box?: ResizeObserverBoxOptions;
}

interface ResizeObserver {
  disconnect(): void;
  observe(target: Element, options?: ResizeObserverOptions): void;
  unobserve(target: Element): void;
}

interface ResizeObserverEntry {
  readonly borderBoxSize: ReadonlyArray<ResizeObserverSize>;
  readonly contentBoxSize: ReadonlyArray<ResizeObserverSize>;
  readonly contentRect: DOMRectReadOnly;
  readonly devicePixelContentBoxSize: ReadonlyArray<ResizeObserverSize>;
  readonly target: Element;
}

interface ResizeObserverSize {
  readonly blockSize: number;
  readonly inlineSize: number;
}

interface ResizeObserverCallback {
  (entries: ResizeObserverEntry[], observer: ResizeObserver): void;
}

declare var ResizeObserver: {
  prototype: ResizeObserver;
  new (callback: ResizeObserverCallback): ResizeObserver;
};
```

### 전역 네임스페이스 확장

전역 네임스페이스에는 전 세계에서 사용할 수 있는 모든 객체와 인터페이스를 포함한다. `window` 객체를 비롯해 자바스크립트 실행 컨텍스트의 일부가 되어야 하는 다른 모든 객체가 여기에 포함된다:

```ts
declare global {
  var ResizeObserver:
    | {
        prototype: ResizeObserver;
        new (callback: ResizeObserverCallback): ResizeObserver;
      }
    | undefined;
}
```

`ResizeObserver`를 `undefined`로도 설정하면 객체를 사용할 수 있는지 확인할 수 있다.

### tsconfig.json 설정

`resize-observer.d.ts`를 `@types` 폴더에 넣고, `tsconfig.json`에 추가한다:

```json
{
  "compilerOptions": {
    "typeRoots": ["@types", "./node_modules/@types"]
  },
  "include": ["src", "@types"]
}
```

### 사용 예시

```ts
if (typeof ResizeObserver !== 'undefined') {
  const x = new ResizeObserver((entries) => {});
}
```

> **팁**: 앰비언트 선언 파일과 전역 형식을 타입스크립트가 인식하지 못할 때는 다음을 확인한다:
>
> - `tsconfig.json`의 `include` 속성으로 `@types` 폴더를 파싱한다.
> - 앰비언트 형식 선언 파일을 `tsconfig.json` 컴파일러 옵션의 `types`나 `typeRoots`에 추가한다.
> - 앰비언트 선언 파일의 끝에 `export {}`를 추가하면 타입스크립트는 이 파일을 모듈로 인식한다.

## 9.8 자바스크립트가 아닌 모듈을 모듈 그래프로 추가하기

**문제** 웹팩과 같은 번들러로 자바스크립트에서 CSS나 이미지와 같은 파일을 불러왔는데, 타입스크립트는 이러한 파일을 인식하지 못한다.

**해결** 파일명 확장자에 기반해 모듈을 전역으로 선언한다.

**논의** 웹 개발 업계에서는 자바스크립트를 모든 것의 기본 진입점으로 삼고 임포트 문으로 모든 관련 자산을 처리하도록 하는 경향이 있다. 웹팩은 CSS, 마크다운, SVG, JPEG 등 모든 것을 번들링할 수 있는 자바스크립트 번들러다:

```ts
// 다음처럼
import './Button.css';
// 또는 다음처럼
import styles from './Button.css';
```

웹팩은 로더라는 개념을 사용해 파일 엔딩을 살펴본 다음 특정 번들링 개념을 활성화한다. 자바스크립트에서 CSS 파일을 가져오는 것은 기본 기능이 아니다. 이 기능은 웹팩(또는 사용 중인 번들러)의 일부다.

### 앰비언트 모듈 선언

타입스크립트는 '물리적으로' 존재하지 않지만 환경에 있거나 도구를 통해 접근할 수 있는 모듈에도 앰비언트 모듈 선언(ambient module declaration)을 지원한다:

```ts
declare module 'path' {
  export function normalize(p: string): string;
  export function join(...paths: any[]): string;
  export var sep: string;
}
```

와일드카드 패턴에도 동일한 기법을 사용할 수 있다.

### CSS 모듈 선언

```ts
declare module '*.css' {
  interface IClassNames {
    [className: string]: string;
  }
  const classNames: IClassNames;
  export default classNames;
}
```

이제 파일을 다시 컴파일할 수 있다. 유일한 단점은 자동 완성 등의 기능에서 정확한 클래스 이름을 사용할 수 없다는 것이다. 형식 파일을 자동으로 생성해 이 문제를 해결한다. NPM에는 이 문제를 해결하는 데 사용할 다양한 패키지를 제공한다.

### MDX 모듈 선언

MDX를 사용하면 마크다운을 작성할 수 있고, 이 마크다운은 일반 React(또는 JSX) 컴포넌트로 파싱된다:

```ts
declare module '*.mdx' {
  let MDXComponent: (props: any) => JSX.Element;
  export default MDXComponent;
}
```

이제 자바스크립트에서 mdx 파일을 불러와 컴포넌트로 사용할 수 있다:

```tsx
import About from '../articles/about.mdx';

function App() {
  return (
    <>
      <About />
    </>
  );
}
```

### 단순 모듈 선언

무엇을 기대해야 할지 모르겠다면 편하게 생각하자. 모듈을 선언하기만 하면 된다. 형식을 제공할 필요가 없다. 타입스크립트는 이를 로딩하지만 형식 안전성은 제공하지 않는다:

```ts
declare module '*.svg';
```

### tsconfig.json 설정

앱에서 앰비언트 모듈을 사용하려면 프로젝트 어딘가(아마도 루트 수준)에 `@types` 폴더를 만드는 것이 좋다. 이 폴더에 모듈 정의가 포함된 `.d.ts` 파일을 얼마든지 추가할 수 있다:

```json
{
  "compilerOptions": {
    "typeRoots": ["./node_modules/@types", "./@types"]
  }
}
```

`tsconfig.json`에 이 폴더의 참조를 추가하면 나머지는 타입스크립트가 알아서 처리한다.

> **노트**: ECMAScript 표준 위원회에는 자바스크립트 이외의 파일 가져오기를 허용하도록 내장 형식을 제공하자고 주장하는 제안이 있다. 이는 언젠가 타입스크립트에 영향을 미칠 것이다.
