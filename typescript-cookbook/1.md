# 1장 프로젝트 설정

## 1.1 자바스크립트 형식 검사하기
**문제** 최소한의 노력으로 자바스크립트에 형식 검사 기능을 추가하려 한다.

**해결** 모든 자바스크립트 파일 상단에 `// @ts-check` 주석을 붙이고 JSDoc 주석으로 함수·객체 형식을 알린다.

타입스크립트는 자바스크립트의 상위 집합이므로 기존 JS 코드를 그대로 검사할 수 있다. VS Code처럼 타입스크립트를 이해하는 IDE에 `// @ts-check`를 추가하면 곧바로 형식 오류를 확인할 수 있고, JSDoc 주석으로 인수·반환 값을 명시해 자동 완성과 오류 탐지를 강화할 수 있다. 필요 시 `// @ts-expect-error`로 임시 예외를 남겨 리팩터링 중 발생한 오류를 추후에 정리할 수 있다.

```ts
// @ts-check

/**
 * VAT를 더한 금액을 반환한다.
 * @param {number} price 원금
 * @param {number} [vat=0.2] 부가가치세 비율(0~1)
 * @returns {number}
 */
function addVAT(price, vat = 0.2) {
  return price * (1 + vat);
}

addVAT(100, 0.2);
// @ts-expect-error - 문자열은 허용하지 않음을 확인
addVAT(100, "0.2");
```

실제로 도입할 때는 아래 순서를 따르면 된다.

1. `// @ts-check` 주석을 파일 최상단에 추가한다. 편집기가 즉시 타입스크립트 서비스(언어 서버)를 작동시켜 오류를 표시한다.
2. 함수나 객체 선언에 JSDoc을 붙여 인수·반환 타입을 명시한다. `@param`의 기본값 표기(`[]`)나 `@returns` 주석은 자동 완성 목록에도 그대로 반영된다.
3. 타입 오류가 발생했는데 지금 당장 해결할 수 없다면 `// @ts-expect-error`를 덧붙인다. 이 주석은 “이 줄에 오류가 나는 것이 의도”임을 컴파일러에 알려 주고, 나중에 해결하면 주석을 제거했을 때 오류가 사라지는지 확인해 준다.

이렇게 하면 자바스크립트 프로젝트에서도 별도의 빌드 단계 없이 “IDE 상에서만” 타입 검사를 누릴 수 있다. 점진적으로 타입 정밀도를 높이면서도, 완전한 타입스크립트 전환을 위한 발판을 마련하는 셈이다.

## 1.2 타입스크립트 설치하기
**문제** 에디터 경고만으로는 부족하다. 명령줄 피드백과 정식 컴파일 설정이 필요하다.

**해결** 프로젝트를 `npm init`으로 초기화하고 `npm install --save-dev typescript`로 컴파일러를 설치한 뒤 `npx tsc --init`으로 `tsconfig.json`을 만든다.

Node.js 환경을 준비한 뒤 `rootDir`, `outDir` 같은 기본 옵션을 지정하면 소스와 출력물 폴더를 분리할 수 있다. `npx tsc`를 실행하면 `src` 아래의 `.ts` 파일을 `dist`에 컴파일한다.

```jsonc
// tsconfig.json
{
  "compilerOptions": {
    "target": "es2019",
    "module": "commonjs",
    "rootDir": "./src",   // 소스 위치
    "outDir": "./dist",    // 컴파일 결과 위치
    "strict": true,
    "esModuleInterop": true
  }
}
```

```ts
// src/index.ts
console.log("Hello World");
```

```bash
$ npm init -y
$ npm install --save-dev typescript
$ npx tsc --init
$ npx tsc
```

터미널에서 `npx tsc`를 실행하면 다음과 같은 흐름이 진행된다.

- `tsconfig.json`의 `rootDir` 아래에 있는 `.ts` 파일을 찾는다. 기본값은 현재 디렉터리지만, 관습적으로 `src`를 사용해 소스 코드 위치를 명확히 분리한다.
- 각 파일을 `target`(여기서는 `es2019`)에 맞춰 다운레벨링하고, `outDir`에 지정된 폴더(`dist`)로 JavaScript 결과물을 출력한다.
- `strict: true` 설정이 있다면 모든 타입 검사를 엄격하게 수행하고, 오류가 발생하면 종료 코드가 1로 설정되어 CI에서도 쉽게 감지할 수 있다.

IDE 경고에서 한 걸음 더 나아가 “컴파일러가 실패하면 빌드가 멈추는” 구조를 마련한 셈이다. 이후 장에서 필요한 옵션을 계속 추가하게 되지만, 이 초깃값만으로도 프로젝트를 타입스크립트 기반으로 운영할 수 있다.

## 1.3 형식을 나란히 유지하기
**문제** 기존 자바스크립트 코드에서 복잡한 형식 정보를 IDE가 이해하도록 유지하고 싶지만, JSDoc만으로는 한계가 있다.

**해결** `.d.ts` 선언 파일을 만들어 타입 정보를 별도 관리하고 `checkJs`, `noEmit` 옵션으로 JS 파일도 실시간으로 검사한다.

`@types` 폴더에 인터페이스를 선언하고, JS 파일에서는 `import()` JSDoc 구문으로 형식을 끌어온다. `tsconfig.json`에서 `checkJs: true`, `noEmit: true`를 켜면 타입 검사를 하면서도 JS 파일을 다시 출력하지 않는다.

```ts
// @types/person.d.ts
export interface Person {
  name: string;
  age: number;
}

export interface Student extends Person {
  semester: number;
}
```

```ts
// src/index.js
// @ts-check
/** @typedef {import("../@types/person").Person} Person */

/**
 * @param {Person} person
 */
function printPerson(person) {
  console.log(person.name);
}

printPerson({ name: "Stefan", age: 40 });
```

```jsonc
// tsconfig.json
{
  "compilerOptions": {
    "checkJs": true,    // JS 파일 검사
    "noEmit": true      // 출력물 생성 생략
  }
}
```

선언 파일 전략은 다음과 같은 문제를 풀어 준다.

- **형식과 구현 분리**: `.d.ts` 파일은 런타임 코드가 없으므로 번들 크기에 영향을 주지 않는다. 팀 내 다른 자바스크립트 코드에서도 동일한 선언 파일을 재사용할 수 있다.
- **IDE 친화성**: `@ts-check`가 켜진 JS 파일은 `import("../@types/person").Person` 구문을 통해 타입을 가져올 수 있다. 이름이 바뀌면 선언 파일만 수정하면 되고, 모든 호출부가 즉시 알림을 받는다.
- **점진적 적용**: `checkJs: true`, `noEmit: true` 조합은 “JS 파일을 검사하되 컴파일 결과는 버린다”는 의미다. 따라서 빌드 파이프라인을 건드리지 않고도 타입 검사를 기존 JS 코드에 적용할 수 있다.

프로젝트 규모가 커질수록 선언 파일을 `@types` 폴더 아래로 모아 두고, 모듈 이름과 일치하도록 폴더를 나누면 충돌 없이 관리할 수 있다.

## 1.4 프로젝트를 타입스크립트로 바꾸기
**문제** 프로젝트 전체를 타입스크립트로 전환하려고 `.js`를 `.ts`로 바꾸자마자 오류가 쏟아진다.

**해결** `allowJs`, `strict` 등의 설정을 조정하며 파일을 하나씩 `.ts`로 전환하고, 필요한 곳에 `any`나 `@ts-expect-error`를 명시적으로 사용해 이행 과정을 관리한다.

점진적으로 파일 확장자를 바꾸면서 타입 오류를 해결한다. 외부 라이브러리가 형식을 제공하지 않을 때는 일시적으로 `any`를 쓰거나 함수 경계에 보호막을 추가한다. 변환 과정에서 남겨둔 `@ts-expect-error`는 추후 정리하며 안전하게 마이그레이션을 완료한다.

```ts
// utils/math.ts
export function toNumber(value: unknown): number {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    const parsed = Number(value);
    if (!Number.isNaN(parsed)) {
      return parsed;
    }
  }
  throw new TypeError("숫자로 변환할 수 없습니다.");
}
```

```ts
// legacy.ts (변환 중)
// @ts-expect-error - 아직 any를 반환하는 외부 라이브러리
const amount = (legacyApi as any).getAmount();
const total = toNumber(amount);
```

```jsonc
// tsconfig.json
{
  "compilerOptions": {
    "allowJs": true,            // JS와 TS 혼용 허용
    "checkJs": false,           // 변환이 끝난 뒤 다시 true로
    "noEmitOnError": false,     // 오류가 있어도 출력 가능
    "strict": true
  },
  "include": ["src/**/*"]
}
```

마이그레이션을 진행할 때는 다음 전략을 따르면 안정적으로 전환할 수 있다.

1. **`allowJs` 켜기**: 기존 `.js` 파일을 유지한 채 새 `.ts` 파일을 추가할 수 있다. 컴파일 결과에 두 언어가 공존해도 엔트리 포인트가 동일하면 런타임은 변하지 않는다.
2. **확장자를 순차적으로 변경**: 한 번에 모든 파일을 `.ts`로 바꾸지 말고, 기능 단위로 전환한다. 해당 파일에서 발생한 오류를 해결한 뒤 다음 파일로 넘어간다.
3. **교차 경계에 보호막 두기**: 아직 타입이 정리되지 않은 모듈은 `any` 또는 `unknown`을 명시하고, 타입이 명확한 함수(예: `toNumber`) 안에서 검증한다. 리팩터링이 끝나면 `any` 선언을 제거한다.
4. **`@ts-expect-error` 관리**: 임시로 넣은 예외 주석은 TODO 리스트처럼 취급한다. 주석이 붙은 줄에서 오류가 사라지면 컴파일러가 “예상한 오류가 발생하지 않았다”고 경고하므로 정리 시점을 놓치지 않는다.

이런 방식으로 변환하면 릴리스 일정에 영향 없이도 타입스크립트로 서서히 옮겨 갈 수 있다. CI에 `npx tsc --noEmit`을 추가해 늘 오류가 없는 상태를 유지하는 것도 좋은 습관이다.

## 1.5 DefinitelyTyped에서 형식 불러오기
**문제** 타입스크립트로 작성되지 않은 의존성이 형식 정의를 제공하지 않는다.

**해결** 커뮤니티가 관리하는 `@types/*` 패키지를 설치하고 `typeRoots`·`types` 옵션으로 원하는 전역 형식을 제어한다.

`npm` 페이지에서 DT 로고(DT 배지)가 붙은 패키지는 `npm install --save-dev @types/패키지명`으로 설치할 수 있다. 타깃 프로젝트의 `typeRoots`를 커스터마이즈하거나 `types` 배열로 특정 형식만 로드하면 전역 선언 충돌을 피할 수 있다.

```bash
$ npm install react
$ npm install --save-dev @types/react
```

```jsonc
// tsconfig.json
{
  "compilerOptions": {
    "types": ["node", "jest"],          // 필요한 전역 형식 제한
    "typeRoots": [
      "./typings",                        // 사용자 정의 선언
      "./node_modules/@types"            // DefinitelyTyped
    ]
  }
}
```

```ts
import _ from "lodash";
const flat = _.flattenDeep([1, [2, [3, [4]], 5]]); // lodash 형식 정보 활용
```

`@types` 패키지를 사용할 때 기억해야 할 점은 다음과 같다.

- 대부분의 유명 라이브러리는 DefinitelyTyped 레포지토리에서 형식을 관리한다. 패키지 페이지에 `TypeScript` 또는 `DT` 배지가 있으면 `@types/` 네임스페이스를 확인한다.
- 전역 타입 오염을 막으려면 `tsconfig.json`의 `types` 배열에 필요한 패키지를 명시한다. 예를 들어 `["node", "jest"]`라고 적으면 다른 전역 선언(예: `@types/jquery`)은 자동으로 로드되지 않는다.
- 커뮤니티 타입 정의가 없거나 오래됐다면 직접 `.d.ts` 파일을 만들어 `typeRoots`에 등록할 수 있다. 로컬 선언과 DefinitelyTyped를 혼용할 때는 충돌을 피하기 위해 폴더 구조를 명확히 구분한다.

이렇게 하면 런타임 구현은 JavaScript로 남아 있더라도, 타입 시스템이 제공하는 안전장치를 빠짐없이 사용할 수 있다.

## 1.6 풀스택 프로젝트 설정하기
**문제** Node.js 서버와 브라우저 클라이언트를 동시에 개발하면서 공용 모델·유틸을 공유하고 싶다.

**해결** 서버, 클라이언트, 공유 코드 각각에 `tsconfig.json`을 만들고 `composite`과 `references`를 이용해 프로젝트 참조를 구성한다.

`shared/tsconfig.json`에서 `composite: true`와 `declaration: true`를 켜면 다른 프로젝트가 `shared`를 의존성처럼 참조할 수 있다. 서버와 클라이언트의 `tsconfig.json`에는 `references` 배열을 추가해 `shared`를 빌드 순서에 포함시킨다.

```jsonc
// shared/tsconfig.json
{
  "compilerOptions": {
    "composite": true,            // 다른 프로젝트에서 참조 가능
    "declaration": true,          // d.ts 출력
    "target": "esnext",
    "module": "esnext",
    "rootDir": "../shared",
    "outDir": "../dist/shared",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "types": []
  }
}
```

```jsonc
// server/tsconfig.json
{
  "extends": "../tsconfig.base.json",
  "references": [{ "path": "../shared/tsconfig.json" }]
}
```

이 방식은 모델·형식만 공유할 때 특히 효과적이다. 런타임 구현까지 공유하려면 번들러를 사용하거나 Node/브라우저 모두에서 이해할 수 있는 ESM 결과물로 빌드되도록 별도 빌드 파이프라인을 추가해야 한다.

프로젝트 참조를 사용할 때의 흐름은 다음과 같다.

1. `shared`가 먼저 컴파일된다. `composite: true`와 `declaration: true`가 켜져 있어야 `tsc -b`가 빌드 순서를 계산하고, 다른 프로젝트가 `shared`의 `.d.ts` 결과물을 소비할 수 있다.
2. `server`와 `client`는 각자의 `tsconfig.json`에서 `references` 배열을 통해 `shared`를 의존성으로 선언한다. `tsc -b packages/server`를 실행하면 필요한 경우 `shared`가 자동으로 빌드된다.
3. 루트 `tsconfig.json`에 `references`를 나열해 두면 `tsc -b`만으로 모노레포 전체를 순서대로 빌드할 수 있다. `--watch` 옵션도 참조 그래프를 감안해 변경된 프로젝트만 다시 컴파일한다.

폴더가 많아질수록 `tsconfig.base.json` 같은 공통 설정 파일을 두고, 각 패키지의 설정 파일은 필요한 부분만 덮어써 중복을 줄이는 것이 좋다.


## 1.7 테스트 설정하기
**문제** Mocha, Jest 같은 테스트 런너가 전역으로 노출하는 심벌이 제품 코드와 충돌하거나 빌드에 섞이는 문제가 있다.

**해결** 공통 설정(`tsconfig.base.json`)을 만든 뒤 개발용(`tsconfig.json`)과 빌드용(`tsconfig.build.json`)을 분리해 테스트 파일을 제외한다. 테스트 실행은 `ts-node/register` 등으로 간소화한다.

```jsonc
// tsconfig.base.json
{
  "compilerOptions": {
    "target": "esnext",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "outDir": "./dist",
    "skipLibCheck": true
  }
}
```

```jsonc
// tsconfig.json (개발용)
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "types": ["node", "mocha"],   // 전역 describe/it 사용
    "rootDirs": ["src", "test"]
  },
  "include": ["src", "test"]
}
```

```jsonc
// tsconfig.build.json (배포용)
{
  "extends": "./tsconfig.base.json",
  "exclude": ["**/*.test.ts", "test"],   // 테스트 파일 제거
  "compilerOptions": {
    "types": ["node"],
    "declaration": true
  }
}
```

```bash
$ npm install --save-dev mocha @types/mocha @types/node ts-node
$ npx mocha -r ts-node/register "test/**/*.ts"
```

핵심은 “런타임 코드와 테스트 전용 설정을 분리”하는 데 있다.

- 개발 시에는 `types`에 `mocha`를 포함해 `describe`, `it` 같은 전역 심벌을 인식하도록 한다. 빌드 시에는 `types`에서 빼서 배포 번들에 테스트 전용 타입이 섞이지 않게 한다.
- `rootDirs`에 `src`와 `test`를 함께 넣으면 상대 경로 대신 모듈 경로로 테스트 파일이 제품 코드를 참조할 수 있다. 이는 모듈 해석 시 두 디렉터리를 하나의 가상 루트로 취급하겠다는 뜻이다.
- `ts-node/register`는 런타임에서 타입스크립트를 즉시 트랜스파일한다. 테스트 실행 속도가 중요하면 `ts-node/register/transpile-only`처럼 타입 검사를 생략하고, 빌드 단계에서 `tsc --noEmit`으로 별도 검사하는 전략도 가능하다.

이 패턴을 적용하면 테스트 러너가 가져다 쓰는 전역 심벌과 실제 제품 코드의 타입 공간을 깔끔하게 분리할 수 있다.

## 1.8 URL로 ECMAScript 모듈 형식화하기
**문제** 브라우저 네이티브 ESM 환경에서 원본 문법을 유지하고 원격 CDN 모듈까지 타입 검사를 하고 싶다.

**해결** `target`과 `module`을 `esnext`로 설정하고, 실제 가져올 경로에 `.js` 확장자를 명시한다. 원격 모듈은 `paths`로 형식 정의를 연결하거나 직접 `@types/*` 패키지를 설치한다.

```jsonc
// tsconfig.json
{
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "moduleResolution": "node",
    "paths": {
      "https://esm.sh/lodash@4.17.21": [
        "./node_modules/@types/lodash/index.d.ts"  // CDN URL에 대응하는 형식
      ]
    }
  }
}
```

```ts
// src/index.ts
import { obj } from "./module.js"; // .ts 파일이지만 .js로 가져와 브라우저와 맞춘다
import _ from "https://esm.sh/lodash@4.17.21";

console.log(obj.name);
console.log(_.flattenDeep([1, [2, [3, [4]], 5]]));
```

```bash
$ npm install --save-dev @types/lodash
```

필요 시 `// @ts-ignore`로 특정 import만 예외 처리할 수 있지만, 장기적으로는 타입 정의를 연결하는 편이 안전하다.

브라우저 ESM 환경에서 주의할 점은 다음과 같다.

- 실제 파일 확장자를 명시해야 한다. 타입스크립트가 `.ts`를 `.js`로 바꿔 출력하더라도 브라우저는 정적 분석으로 경로를 그대로 사용하기 때문에 `import "./module.js"`처럼 작성해야 한다.
- CDN 모듈과 로컬 타입 정의를 연결하려면 `paths` 또는 `typesVersions` 같은 기능을 활용한다. 위 예제에서는 CDN URL을 키로 사용해 로컬 `@types/lodash` 정의로 매핑했다.
- Vite, Snowpack 같은 도구도 동일한 패턴을 따른다. 개발 서버는 상대 경로에 `.ts`를 허용해 줄 수 있지만, 정적 배포를 염두에 두면 처음부터 `.js` 확장자를 사용하는 편이 불필요한 오류를 방지한다.


## 1.9 노드에서 다른 모듈 형식 불러오기
**문제** Node.js에서 ESM을 사용하되 CommonJS 라이브러리와도 상호 운용해야 한다.

**해결** `moduleResolution`을 `nodenext`로 지정하고 파일 확장자를 `.mts`(ESM) 또는 `.cts`(CommonJS)로 구분한다. `package.json`의 `exports` 필드로 각 모듈 시스템의 진입점을 제공한다.

```jsonc
// package.json
{
  "type": "module",
  "exports": {
    ".": {
      "import": "./esm/index.js",       // ESM 소비자용
      "require": "./commonjs/index.cjs"  // CommonJS 소비자용
    }
  },
  "main": "./commonjs/index.cjs"
}
```

```jsonc
// tsconfig.json
{
  "compilerOptions": {
    "module": "esnext",
    "moduleResolution": "nodenext",   // 확장자별 해석 규칙 적용
    "declaration": true,
    "outDir": "./dist"
  }
}
```

```ts
// src/person.mts (ESM)
export type Person = {
  name: string;
  age: number;
};

export function printPerson(person: Person) {
  console.log(person.name);
}
```

```ts
// src/index.cts (CommonJS)
import type { Person } from "./person";
const { printPerson } = require("./person.cjs");

printPerson({ name: "Stefan", age: 40 } satisfies Person);
```

Node 18 이후에는 `type: "module"`이 기본 ESM을 의미하지만, 여전히 많은 패키지가 CommonJS로 배포된다. 위 설정은 다음 상황을 해결한다.

- `moduleResolution: "nodenext"`는 import 경로가 `.mts`, `.cts`, `.mjs`, `.cjs`인지에 따라 ESM 또는 CommonJS 규칙을 자동 적용한다. 확장자를 생략하면 타입스크립트가 올바른 파일을 찾지 못할 수 있으므로 명확히 구분한다.
- `exports` 필드에서 `import`/`require`를 동시에 제공하면, 소비자가 어떤 모듈 시스템을 사용하든 동일 패키지에서 적절한 엔트리 포인트를 선택한다.
- `satisfies` 연산자는 CommonJS `require` 결과가 `Person` 타입과 호환되는지 검사하면서, `Person` 구조 자체를 좁히거나 변환하지 않는다. 마이그레이션 중에 타입 안전성을 잃지 않기 위해 필수적인 기법이다.

필요하다면 `.d.cts`, `.d.mts` 파일을 통해 선언도 모듈 시스템별로 분리할 수 있다. 이렇게 하면 Node.js 런타임과 타입 시스템 모두에서 일관된 동작을 보장한다.

## 1.10 디노와 의존성 이용하기
**문제** Deno 환경에서 타입스크립트를 실행하고, URL 기반 의존성을 타입 안전하게 다루고 싶다.

**해결** `deno run`은 타입스크립트를 바로 이해하므로 별도 컴파일이 필요 없다. `deno.json`으로 컴파일러 옵션과 사용 라이브러리를 정의하고, 필요 시 `@deno-types` 지시어로 형식을 연결한다.

```ts
// main.ts
function sayHello(name: string) {
  console.log(`Hello ${name}`);
}

sayHello("Stefan");
```

```bash
$ deno run main.ts
```

```jsonc
// deno.json
{
  "compilerOptions": {
    "target": "esnext",
    "lib": ["dom", "dom.iterable", "dom.asynciterable", "deno.ns"]
  },
  "fmt": {
    "useTabs": false
  }
}
```

```ts
/// <reference types="./charting.d.ts" />
import * as charting from "./charting.js"; // charting.d.ts로 형식 연결
```

CDN 의존성은 `X-TypeScript-Types` 헤더를 지원하므로 추가 설정 없이도 형식 정보를 전달한다. 직접 제공하지 않는다면 `@deno-types` 주석으로 `.d.ts` 파일을 매핑하면 된다.

덧붙여 기억할 사항은 다음과 같다.

- `deno.json`의 `compilerOptions`는 TypeScript의 `tsconfig.json`과 거의 동일하게 동작한다. 다만 Deno는 기본적으로 `--strict`에 해당하는 옵션을 활성화하므로, 완화하려면 명시적으로 옵션을 끄거나 `deno.json`에 덮어써야 한다.
- URL로 의존성을 가져오면 해당 URL이 곧 모듈 식별자가 된다. 재사용성을 높이고 싶다면 `import_map.json`을 작성해 별칭을 부여한다.
- `deno cache` 명령을 실행하면 원격 모듈을 미리 받아 local cache에 저장할 수 있다. CI에서는 `deno task`를 정의해 빌드·테스트 과정을 자동화하는 것이 일반적이다.


## 1.11 미리 정의된 설정 사용하기
**문제** 프레임워크나 런타임별 최적 설정을 스스로 작성하기 어렵다.

**해결** 커뮤니티가 관리하는 `tsconfig/bases` 프리셋을 `extends`로 불러온다.

`@tsconfig/*` 패키지를 설치해 `tsconfig.json`의 `extends`에 연결하면 곧바로 권장 옵션을 사용할 수 있다. 예를 들어 Node.js 18 + ESM + Strict 환경은 다음과 같이 적용한다.

```bash
$ npm install --save-dev @tsconfig/node18-strictest-esm
```

```jsonc
// tsconfig.json
{
  "extends": "@tsconfig/node18-strictest-esm/tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"       // 프로젝트별 경로만 추가로 지정
  }
}
```

프리셋에는 `strict` 옵션 세트, `importsNotUsedAsValues` 같은 안전장치까지 포함돼 있어 프로젝트별 세부 설정만 더해주면 된다.

활용 요령은 다음과 같다.

- 프리셋이 이미 `lib`, `target`, `moduleResolution` 등을 지정하므로, 프로젝트마다 다른 값을 사용하고 싶다면 `compilerOptions`에서 필요한 항목만 덮어쓴다.
- 개발·테스트·빌드용 설정을 분리할 경우 공통 프리셋을 한 번 더 확장하면 된다. 예를 들어 `tsconfig.base.json`에서 프리셋을 불러오고, `tsconfig.test.json`이 이를 다시 확장해 테스트 전용 타입을 추가하는 식이다.
- `@tsconfig` 패키지들은 GitHub에서 공개적으로 유지 보수된다. “Node 20”, “Next.js” 등 목적에 맞는 프리셋이 있는지 확인하고, 없다면 기존 프리셋을 참고해 조직 내부 표준을 만드는 것도 좋다.

이렇게 하면 새로운 프로젝트를 시작할 때마다 수십 개의 컴파일러 옵션을 직접 구성하는 수고를 덜고, 팀 전체에 일관된 규칙을 빠르게 배포할 수 있다.
