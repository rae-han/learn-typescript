# **4. 제네릭**

- 타입 안정성과 유연성을 동시에 얻기 위한 핵심 도구가 제네릭.
- 제네릭, 매핑된 타입, 형식 맵, 형식 변경자, 헬퍼 타입 등으로 **메타 타입 세계**에서 형식 간 관계를 모델링할 수 있다.
- 복잡한 자료구조를 안전하게 다루면서도 아직 정의되지 않은 부분을 추상화할 수 있다.

---

# **4.1 함수 시그니처 일반화하기**

## **상황**
- `isLanguageAvailable`, `isElementAllowed`처럼 구조는 같지만 다른 객체/키를 다루는 타입가드 함수가 중복된다.
- 각각의 함수는 `in` 검사를 통해 키 유효성을 확인하지만, 타입 정의 때문에 함수가 분리되어 있다.

## **제네릭 적용**
```ts
function isAvailable<Obj>(
  obj: Obj,
  key: string | number | symbol,
): key is keyof Obj {
  return key in obj;
}
```
- `Obj` 제네릭 매개변수를 도입하여 어떤 객체든 처리 가능.
- 반환 타입을 `key is keyof Obj`로 선언하여 안전한 인덱스 접근을 보장.

## **효과**
- `Languages`, `AllowedElements` 등 서로 다른 사전 타입에서도 타입 가드를 재사용.
- 자바스크립트 스타일의 유연성은 유지하면서, TypeScript가 호출 지점마다 `Obj`를 추론해 좁혀 준다.

---

# **4.2 관련된 함수 인수 만들기**

## **문제**
- `fetchFile(languages, "it")` 같이 존재하지 않는 키도 허용되어 버그가 런타임까지 지연된다.
- `URLList`와 같은 인덱스 시그니처 타입은 너무 넓어서 특정 키를 제약하지 못한다.

## **제네릭 제약으로 풀기**
```ts
type URLList = { [x: string]: URL };

function fetchFile<List extends URLList>(
  urls: List,
  key: keyof List,
) {
  return fetch(urls[key]).then((res) => res.json());
}
```
- `List extends URLList`로 **실제 목록 타입**을 유지하면서 인덱스 키를 `keyof List`로 제한.
- 잘못된 키 사용 시 컴파일 단계에서 오류 감지.

## **여러 키 처리**
- 두 번째 제네릭 `Keys extends keyof List`를 도입하여 배열 키까지 좁힐 수 있다.
- 결과 튜플 타입에 `[Keys, any]`를 사용하고, 필요 시 반환 타입을 추가 제네릭으로 더욱 구체화.

```ts
function fetchFiles<List extends URLList, Keys extends keyof List>(
  urls: List,
  keys: Keys[],
) {
  return keys.map((key) =>
    fetch(urls[key])
      .then((res) => res.json())
      .then((data) => [key, data] as [Keys, unknown]),
  );
}
```
- 이렇게 제네릭 매개변수 간 관계를 설정하면, **요청하지 않은 언어 결과를 검사하는 코드**도 자동으로 오류 처리된다.

---

# **4.3 any와 unknown 제거하기**

## **핵심 비교**
- `any`, `unknown`은 넓은 집합을 표현하지만, **형식 정보를 보존하지 못한다**는 한계가 있다.
- 제네릭을 쓰면 호출 시점에 **실제 타입으로 치환**되므로, 동일한 유연성을 유지하면서도 결과 타입을 정확히 알 수 있다.

## **예시: identity**
```ts
function identity<T>(value: T): T {
  return value;
}

const str = identity('Hello');        // string
const num = identity(2000);          // number
const literal = identity<'Hi'>('Hi'); // 'Hi'
```
- `const` 바인딩과 결합하면 리터럴 타입도 유지된다.
- 제네릭은 `unknown`처럼 내부에서 좁혀야 하는 번거로움 없이 **입력과 출력 타입을 연결**한다.

## **튜플 생성**
```ts
function pairs<T, U>(a: T, b: U): [T, U] {
  return [a, b];
}
```
- 제네릭을 사용하면 `[number, string]`처럼 정확한 튜플 타입을 얻을 수 있으며, 필요하면 `T` 하나로 제한하여 두 요소 타입을 동일하게 강제할 수도 있다.

---

# **4.4 제네릭 인스턴스화 이해하기**

## **문제**
- `reset<F extends Filter>(filter: F): F`처럼 작성하면, `Filter`의 하위 타입을 전달했을 때 추가 프로퍼티까지 그대로 유지된다.
- 하지만 함수 내부에서 새로운 객체를 만들어 반환하면, **추가 필드를 잃어버릴 위험**이 있다.

## **대응 전략**
- 함수에서 입력 객체를 복제하고 필요한 속성만 덮어써서 **하위 타입을 존중**한다.
- 동일한 문제는 재귀 타입(`TreeItem`)에서도 발생. 제네릭 반환 타입을 실제 `TreeItem`으로 고정하거나, 제네릭 자체를 재귀적으로 설계해야 한다.

## **교훈**
- 제네릭 함수는 호출 시점마다 **다양한 하위 타입으로 인스턴스화**될 수 있다.
- 구현부는 가능한 한 “받은 타입 그대로”를 다루고, 반환 타입도 그 하위 타입을 유지하도록 주의한다.

---

# **4.5 새 객체 형식 생성하기**

## **동기**
- `Toy` 유니온에 새 변형을 추가할 때마다 `GroupedToys` 타입을 수동으로 업데이트하는 것은 번거롭다.
- 유니온 멤버와 그룹 구조 간의 **암묵적인 관계**를 타입 수준에서 유지하고 싶다.

## **매핑된 타입 활용**
```ts
type GroupedToys = {
  [K in Toy['kind']]?: Toy[];
};
```
- `Toy['kind']` 유니온을 키로 사용하여 자동으로 그룹 타입을 구성.
- 선택적 프로퍼티로 두어 초기화되지 않은 그룹도 허용하고, 런타임에는 `?? []`와 결합해 처리.

## **일반화**
- `Group<Collection, Selector>`처럼 제네릭 매핑 타입을 정의해 다양한 모델에 재사용.
- `Record<string, any>` 같은 제약 또는 조건부 타입을 활용해 **유효한 키만 허용**하도록 구성.
- 필요 시 `Partial<Group<...>>`로 선택형 프로퍼티를 손쉽게 도입.

---

# **4.6 어서션 시그니처로 객체 변경하기**

## **문제**
- 어떤 함수를 실행한 뒤 객체가 확장되거나 형식이 바뀌었음을 타입 시스템에 알리고 싶다.
- 단순 type guard는 `true`를 반환해야 해서 어색한 경우가 있다.

## **어설션 시그니처(asserts)**
```ts
function check<T>(obj: T): asserts obj is T & { checked: true } {
  (obj as T & { checked: boolean }).checked = true;
}

const person = { name: 'Stefan', age: 27 };
check(person);
// person.checked의 타입은 true로 좁혀짐
```
- `asserts condition` 또는 `asserts val is NarrowType` 형태로 선언.
- 함수가 반환되면 주어진 조건이 성립한다고 가정하므로, `if` 분기 없이도 형식이 갱신된다.
- Node.js `assert` 구현과 같은 패턴으로 널리 활용 가능하다.

---

# **4.7 형식 맵을 이용한 매핑 타입 사용하기**

## **목표**
- 태그명으로 올바른 DOM 요소를 생성하는 `createElement` 팩토리 함수를 타입 안전하게 작성.
- 태그마다 허용되는 프로퍼티(예: `<a>`의 `href`)를 자동으로 안내하고 잘못된 속성은 차단.

## **형식 맵 구축**
```ts
type AllElements = {
  a: HTMLAnchorElement;
  div: HTMLDivElement;
  video: HTMLVideoElement;
  // ... 실제로는 HTMLElementTagNameMap 활용
};

function createElement<T extends keyof AllElements>(
  tag: T,
  props?: Partial<AllElements[T]>,
): AllElements[T] {
  const elem = document.createElement(tag);
  return Object.assign(elem, props);
}
```
- `Partial`로 모든 프로퍼티를 선택형으로 바꿔 한 번에 설정할 수 있게 한다.
- 라이브러리 제공 `HTMLElementTagNameMap`을 확장하면 140개 HTML 태그를 모두 지원 가능하며, 추가적으로 `[x: string]: HTMLUnknownElement;`를 선언해 사용자 정의 요소도 처리.

## **고급 응용**
- 템플릿 리터럴 타입과 매핑된 타입을 결합해 `
  { [x in `${string}-${string}`]: HTMLElement }
`와 같이 커스텀 엘리먼트 네이밍 규칙을 모델링할 수 있다.
- 함수 오버로드를 사용해 내부 구현과 외부 API를 분리하면, 타입 어서션을 최소화하면서 깔끔한 시그니처 유지가 가능하다.

---

# **4.8 ThisType으로 객체의 this 정의하기**

## **동기**
- Vue.js 같은 프레임워크는 `data`, `computed`, `methods`가 서로 다른 `this` 컨텍스트를 사용한다.
- 일반 함수 타입만으로는 이런 컨텍스트 변화를 모델링하기 어렵다.

## **구성**
```ts
type FnObj = Record<string, () => any>;

type Options<Data, Computed extends FnObj, Methods> = {
  data?(this: {}): Data;
  computed?: Computed & ThisType<Data>;
  methods?: Methods & ThisType<
    Data & MapFnToProp<Computed> & Methods
  >;
};
```
- `ThisType<T>`는 객체 리터럴에서 `this`의 타입을 `T`로 간주하게 만드는 내장 제네릭.
- `MapFnToProp`은 `ReturnType`을 이용해 `computed` 함수들의 반환값을 프로퍼티 형태로 변환.
- `create(options)` 팩토리 함수에 위 타입을 적용하면, 각 섹션에서 접근 가능한 속성이 정확히 추론되며 잘못된 접근은 컴파일 에러로 잡힌다.

---

# **4.9 제네릭 형식 매개변수에 const 컨텍스트 추가하기**

## **문제**
- 객체/배열을 인수로 받으면, TypeScript는 기본적으로 내부 값을 넓은 타입으로 계산한다.
- 라우터 예시처럼 `path`들을 리터럴 그대로 유지해야 탐색 메서드에 자동완성을 제공할 수 있다.

## **해결: const 제네릭**
```ts
function router<const T extends Route>(routes: T[]) {
  return {
    navigate(path: T['path']) {
      history.pushState({}, '', path);
    },
  };
}
```
- 제네릭 매개변수 앞에 `const`를 붙이면 전달된 값이 **const 컨텍스트**에서 추론된다.
- 호출부에서 `as const`를 잊어도 `navigate`는 `"/" | "/about"`처럼 구체적인 경로만 허용한다.
- 잘못된 경로 문자열을 전달하면 컴파일 오류로 즉시 감지된다.

---

> 제네릭과 매핑된 타입은 타입스크립트의 표현력을 크게 확장시켜 준다. 처음엔 복잡해 보이지만, 한 번 구조를 잡아 놓으면 모델 변경에도 자동으로 대응하며 코드 품질을 높일 수 있다.
