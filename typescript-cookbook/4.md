# 4장 제네릭

## 4.1 함수 시그니처 일반화하기
**문제** 구조만 다른 여러 함수를 유지하다 보니 중복이 늘어난다.

**해결** 제네릭 타입 매개변수와 타입 가드를 결합해 하나의 범용 함수로 추상화한다.

```ts
function isAvailable<Collection>(
  collection: Collection,
  key: string | number | symbol
): key is keyof Collection {
  return key in collection;
}

const languages = {
  de: new URL("/de.json", import.meta.url),
  en: new URL("/en.json", import.meta.url)
};

if (isAvailable(languages, "de")) {
  const url = languages["de"]; // keyof Collection 덕분에 안전하게 접근
}
```

**논의**
이 패턴을 적용하려면 세 가지 요소를 기억하면 좋다.

1. **제네릭 타입 매개변수 도입**: `Collection`은 호출 시점에 실제 객체 타입으로 치환된다. 덕분에 `languages`든 `allowedElements`든 동일한 로직으로 검사할 수 있다.
2. **타입 가드 반환**: `key is keyof Collection` 서명 덕분에 `if` 문 안에서는 `key`가 실제 키로 좁혀진다. 이것이 없으면 `collection[key]` 접근이 안전한지 컴파일러가 알 수 없다.
3. **키의 가능한 타입**: 객체 키는 문자열뿐 아니라 숫자, 심볼일 수도 있다. 따라서 `key` 매개변수는 `string | number | symbol`로 선언해 모든 경우를 포괄한다.

> **팁**: 이렇게 추상화하면 "객체에 키가 존재하는지 검사"라는 패턴을 코드 전반에서 재사용할 수 있다. 필요하면 제약 조건을 추가해 `Collection extends Record<PropertyKey, unknown>`처럼 더 구체적으로 제한할 수도 있다.

## 4.2 관련된 함수 인수 만들기
**문제** 두 번째 매개변수가 첫 번째 매개변수에 의존하지만, 단순한 타입 선언으로는 연결이 되지 않는다.

**해결** 여러 제네릭 매개변수와 제약(`extends`)을 이용해 인수 간 관계를 명시하고, 올바른 키만 선택할 수 있게 한다.

```ts
function fetchFiles<Collection extends Record<string, URL>, K extends keyof Collection>(
  collection: Collection,
  keys: readonly K[]
): Promise<Collection[K][]> {
  return Promise.all(keys.map(key => fetch(collection[key]).then(res => res.json())));
}

const locales = {
  de: new URL("/de.json", import.meta.url),
  ja: new URL("/ja.json", import.meta.url)
};

fetchFiles(locales, ["de", "ja"]);
// fetchFiles(locales, ["fr"]); // 오류: 존재하지 않는 키
```

**논의**
제네릭 매개변수 사이의 관계를 표현할 때는 다음 순서를 따른다.

- `Collection extends Record<string, URL>`로 첫 번째 인수가 "문자열 키를 가진 URL 컬렉션"임을 제한한다. 이렇게 하면 함수 본문에서 `collection[key]`가 URL이라는 사실을 활용할 수 있다.
- 두 번째 제네릭 `K extends keyof Collection`은 `keys` 배열에 들어올 수 있는 값의 범위를 "컬렉션 키"로 제한한다. 호출부에서 존재하지 않는 키를 전달하면 즉시 타입 오류가 발생한다.
- 반환 타입 `Promise<Collection[K][]>`는 "각 키에 해당하는 URL이 fetch되어 JSON으로 파싱된 결과"라는 의미를 그대로 유지한다. 호출자는 `const [deData, jaData] = await fetchFiles(...);`처럼 타입 안전하게 구조 분해할 수 있다.

> **팁**: 입력값 사이의 제약을 명시적으로 모델링하면 런타임 검사 없이도 잘못된 호출을 미리 차단할 수 있다.

> **2025 업데이트**: TypeScript 5.4에서 추가된 `NoInfer<T>` 유틸리티 타입을 사용하면 특정 위치에서 타입 추론을 방지할 수 있다. 예를 들어 기본값 매개변수가 제네릭 추론에 영향을 주지 않도록 할 때 유용하다:
> ```ts
> function fetchWithDefault<K extends string>(
>   keys: K[],
>   defaultKey: NoInfer<K>  // 이 위치에서는 K 추론에 영향 안 줌
> ): K[] { ... }
> ```

## 4.3 any와 unknown 제거하기
**문제** 제네릭 함수 내부에서 `any`나 `unknown`을 남겨두면 반환 타입이 무의미해진다.

**해결** 제네릭 타이핑으로 실제 값을 그대로 되돌리고, 필요하면 타입 가드로 좁힌 뒤 반환한다.

```ts
function identity<T>(value: T): T {
  return value; // 전달된 타입이 그대로 돌아온다.
}

const a = identity("hello"); // string
const b = identity({ x: 1 }); // { x: number }
```

**논의**
제네릭을 사용하면 함수 외부로 전달되는 값에 대한 타입 정보를 그대로 유지할 수 있다.

이 단순한 예제는 몇 가지 중요한 사실을 보여 준다.

- `identity`는 호출 시점에 `T`가 어떤 타입이든 그대로 반환하므로, 함수 내부에서 `any`를 사용할 이유가 없다. 제네릭을 쓰면 타입 정보가 사라지지 않는다.
- 화살표 함수나 메서드에서도 동일한 패턴을 사용할 수 있다. `const toArray = <T>(value: T): T[] => [value];`처럼 작성하면 입력 타입과 출력 타입이 연동된다.
- 타입 추론이 원하는 만큼 좁혀지지 않을 때는 `identity<string>("hello")`처럼 제네릭 인수를 명시적으로 제공할 수도 있다. 하지만 일반적으로는 추론에 맡기는 것이 더 간결하다.

> **팁**: 제네릭 함수가 `any`를 도입하게 되는 지점이 있다면 "타입 매개변수를 더 도입할 수는 없는지" 먼저 고민해 보자.

> **2025 업데이트**: TypeScript 5.0에서 도입된 `const` 타입 매개변수를 사용하면 리터럴 타입을 더 정확하게 추론할 수 있다:
> ```ts
> // 기존 방식 - 타입이 넓어짐
> function getValues<T>(arr: T[]): T[] { return arr; }
> const vals = getValues(["a", "b"]); // string[]
>
> // const 타입 매개변수 - 리터럴 유지
> function getValuesConst<const T>(arr: T[]): T { return arr[0]; }
> const valsConst = getValuesConst(["a", "b"]); // "a" | "b"
> ```
> 이는 `as const` 없이도 리터럴 타입을 보존하고 싶을 때 특히 유용하다.


## 4.4 제네릭 인스턴스화 이해하기
**문제** "제약 조건을 만족하지만 다른 하위 타입으로는 인스턴스화할 수 없다"는 오류가 이해되지 않는다.

**해결** 제네릭은 호출 지점마다 구체 타입으로 대체되므로, 제약은 상위 타입을 강제할 뿐 실제 전달되는 타입은 더 좁을 수 있음을 기억한다. 하위 타입을 처리하려면 제약을 넓히거나 공변성을 보장해야 한다.

```ts
interface FilterRule {
  field: string;
  operator: "eq" | "gt" | "lt";
  value: unknown;
}

interface Combinator {
  combinator: "and" | "or";
  rules: FilterRule[];
}

type FilterNode = FilterRule | Combinator;

function visit<T extends FilterNode>(node: T, visitRule: (rule: FilterRule) => void) {
  if ("rules" in node) {
    node.rules.forEach(rule => visitRule(rule));
  } else {
    visitRule(node);
  }
}
```

**논의**
"제네릭 인스턴스화(instantiation)" 오류를 해결하려면 다음 개념을 이해해야 한다.

- `T extends FilterNode`는 `T`가 최소한 `FilterRule | Combinator` 중 하나와 호환되어야 한다는 뜻이다. 하지만 실제 호출 시점에는 `visit<Combinator>(...)`처럼 더 좁은 타입으로 인스턴스화된다.
- 따라서 함수 본문에서 `node.rules`를 사용할 때는 `Combinator`일 때만 존재한다는 사실을 확실히 해야 한다. 그렇지 않으면 `FilterRule`로 호출한 경우 컴파일러가 안전성을 보장하지 못한다.
- 제네릭 매개변수는 공변성/반공변성 규칙도 영향을 준다. 예를 들어 콜백 `visitRule`이 `FilterRule`보다 좁은 타입을 기대한다면 `visitRule: (rule: T extends FilterRule ? T : FilterRule)`처럼 추가 제약을 넣어야 할 수도 있다.

> **팁**: "제약 조건을 만족하지만 다른 하위 타입으로는 인스턴스화할 수 없다"는 오류는 보통 함수 시그니처가 너무 일반적인데 구현이 구체적일 때 발생한다. 구현 로직을 제약 조건에 맞춰 일반화하거나, 제약을 더 정확히 좁혀서 구현과 일치시켜야 한다.

| 오류 유형 | 원인 | 해결 방법 |
|----------|------|----------|
| 제약 조건 불일치 | 시그니처가 너무 일반적 | 제약을 더 구체적으로 좁히기 |
| 하위 타입 인스턴스화 불가 | 구현이 특정 타입 가정 | 타입 가드로 분기 처리 |
| 공변성/반공변성 문제 | 콜백 타입 불일치 | 조건부 타입으로 정확한 타입 명시 |


## 4.5 새 객체 형식 생성하기
**문제** 기존 타입을 기반으로 파생된 객체 모델을 반복해 선언하기 번거롭다.

**해결** 매핑 타입과 제네릭을 이용해 키를 변환하거나 속성을 선택해 새로운 객체 타입을 만들어낸다.

```ts
type ApiResponse<T> = {
  [K in keyof T as `${K & string}Response`]: {
    data: T[K];
    lastUpdated: Date;
  }
};

type Endpoints = {
  user: { id: string; name: string };
  order: { id: string; total: number };
};

type Responses = ApiResponse<Endpoints>;
/*
Responses는 다음과 같다.
{
  userResponse: { data: { id: string; name: string }; lastUpdated: Date };
  orderResponse: { data: { id: string; total: number }; lastUpdated: Date };
}
*/
```

**논의**
매핑 타입을 설계할 때 알아두면 좋은 패턴:

- `keyof T`로 원본 타입의 키를 순회하고, `as` 키 재매핑을 통해 새 키 이름을 만들 수 있다. 템플릿 리터럴을 활용하면 접두사/접미사를 자유롭게 붙일 수 있다.
- 값 부분에는 원본 속성 타입(`T[K]`)을 그대로 사용하거나, 제네릭을 통해 변환할 수 있다. 위 예제에서는 `data: T[K]`로 원본 엔드포인트 응답을 보존했다.
- 추가 프로퍼티(`lastUpdated`)처럼 모든 엔드포인트에 공통으로 붙이고 싶은 필드는 매핑 타입 내부에서 선언하면 된다.

> **팁**: `ApiResponse`는 다른 도메인에도 재사용할 수 있다. 예를 들어 `ApiResponse<Pick<Endpoints, "user">>`처럼 부분 집합을 넘기면 필요한 엔드포인트만의 응답 타입을 자동으로 생성한다.

> **2025 업데이트**: TypeScript 5.0+에서 매핑 타입과 `const` 타입 매개변수를 결합하면 더 정밀한 타입 생성이 가능하다:
> ```ts
> // 키를 리터럴로 유지하면서 매핑
> function createEndpoints<const T extends Record<string, string>>(
>   endpoints: T
> ): { [K in keyof T as `${K & string}Url`]: URL } {
>   return Object.fromEntries(
>     Object.entries(endpoints).map(([k, v]) => [`${k}Url`, new URL(v)])
>   ) as any;
> }
>
> const urls = createEndpoints({ api: "https://api.example.com" });
> // { apiUrl: URL } - 키가 정확하게 추론됨
> ```

---

## 제네릭 타입 매개변수 비교

| 기능 | 일반 제네릭 `<T>` | const 제네릭 `<const T>` | 제약 제네릭 `<T extends X>` |
|-----|------------------|------------------------|---------------------------|
| 리터럴 추론 | 넓은 타입으로 추론 | 리터럴 유지 | 제약 범위 내에서 추론 |
| 사용 시점 | 일반적인 타입 추상화 | 정확한 리터럴 필요 시 | 특정 구조 강제 시 |
| TypeScript 버전 | 모든 버전 | 5.0+ | 모든 버전 |
| 예시 | `identity<T>` | `getValues<const T>` | `fetch<T extends object>` |
