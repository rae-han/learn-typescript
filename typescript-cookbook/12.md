# 12장 형식 개발 전략

지금까지 타입스크립트 프로그래밍 언어와 형식 시스템의 다양한 특징을 살펴봤다. 2장과 3장에서는 기본 형식을 효과적으로 사용하는 방법, 4장에서는 제네릭으로 코드 재사용성을 높이는 방법을 살펴봤다. 5장에서는 조건부 형식, 6장에서는 문자열 템플릿 리터럴 형식, 7장에서는 가변 튜플 형식을 사용하여 특정 상황에 맞는 고급 형식을 만드는 방법을 배웠다.

8장에서는 헬퍼 형식 컬렉션을 만들었고, 9장에서는 표준 라이브러리라는 제한을 안고 작업했다. 10장에서는 JSX를 언어 확장으로 사용하는 방법을 배웠고, 11장에서는 언제, 어떻게 클래스를 사용하는지 배웠다.

이 장에서는 **유지보수가 쉬운 형식**(low-maintenance type)이라는 개념을 배운다. 우선 간단한 형식부터 시작해 점차 더 정교하고 탄탄한 형식을 만드는 과정을 탐구한다. 타입스크립트 플레이그라운드의 숨겨진 기능과 검증을 도와주는 라이브러리 사용 방법을 배운다. 어려운 결정을 내리는 데 도움이 되는 가이드를 찾아보고, 타입스크립트를 사용하면서 반드시 부딪히게 되는 일반적이지만 까다로운 형식 오류를 해결하는 방법을 살펴본다.

---

## 12.1 유지보수가 쉬운 형식 구현하기

**문제**: 모델이 바뀔 때마다 코드베이스 전체에서 수십 개의 형식을 바꿔야 한다. 이 작업은 지루할 뿐 아니라 뭔가 빼먹는 실수가 쉽게 발생할 수 있다.

**해결**: 다른 형식으로부터 새 형식을 파생하고, 사용 방법으로 형식을 추론하며, 유지보수가 쉬운 형식을 만든다.

**논의**:

지금까지 다른 형식으로부터 새 형식을 만드는 데 많은 시간을 소비했다. 기존 형식으로부터 새 형식을 파생할 수 있다면 형식 정보를 구현하고 적용하는 데 걸리는 시간을 아껴서 버그를 수정하고 자바스크립트 오류를 고치는 데 더 많은 시간을 투자할 수 있다.

타입스크립트는 자바스크립트 위에 추가된 메타정보 계층이다. 튼튼하고 이해하기 쉬운 자바스크립트 코드를 구현하는 것이 우리의 목표다.

### 유지보수가 쉬운 형식을 만드는 세 단계

1. **데이터를 직접 모델링하거나 기존 모델에서 추론한다**
2. **파생형(매핑된 형식, Partial 등)을 정의한다**
3. **조건부 형식으로 동작을 정의한다**

### 예제: copy 함수

```typescript
// 명시적으로 형식을 만드는 방법 (유지보수 어려움)
type Options = {
  from: string;
  to: string;
};

const defaultOptions: Options = {
  from: "./src",
  to: "./dest",
};

type PartialOptions = {
  from?: string;
  to?: string;
};

function copy(options: PartialOptions) {
  const allOptions = { ...defaultOptions, ...options };
  // 나머지 구현
}
```

위 방법은 합리적이지만, 새 필드를 추가할 때 코드를 세 번 바꿔야 한다!

### 개선된 방법: typeof와 Partial 활용

```typescript
const defaultOptions = {
  from: "./src",
  to: "./dest",
  overwrite: true,
};

function copy(options: Partial<typeof defaultOptions>) {
  const allOptions = { ...defaultOptions, ...options };
  // 나머지 구현
}
```

이 방법의 장점:
- **새 필드를 추가할 때 유지 관리가 전혀 필요 없다**
- **필드 이름을 바꾸면** `copy`의 모든 사용처에서 원하는 정보만 얻을 수 있다
- **신뢰할 수 있는 한 가지 소스**, 즉 실제 `defaultOptions` 객체가 있다 (런타임에 우리에게 있는 유일한 정보)

> **팁**: 자바스크립트를 구현하듯이 자연스럽게 타입스크립트를 사용하자. 형식을 먼저 정의하고 값을 만드는 것보다, 값에서 형식을 추론하는 방식이 더 유지보수하기 쉽다.

---

## 12.2 단계별로 형식 다듬기

**문제**: API에는 제네릭, 조건부 형식, 문자열 템플릿 리터럴 형식 같은 고급 기능을 활용한 정교한 형식이 필요하다. 하지만 어디서부터 시작해야 할지 모른다.

**해결**: 형식을 단계적으로 다듬는다. 기본 형식과 객체 형식부터 시작해 부분집합, 제네릭 형식 추가를 살펴본 후 고급 기법을 사용한다.

**논의**:

익스프레스(Express) 스타일의 서버를 예로 들어보자:

```typescript
app.get("/api/users/:userID", function (req, res) {
  if (req.method === "POST") {
    res.status(20).send({
      message: "Got you, user " + req.params.userId,
    });
  }
});
```

이 코드에는 **세 가지 오류**가 있다:

1. `app.get`을 호출하는데 `req.method === "POST"`를 검사함 (항상 false)
2. `20`은 올바른 HTTP 상태 코드가 아님 (200이어야 함)
3. `userId`는 오타 (`userID`가 맞음)

### 1단계: 기본 타이핑

```typescript
type ServerRequest = {
  method: string;
  params: Record<string, string>;
};

type ServerReply = {
  send: (obj?: any) => void;
  status: (statusCode: number) => ServerReply;
};

type CallbackFn = (req: ServerRequest, reply: ServerReply) => void;

function get(path: string, callback: CallbackFn) {
  // 구현 예정
}
```

기본 형식만으로도 일부 오류를 잡을 수 있다:
- 숫자와 문자열 비교 오류 감지
- 상태 코드에 문자열 전달 시 오류 감지

### 2단계: 기본 형식의 부분집합

```typescript
type Methods = "GET" | "POST" | "PUT" | "DELETE";

type StatusCode =
  | 100 | 101 | 102 | 200 | 201 | 202 | 203 | 204 | 205
  | 206 | 207 | 208 | 226 | 300 | 301 | 302 | 303 | 304
  | 305 | 306 | 307 | 308 | 400 | 401 | 402 | 403 | 404
  | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413
  | 414 | 415 | 416 | 417 | 418 | 420 | 422 | 423 | 424
  | 425 | 426 | 428 | 429 | 431 | 444 | 449 | 450 | 451
  | 499 | 500 | 501 | 502 | 503 | 504 | 505 | 506 | 507
  | 508 | 509 | 510 | 511 | 598 | 599;

type ServerRequest = {
  method: Methods;
  params: Record<string, string>;
};

type ServerReply = {
  send: (obj?: any) => void;
  status: (statusCode: StatusCode) => ServerReply;
};
```

리터럴 유니온 형식으로 유효한 값만 허용한다.

### 3단계: 제네릭 추가

```typescript
type ServerRequest<Met extends Methods> = {
  method: Met;
  params: Record<string, string>;
};

type CallbackFn<Met extends Methods> = (
  req: ServerRequest<Met>,
  reply: ServerReply
) => void;

function get(path: string, callback: CallbackFn<"GET">) {
  // 구현 예정
}
```

이제 `app.get` 콜백에서 `req.method`는 오직 `"GET"`만 가능하다.

### 4단계: 고급 형식으로 형식 검사

```typescript
type ServerRequest<Met extends Methods, Par extends string = string> = {
  method: Met;
  params: Record<Par, string>;
};

function get<Par extends string = string>(
  path: string,
  callback: CallbackFn<"GET", Par>
) {
  // 구현 예정
}

// 사용
app.get<"userID">("/api/users/:userID", function (req, res) {
  req.params.userID;       // 동작!
  req.params.anythingElse; // 오류!
});
```

### 5단계: 문자열 템플릿 리터럴 형식으로 경로 검증

```typescript
type IncludesRouteParams<Par extends string> =
  | `${string}/:${Par}`
  | `${string}/:${Par}/${string}`;

function get<Par extends string = string>(
  path: IncludesRouteParams<Par>,
  callback: CallbackFn<"GET", Par>
) {
  // 구현 예정
}
```

### 6단계: 조건부 형식으로 매개변수 자동 추출

```typescript
type ParseRouteParams<Route> =
  Route extends `${string}/:${infer P}/${infer R}`
    ? P | ParseRouteParams<`/${R}`>
    : Route extends `${string}/:${infer P}`
      ? P
      : never;

function get<Path extends string = string>(
  path: Path,
  callback: CallbackFn<"GET", ParseRouteParams<Path>>
) {
  // 구현 예정
}

// 사용 - 제네릭 매개변수 명시 필요 없음!
app.get("/api/users/:userID/orders/:orderID", function (req, res) {
  req.params.userID;  // 동작!
  req.params.orderID; // 동작!
});
```

### 단계별 접근의 장점

| 단계 | 형식 안전성 | 복잡도 |
|------|------------|--------|
| 1단계 | 기본 형식 검사 | 낮음 |
| 2단계 | 유효값 제한 | 낮음 |
| 3단계 | 사용사례별 동작 조정 | 중간 |
| 4단계 | 문자열 형식 의미 부여 | 높음 |
| 5단계 | 리터럴 활용 | 높음 |
| 6단계 | 자바스크립트만큼 유연한 형식 | 매우 높음 |

> **팁**: 각 단계마다 형식 안전성을 추가할 수 있다. 필요에 따라 중간에 멈춰도 된다!

---

## 12.3 satisfies로 계약 검사하기

**문제**: 리터럴 형식으로 작업하고 싶지만, 계약을 이행하려면 애너테이션 형식 검사를 해야 한다.

**해결**: `satisfies` 연산자로 리터럴 형식을 유지하면서 애너테이션과 비슷한 형식 검사를 수행한다.

**논의**:

채널 정의 객체를 사용하는 메시징 라이브러리를 예로 살펴보자:

```typescript
type Messages =
  | "CHANNEL_OPEN"
  | "CHANNEL_CLOSE"
  | "CHANNEL_FAIL"
  | "MESSAGE_CHANNEL_OPEN"
  | "MESSAGE_CHANNEL_CLOSE"
  | "MESSAGE_CHANNEL_FAIL";

type ChannelDefinition = {
  [key: string]: {
    open: Messages;
    close: Messages;
    fail: Messages;
  };
};
```

### 문제: 명시적 형식 지정 시 구체적인 키 정보 손실

```typescript
const impl: ChannelDefinition = {
  test: {
    open: "CHANNEL_OPEN",
    close: "CHANNEL_CLOSE",
    fail: "CHANNEL_FAIL",
  },
  message: {
    open: "MESSAGE_CHANNEL_OPEN",
    close: "MESSAGE_CHANNEL_CLOSE",
    fail: "MESSAGE_CHANNEL_FAIL",
  },
};

function openChannel(
  def: ChannelDefinition,
  channel: keyof ChannelDefinition  // string - 모든 문자열 허용!
) {
  // 구현 예정
}

// 문제: "massage" 오타를 잡지 못함!
openChannel(impl, "massage");
```

### 해결 1: 제네릭 함수 사용

```typescript
function openChannel<T extends ChannelDefinition>(
  def: T,
  channel: keyof T  // 실제 키만 허용!
) {
  // 구현 예정
}

const impl = {
  test: {
    open: "CHANNEL_OPEN",
    close: "CHANNEL_CLOSE",
    fail: "CHANNEL_FAIL",
  },
  message: {
    open: "MESSAGE_CHANNEL_OPEN",
    close: "MESSAGE_CHANNEL_CLOSE",
    fail: "MESSAGE_CHANNEL_FAIL",
  },
} as const;

openChannel(impl, "message");  // 동작!
openChannel(impl, "massage");  // 오류! "test" | "message"만 허용
```

하지만 `impl`이 `ChannelDefinition`을 준수하는지 사용 시점에만 확인할 수 있다.

### 해결 2: satisfies 연산자 사용

```typescript
const impl = {
  test: {
    open: "CHANNEL_OPEN",
    close: "CHANNEL_CLOSE",
    fail: "CHANNEL_FAIL",
  },
  message: {
    open: "MESSAGE_CHANNEL_OPEN",
    close: "MESSAGE_CHANNEL_CLOSE",
    fail: "MESSAGE_CHANNEL_FAIL",
  },
} satisfies ChannelDefinition;
```

`satisfies`의 장점:
- **계약 검사**: 정의 시점에 `ChannelDefinition` 준수 여부 확인
- **리터럴 형식 유지**: `keyof typeof impl`은 `"test" | "message"`
- **형식 좁히기**: 각 필드의 구체적인 리터럴 형식 유지

```typescript
// satisfies 덕분에 구체적인 리터럴 형식으로 인식
impl.test.close = "CHANNEL_CLOSE_MESSAGE";
// 오류! "CHANNEL_CLOSE_MESSAGE"는 "CHANNEL_CLOSE"에 할당 불가
```

> **2025 업데이트**: `satisfies`는 TypeScript 4.9에서 도입되었으며, 현재 널리 사용되는 패턴입니다.

### as const와 satisfies 조합

```typescript
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3,
} as const satisfies {
  apiUrl: string;
  timeout: number;
  retries: number;
};

// config.apiUrl의 형식: "https://api.example.com" (리터럴)
// config.timeout의 형식: 5000 (리터럴)
```

### 언제 satisfies를 사용해야 할까?

| 상황 | 권장 방법 |
|------|----------|
| 계약 검사 + 리터럴 형식 유지 | `satisfies` |
| 단순 형식 지정 | `: Type` 애너테이션 |
| 형식 좁히기 필요 없음 | `: Type` 애너테이션 |
| 객체 리터럴의 구체적 형식 필요 | `as const satisfies Type` |

> **팁**: `satisfies`는 "이 값이 이 형식을 만족하는지 확인하되, 더 구체적인 형식을 유지해라"라는 의미입니다.

---

## 12.4 복합 형식 테스트하기

**문제**: 매우 정교하고 복잡한 형식을 구현했는데, 이들이 제대로 동작하는지 확인하려 한다.

**해결**: 일부 유명한 헬퍼 형식은 테스트 프레임워크처럼 동작한다. 형식을 테스트해보자!

**논의**:

타입챌린지 저장소(https://tsch.js.org)에서 제공하는 형식 테스트 유틸리티를 살펴보자:

### 기본 테스트 형식

```typescript
export type Expect<T extends true> = T;
export type ExpectTrue<T extends true> = T;
export type ExpectFalse<T extends false> = T;
export type IsTrue<T extends true> = T;
export type IsFalse<T extends false> = T;
```

### Equal과 NotEqual

```typescript
export type Equal<X, Y> =
  (<T>() => T extends X ? 1 : 2) extends
  (<T>() => T extends Y ? 1 : 2) ? true : false;

export type NotEqual<X, Y> = true extends Equal<X, Y> ? false : true;
```

`Equal<X, Y>`는 제네릭 함수를 생성하고 서로 비교해야 할 두 가지 형식을 대조 검사한다.

### IsAny와 NotAny

```typescript
export type IsAny<T> = 0 extends 1 & T ? true : false;
export type NotAny<T> = true extends IsAny<T> ? false : true;
```

`0 extends 1 & T`는 `T`가 `any`인 경우에만 `true`가 된다. `any`와 인터섹션을 수행하면 `any`가 되며, `0`은 `any`의 하위집합이기 때문이다.

### Alike - 구조적 동등성 검사

```typescript
export type Debug<T> = { [K in keyof T]: T[K] };

export type MergeInsertions<T> = T extends object
  ? { [K in keyof T]: MergeInsertions<T[K]> }
  : T;

export type Alike<X, Y> = Equal<MergeInsertions<X>, MergeInsertions<Y>>;
```

`Alike`는 `{ x: number, y: string }`이 `{ x: number } & { y: string }`와 같은지 확인할 때 유용하다.

### 부분집합과 함수 인수 검사

```typescript
export type ExpectExtends<VALUE, EXPECTED> = EXPECTED extends VALUE
  ? true
  : false;

export type ExpectValidArgs<
  FUNC extends (...args: any[]) => any,
  ARGS extends any[]
> = ARGS extends Parameters<FUNC> ? true : false;
```

### 사용 예시

```typescript
type TestParseRouteParams = [
  Expect<Equal<ParseRouteParams<"/api/user/:userID">, "userID">>,
  Expect<Equal<
    ParseRouteParams<"/api/user/:userID/orders/:orderID">,
    "userID" | "orderID"
  >>,
  Expect<Equal<ParseRouteParams<"/api/user">, never>>,
];
```

> **2025 업데이트**: Vitest에서는 `expectTypeOf`를 내장 지원합니다:

```typescript
import { expectTypeOf, test } from 'vitest';

test('ParseRouteParams works correctly', () => {
  expectTypeOf<ParseRouteParams<"/api/user/:userID">>()
    .toEqualTypeOf<"userID">();

  expectTypeOf<ParseRouteParams<"/api/user">>()
    .toEqualTypeOf<never>();
});
```

### expect-type 패키지

```typescript
import { expectTypeOf } from 'expect-type';

// 형식이 일치하는지 검사
expectTypeOf<string>().toMatchTypeOf<string | number>();

// 정확히 같은지 검사
expectTypeOf<{ a: 1 }>().toEqualTypeOf<{ a: 1 }>();

// any가 아닌지 검사
expectTypeOf<string>().not.toBeAny();
```

> **팁**: 형식 테스트 파일은 `*.test-d.ts` 또는 `*.spec-d.ts` 패턴을 사용하는 것이 관례입니다.

---

## 12.5 런타임에서 조드로 데이터 형식 확인하기

**문제**: 외부 소스에서 전달한 데이터에 의존하고 있는데, 데이터의 정확성을 신뢰할 수 없다.

**해결**: 조드(Zod)라는 라이브러리를 사용해 스키마를 정의하고 이를 사용하여 외부 소스의 데이터를 검증한다.

**논의**:

타입스크립트의 형식 시스템은 컴파일 타임에만 적용되므로 런타임 환경에서 자바스크립트를 실행할 때는 모든 안전장치가 사라진다. 외부 API, 사용자 입력 등 통제할 수 없는 데이터를 처리할 때는 런타임 검증이 필요하다.

### 조드(Zod) 소개

조드(https://zod.dev)는 타입스크립트를 우선시하는 스키마 검증 라이브러리다:

```typescript
import { z } from "zod";

// 스키마 정의
const Person = z.object({
  name: z.string(),
  age: z.number().min(0).max(150),
  profession: z.string().optional(),
  status: z.union([
    z.literal("active"),
    z.literal("inactive"),
    z.literal("registered"),
  ]),
});

const Results = z.object({
  entries: z.array(Person),
});

// 타입스크립트 형식 추출
type PersonType = z.infer<typeof Person>;
type ResultType = z.infer<typeof Results>;
```

### 데이터 검증 및 파싱

```typescript
async function fetchData(): Promise<ResultType> {
  const data = await fetch("/api/persons").then((res) => res.json());
  return Results.parse(data);  // 검증 실패 시 오류 throw
}

// 사용
try {
  const res = await fetchData();
  // 결과 활용
} catch (e) {
  // 조드 오류 처리
}
```

### safeParse로 안전한 검증

```typescript
async function fetchData(): Promise<ResultType> {
  const data = await fetch("/api/persons").then((res) => res.json());
  const results = Results.safeParse(data);

  if (results.success) {
    return results.data;
  } else {
    // 오류 처리
    return { entries: [] };
  }
}
```

### 데이터 변환

```typescript
const Person = z.object({
  name: z.string(),
  age: z.number().min(0).max(150),
  profession: z.string().optional(),
  status: z
    .union([
      z.literal("active"),
      z.literal("inactive"),
      z.literal("registered"),
    ])
    .transform((val) => {
      if (val === "registered") {
        return "active";
      }
      return val;
    }),
});

// 입력과 출력 형식
type PersonTypeIn = z.input<typeof Person>;
// status: "active" | "inactive" | "registered"

type PersonTypeOut = z.output<typeof Person>;
// status: "active" | "inactive"
```

> **2025 업데이트**: Zod v4의 새 기능들:

```typescript
import { z } from "zod";

// z.pipe() - 변환 파이프라인
const DateString = z.string()
  .pipe(z.coerce.date());

// z.coerce - 자동 형변환
const numericString = z.coerce.number();  // "42" → 42

// superRefine - 정교한 검증
const passwordSchema = z.string().superRefine((val, ctx) => {
  if (val.length < 8) {
    ctx.addIssue({
      code: z.ZodIssueCode.too_small,
      minimum: 8,
      type: "string",
      inclusive: true,
      message: "비밀번호는 8자 이상이어야 합니다",
    });
  }
});

// z.discriminatedUnion - 최적화된 유니온
const Event = z.discriminatedUnion("type", [
  z.object({ type: z.literal("click"), x: z.number(), y: z.number() }),
  z.object({ type: z.literal("keypress"), key: z.string() }),
]);
```

### Zod 대안 라이브러리

| 라이브러리 | 특징 | 번들 크기 |
|-----------|------|----------|
| **Zod** | 가장 인기, 풍부한 생태계 | ~12KB |
| **Valibot** | Zod보다 ~94% 작은 번들 | ~700B |
| **ArkType** | 가장 빠른 성능, TS와 유사한 문법 | ~8KB |
| **TypeBox** | JSON Schema 호환 | ~5KB |
| **Effect Schema** | Effect 생태계 통합 | ~15KB |

```typescript
// Valibot 예시
import * as v from 'valibot';

const PersonSchema = v.object({
  name: v.string(),
  age: v.number([v.minValue(0), v.maxValue(150)]),
  status: v.union([
    v.literal('active'),
    v.literal('inactive'),
  ]),
});

type Person = v.Output<typeof PersonSchema>;
```

> **팁**: 조드의 런타임 유효성 검사에는 시간이 걸립니다. 데이터 집합이 클수록 시간이 오래 걸리므로, 경계에 위치한 데이터만 검증하세요.

---

## 12.6 인덱스 접근 제한 작업하기

**문제**: 인덱스로 객체의 속성에 접근할 때, 타입스크립트가 할당하려는 형식을 `never`에 할당할 수 없다고 불평한다.

**해결**: 타입스크립트는 가능한 값 중 가장 최소 공통 분모를 찾는다. 타입스크립트가 모든 키에 규칙이 적용되어야 한다고 가정하지 않도록 제네릭 형식으로 특정 키를 고정한다.

**논의**:

```typescript
let person = {
  name: "Stefan",
  age: 39,
};

type Person = typeof person;

let anotherPerson: Person = {
  name: "Not Stefan",
  age: 20,
};

function update(key: keyof Person) {
  person[key] = anotherPerson[key];
  // 오류! 'string | number' 형식은 'never'에 할당할 수 없습니다.
}
```

### 왜 never가 되는가?

타입스크립트는 **인터섹션**을 통해 할당 가능한 값을 계산한다:

```typescript
type Switch = {
  address: number;
  on: 0 | 1;
};

declare const switcher: Switch;
declare const key: keyof Switch;

// 모든 프로퍼티 형식의 인터섹션: number & (0 | 1) = 0 | 1
switcher[key] = 1;  // 동작!
switcher[key] = 2;  // 오류! '2'는 '0 | 1'에 할당 불가
```

`Person`의 경우:
- `name`은 `string`
- `age`는 `number`
- 인터섹션: `string & number = never`

### 해결: 제네릭으로 특정 키 고정

```typescript
function update<K extends keyof Person>(key: K) {
  person[key] = anotherPerson[key];  // 동작!
}

update("age");  // K는 "age"로 고정
```

`update("age")`를 호출하면 `K`는 문자 그대로 `"age"` 형식으로 연결된다. 모호함이 없어진다!

> **노트**: 이론적인 허점이 있다:
> ```typescript
> update<"age" | "name">("age");  // 허용됨
> ```
> 타입스크립트 팀은 현재 이를 허용한다. 기존 동작을 방해하지 않으면서 전체 클래스의 오류를 해결할 수 있기 때문이다.

---

## 12.7 함수 오버로드 또는 조건부 형식 사용 여부 결정하기

**문제**: 조건부 형식을 사용하면 이전보다 더 많은 함수 시그니처를 정의할 수 있다. 그렇다면 함수 오버로드가 여전히 필요한지, 아니면 더 이상 사용할 필요 없는지가 궁금하다.

**해결**: 함수 오버로드는 조건부 형식보다 가독성이 뛰어나고 더 쉽게 원하는 형식을 정의할 수 있다. 상황에 맞게 함수 오버로드를 사용한다.

**논의**:

### 조건부 형식의 장점: 많은 오버로드 감소

배열 `concat` 함수를 함수 오버로드로 정의하면:

```typescript
// 수십 개의 오버로드가 필요...
function concat(arr1: [], arr2: []): [];
function concat<A>(arr1: [A], arr2: []): [A];
function concat<A, B>(arr1: [A, B], arr2: []): [A, B];
// ... 계속
```

가변 튜플 형식을 사용하면:

```typescript
type Arr = readonly any[];

function concat<T extends Arr, U extends Arr>(
  arr1: T,
  arr2: U
): [...T, ...U] {
  return [...arr1, ...arr2];
}
```

### 함수 오버로드가 더 좋은 경우

#### 1. 다양한 함수 형태 (인수 목록이 다른 경우)

```typescript
// 조건부 형식으로 구현 - 복잡함
type SearchArguments =
  | [query: string, callback: (results: unknown[]) => void]
  | [query: string];

type ReturnSearch<T> = T extends [query: string]
  ? Promise<Array<unknown>>
  : void;

declare function search<T extends SearchArguments>(
  ...args: T
): ReturnSearch<T>;

// 함수 오버로드로 구현 - 명확함
function search(query: string): Promise<unknown[]>;
function search(
  query: string,
  callback: (result: unknown[]) => void
): void;
function search(
  query: string,
  callback?: (result: unknown[]) => void
): void | Promise<unknown> {
  // 구현
}
```

#### 2. 정확한 인수 매핑

이벤트 핸들러와 이벤트를 매핑하는 경우:

```typescript
// 조건부 형식 - 모호한 상황에서 문제 발생
type Handler =
  | MouseEventHandler<HTMLButtonElement>
  | KeyboardEventHandler<HTMLButtonElement>;

type Ev<T> = T extends MouseEventHandler<infer R>
  ? MouseEvent<R>
  : T extends KeyboardEventHandler<infer R>
    ? KeyboardEvent<R>
    : never;

function apply<T extends Handler>(handler: T, ev: Ev<T>): void {
  handler(ev as any);  // as any 필요!
}

// 함수 오버로드 - 명확하고 안전
function apply(
  handler: MouseEventHandler<HTMLButtonElement>,
  ev: MouseEvent<HTMLButtonElement>
): void;
function apply(
  handler: KeyboardEventHandler<HTMLButtonElement>,
  ev: KeyboardEvent<HTMLButtonElement>
): void;
function apply(handler: any, ev: any): void {
  handler(ev);
}
```

#### 3. 만능 함수 본문

조건부 형식과 함수 오버로드를 조합:

```typescript
function createLabel<T extends number | string | StringLabel | NumberLabel>(
  input: T
): GetLabel<T>;
function createLabel(
  input: number | string | StringLabel | NumberLabel
): NumberLabel | StringLabel {
  if (typeof input === "number") {
    return { id: input };
  } else if (typeof input === "string") {
    return { name: input };
  } else if ("id" in input) {
    return { id: input.id };
  } else {
    return { name: input.name };
  }
}
```

### 비교 요약

| 상황 | 권장 방법 |
|------|----------|
| 배열/튜플 조합이 다양 | 가변 튜플 형식 |
| 입력에 따라 반환 형식이 달라짐 | 조건부 형식 |
| 인수 목록이 완전히 다름 | 함수 오버로드 |
| 인수 간 정확한 매핑 필요 | 함수 오버로드 |
| 모호한 유니온 형식 방지 | 함수 오버로드 |

> **팁**: 함수 오버로드의 구현부에서는 `any`를 사용해도 괜찮습니다. 구현부는 형식 공간을 오염시키지 않습니다.

---

## 12.8 제네릭 이름 정하기

**문제**: `T`와 `U`라는 글자는 제네릭 형식 매개변수와 관련해 아무 정보도 제공하지 않는다.

**해결**: 네이밍 패턴을 따른다.

**논의**:

### 기존 관례의 문제

```typescript
type Extract<T, U> = T extends U ? T : never;
// T에서 U를 추출하는지, U에서 T를 추출하는지 구별하기 어려움
```

### 더 나은 네이밍

```typescript
type Extract<From, Union> = From extends Union ? From : never;
// 첫 번째 매개변수에서 Union에 할당될 수 있는 것을 추출
```

### 네이밍 가이드라인

1. **모든 형식 매개변수는 대문자로 시작**
2. **용도가 명확할 때만 단일 문자 사용**
   - `ParseRouteParams<R>`에서 `R`은 Route를 의미
3. **무조건 T로 약칭하지 말 것** - 구체적인 문자로 줄이기
4. **짧은 단어나 줄임말 사용** - `Elem`, `Route` 등
5. **접두어로 내장형과 구별** - `GElement`, `URLObj`
6. **추론된 형식에도 동일한 패턴 적용**

```typescript
// 개선 전
type ParseRouteParameters<T> =
  T extends `${string}/:${infer U}/${infer R}`
    ? { [P in U | keyof ParseRouteParameters<`/${R}`>]: string }
    : T extends `${string}/:${infer U}`
      ? { [P in U]: string }
      : {};

// 개선 후
type ParseRouteParams<Route> =
  Route extends `${string}/:${infer Param}/${infer Rest}`
    ? { [Entry in Param | keyof ParseRouteParams<`/${Rest}`>]: string }
    : Route extends `${string}/:${infer Param}`
      ? { [Entry in Param]: string }
      : {};
```

### T 접두사 패턴

Matt Pocock이 대중화한 방법:

```typescript
type ParseRouteParameters<TRoute> =
  TRoute extends `${string}/:${infer TParam}/${infer TRest}`
    ? { [TEntry in TParam | keyof ParseRouteParameters<`/${TRest}`>]: string }
    : TRoute extends `${string}/:${infer TParam}`
      ? { [TEntry in TParam]: string }
      : {};
```

이 패턴의 장점:
- 형식 매개변수임을 명확히 표시
- 실제 형식과 쉽게 구별

> **2025 업데이트**: ESLint의 `@typescript-eslint/naming-convention` 규칙으로 제네릭 네이밍 컨벤션을 강제할 수 있습니다:

```json
{
  "@typescript-eslint/naming-convention": [
    "error",
    {
      "selector": "typeParameter",
      "format": ["PascalCase"],
      "prefix": ["T"]
    }
  ]
}
```

---

## 12.9 타입스크립트 플레이그라운드 활용하기

**문제**: 프로젝트가 너무 커서, 형식 버그를 제대로 고치기가 어렵다.

**해결**: 형식을 타입스크립트 플레이그라운드로 이동해서 분리해 개발한다.

**논의**:

타입스크립트 플레이그라운드(https://www.typescriptlang.org/play)는 타입스크립트 개발에 필수적인 도구다.

### 플레이그라운드의 주요 기능

1. **다양한 버전 선택**: 버그가 특정 버전에서 발생하는지 쉽게 확인
2. **컴파일러 플래그 설정**: UI 또는 주석으로 설정 가능
3. **형식 정보 추출**: 변수 위에 마우스를 올려 형식 확인
4. **코드 실행**: 작은 코드 조각 테스트
5. **여러 대상으로 내보내기**: CodeSandbox, StackBlitz 등

### 주석으로 컴파일러 플래그 설정

```typescript
// @strictPropertyInitialization: false
// @target: esnext
// @module: nodenext
// @lib: es2015, dom
```

### NPM 패키지 형식 자동 획득

```typescript
import { render } from "preact";  // 자동으로 형식 로드!
```

특정 버전 지정:
```typescript
import { render } from "preact";  // types: legacy
```

### 투슬래시(Twoslash)

코드 예제용 마크업 형식:

```typescript
// @jsxFactory: h
import { render, h } from "preact";

function Heading() {
  return <h1>Hello</h1>
}

const elem = <Heading/>
//    ^? const elem: h.JSX.Element
```

`^?` 마커로 해당 위치의 형식 정보를 인라인으로 표시할 수 있다.

### 멀티파일 지원 (버그 워크벤치)

```typescript
export const a = 2;
// @filename: a.ts
import { a } from "./input.js"
console.log(a);
```

### 지스트 독셋 (Gist Docsets)

깃허브 지스트에 여러 파일을 만들어 교육/워크숍용 데모 스위트로 활용할 수 있다.

> **2025 업데이트**: 로컬 플레이그라운드 구성:

```bash
# Node.js --watch로 로컬 TypeScript 파일 감시
node --watch playground.ts

# tsx 사용
npx tsx watch playground.ts
```

```typescript
// playground.ts
type Test = ParseRouteParams<"/api/users/:id">;
//   ^? type Test = "id"

console.log("Type check passed!");
```

---

## 12.10 여러 라이브러리 버전 제공하기

**문제**: 라이브러리의 외부 형식을 구현하고 라이브러리 버전 업데이트와 형식 업데이트를 연계하려고 한다.

**해결**: 트리플 슬래시 지시어와 모듈, 네임스페이스 및 인터페이스를 이용해 선언 합치기를 구현한다.

**논의**:

### 앰비언트 모듈 선언

`@lib/lib.v1.d.ts`:
```typescript
declare module "lib" {
  export interface ConnectorConstructor {
    new(): Connector;
  }

  var Connector: ConnectorConstructor;

  export interface Connector {
    connect(stream: string): Connection;
  }

  export interface Connection {
    send(msg: string): Connection;
  }
}
```

### 버전별 기능 추가 (선언 합치기)

`@lib/lib.v2.d.ts`:
```typescript
/// <reference path="lib.v1.d.ts" />

declare module "lib" {
  export interface Connection {
    close(): void;  // v2에서 추가된 메서드
  }
}
```

### 사용할 버전 선택

`@types/lib.d.ts`:
```typescript
/// <reference path="../@lib/lib.v2.d.ts" />

declare module "lib" {}
```

버전을 바꾸려면 `lib.v2.d.ts`를 `lib.v1.d.ts`로 변경하면 된다.

### tsconfig.json 설정

```json
{
  "compilerOptions": {
    "typeRoots": ["@types"],
    "rootDir": "./src",
    "outDir": "dist"
  },
  "include": ["./src", "./@types"]
}
```

> **팁**: 타입스크립트에 포함된 라이브러리 파일(`lib.es5.d.ts`, `lib.es2015.d.ts` 등)을 살펴보면 이 기법의 실제 사례를 확인할 수 있다.

---

## 12.11 언제 멈춰야 할지 알기

**문제**: 정교하고 복잡한 형식은 쓰기 힘들다!

**해결**: 정교하고 복잡한 형식을 쓰지 말자. 타입스크립트는 점진적이다. 과감하게 생산성을 높이는 방법을 택한다.

**논의**:

### 복잡한 형식의 함정

조건부 형식과 헬퍼 형식, 가변 튜플 형식, 문자열 템플릿 리터럴 형식 등을 사용하면 솔루션이 매우 복잡해질 수 있다.

타입챌린지(https://tsch.js.org)는 형식 시스템의 가능성을 보여주는 환상적인 퍼즐 프로젝트지만, 대부분은 실전과 거리가 있다.

### 점진적 형식의 장점

타입스크립트의 훌륭한 기능을 간과하지 말자:
- `any` 사용 가능
- 제네릭 형식 매개변수
- 형식 어서션
- 간단한 자바스크립트에 몇 개의 주석만 추가

### 파레토 법칙 (80/20 법칙)

**형식 안전성의 80%는 20%의 기능에서 비롯된다.**

나머지 부분이 나쁘거나 불필요하다는 뜻은 아니다. 어디에 노력을 기울여야 할지 알려줄 뿐이다.

### 실용적인 조언

1. **모든 상황에 고급 기능을 사용하려 하지 말자**
2. **느슨한 형식이 문제가 되는지 모니터하자**
3. **형식을 바꿀 때 드는 노력을 추정하자**
4. **충분한 정보를 바탕으로 결정을 내리자**
5. **단계별 정제 과정(12.2절)을 거쳐 언제든 쉽게 멈출 수 있음을 기억하자**

> **인용**: 타입스크립트 웹사이트는 "확장하는 자바스크립트(JavaScript that Scales)"에서 **"형식에 대한 구문이 있는 자바스크립트(JavaScript with Syntax for Types)"**로 워딩을 변경했다.

### 결론

자바스크립트 코드를 구현하고, 필요한 곳에 애너테이션을 추가하며, 단순하지만 종합적인 형식을 구현하고, 타입스크립트로 소프트웨어를 문서화하고, 이해하며 소통하자.

**언제나 단순한 형식이 더 나은 형식이다. 이해하기 쉽고 사용하기 훨씬 쉽기 때문이다.**

> **2025 업데이트**: TypeScript 5.x의 새로운 기능들:

| 버전 | 주요 기능 |
|------|----------|
| **5.5** | 자동 타입 프레디케이트 추론 (Array.filter에서 자동 좁히기) |
| **5.6** | 항상 truthy/nullish 조건 엄격 검사, `--noCheck` 옵션 |
| **5.8** | `--erasableSyntaxOnly` 옵션 |
| **5.9** | `import defer` 지원 |

```typescript
// TypeScript 5.5: 자동 타입 프레디케이트 추론
const numbers = [1, 2, null, 3, undefined, 4];
const filtered = numbers.filter((n) => n !== null && n !== undefined);
// filtered: number[] (자동 추론!)

// 이전에는 명시적으로 타입 가드가 필요했음
const filteredOld = numbers.filter(
  (n): n is number => n !== null && n !== undefined
);
```

---

## 요약

이 장에서 배운 핵심 내용:

1. **유지보수가 쉬운 형식**: `typeof`, `Partial`, 매핑된 형식으로 형식을 자동 생성
2. **단계별 형식 다듬기**: 기본 형식 → 부분집합 → 제네릭 → 고급 형식
3. **satisfies 연산자**: 계약 검사 + 리터럴 형식 유지
4. **형식 테스트**: `Equal`, `Expect`, Vitest의 `expectTypeOf`
5. **런타임 검증**: Zod 및 대안 라이브러리 (Valibot, ArkType)
6. **인덱스 접근**: 제네릭으로 `never` 오류 해결
7. **함수 오버로드 vs 조건부 형식**: 상황에 맞게 선택
8. **제네릭 네이밍**: 의미 있는 이름, T 접두사 패턴
9. **플레이그라운드**: 독립적인 형식 개발, 투슬래시
10. **라이브러리 버전**: 앰비언트 모듈, 선언 합치기
11. **언제 멈춰야 할지**: 단순한 형식이 더 나은 형식
