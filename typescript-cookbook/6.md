# 6장 문자열 템플릿 리터럴 형식

## 6.1 사용자 정의 이벤트 시스템 정의하기

**문제** 사용자 정의 이벤트 시스템을 만들 때 모든 이벤트 명은 "on"으로 시작하도록 이름 규칙을 정하려 한다.

**해결** 문자열 템플릿 리터럴 형식을 이용해 문자열 패턴을 기술한다.

```ts
type EventName = `on${string}`; // `on` 접두사를 강제

type EventObject<T> = { val: T }; // 콜백에 전달되는 페이로드 래퍼
type Callback<T = unknown> = (ev: EventObject<T>) => void; // 이벤트 리스너 시그니처

type Events = {
  [key in EventName]?: Callback[]; // 유효한 이벤트 이름마다 콜백 배열 저장
};

class EventSystem {
  private events: Events = {}; // 메모리 기반 이벤트 저장소

  defineEventHandler(ev: EventName, cb: Callback) {
    // 이벤트 리스너를 등록
    this.events[ev] ??= [];
    this.events[ev]!.push(cb);
  }

  trigger(ev: EventName, value: unknown) {
    // 값을 포함해 이벤트를 발생
    this.events[ev]?.forEach((cb) => cb({ val: value }));
  }
}
```

**논의**
템플릿 리터럴 타입은 자바스크립트 템플릿 문자열의 문법을 타입 차원에서 다시 활용한다. `` type EventName = `on${string}`; ``처럼 정의하면 `on`으로 시작하는 모든 문자열만 허용된다.

- `` `on${string}` ``은 "`on`으로 시작하는 어떤 문자열이든 허용"이라는 규칙을 한 줄로 표현한다. 이벤트 이름이 늘어날수록 오탈자 가능성이 커지는데, 템플릿 리터럴 타입으로 이를 컴파일 단계에서 차단한다.
- `Events` 매핑 타입은 `EventName`을 키로 사용한다. 따라서 `events["click"]`처럼 잘못된 접근을 시도하면 타입 검사가 즉시 실패한다.
- `defineEventHandler`에서는 `??=`로 콜백 배열을 초기화한 뒤 푸시한다. 모든 인덱스가 템플릿 규칙을 통과한 이름이기 때문에 런타임에서도 제한된 문자열만 저장된다.

> **팁**: `system.defineEventHandler("click", ...)`는 즉시 타입 오류가 나지만 `system.defineEventHandler("onClick", ...)`은 정상 동작한다. 문자열 패턴을 타입으로 적어 두면 런타임에 도달하기 전에 일관성을 보장할 수 있다.

```ts
const system = new EventSystem();

system.defineEventHandler("onLogin", (ev) => {
  console.log("로그인 값:", ev.val);
});

// system.defineEventHandler("login", () => {}); // 타입 오류

system.trigger("onLogin", { user: "Stefan" });
```

## 6.2 문자열 조작 형식과 키 매핑으로 이벤트 콜백 만들기

**문제** 아무 객체를 받아 각 프로퍼티에 와쳐 함수를 추가하는 `watch` 함수를 제공해서 이벤트 콜백을 정의하도록 허용하려 한다.

**해결** 키 매핑을 이용해 새 문자열 프로퍼티 키를 만든다. 와쳐 함수가 적절한 낙타 표기법을 사용하도록 문자열 조작 형식을 이용한다.

6.1절에서 만든 이벤트 시스템에 감시 기능을 얹으려면 원본 객체의 키를 `on{Name}Changed` 형태로 재구성해야 한다.

```ts
type WatchedObject<T> = {
  [K in string & keyof T as `on${Capitalize<K>}Changed`]: (
    ev: EventObject<T[K]>
  ) => void;
};
```

**논의**
이 매핑된 타입에 담긴 의미를 하나씩 뜯어보면 다음과 같다.

1. `K in string & keyof T`는 `T`의 키 중 문자열인 것만 선택한다. 숫자 키나 심벌 키는 감시 대상이 아니므로 교집합을 사용해 걸러낸다.
2. `as` 구문은 "키 재매핑"을 뜻한다. 원래 키 `K`를 바로 쓰는 대신 `` `on${...}Changed` ``라는 새 문자열 키로 바꿔서 결과 타입에 넣는다.
3. `Capitalize<K>` 덕분에 `name`이 `onNameChanged`처럼 낙타 표기법으로 변환된다.
4. 각 프로퍼티 값은 `(ev: EventObject<T[K]>) => void` 타입의 콜백이다.

| 내장 문자열 조작 타입 | 기능 | 예시 |
|---------------------|------|------|
| `Capitalize<S>` | 첫 글자 대문자 | `"hello"` → `"Hello"` |
| `Uncapitalize<S>` | 첫 글자 소문자 | `"Hello"` → `"hello"` |
| `Uppercase<S>` | 전체 대문자 | `"hello"` → `"HELLO"` |
| `Lowercase<S>` | 전체 소문자 | `"HELLO"` → `"hello"` |

`WatchedObject`를 확인해 보면 `system.watch({ name: "Stefan", age: 40 })` 호출 결과의 타입이 다음처럼 계산된다.

```ts
type WatchedPerson = {
  onNameChanged: (ev: EventObject<string>) => void;
  onAgeChanged: (ev: EventObject<number>) => void;
};
```

런타임에서도 동일한 규칙을 재현해야 실제로 동작하는 감시 객체가 만들어진다. 문자열 조작을 위해 두 개의 헬퍼 함수를 준비한다.

```ts
function capitalize(inp: string): string {
  return inp.charAt(0).toUpperCase() + inp.slice(1);
}

function handlerName(name: string): EventName {
  return `on${capitalize(name)}Changed` as EventName;
}
```

이제 `watch` 구현에서 `Proxy`로 `get`과 `set`을 가로채 이벤트 등록과 트리거를 연결한다.

```ts
class EventSystem {
  // ...defineEventHandler, trigger 생략...
  watch<T extends object>(obj: T): T & WatchedObject<T> {
    const self = this;
    return new Proxy(obj, {
      get(target, property) {
        if (typeof property === "string") {
          if (property.startsWith("on") && property.endsWith("Changed")) {
            return (cb: Callback) =>
              self.defineEventHandler(property as EventName, cb);
          }
          return target[property as keyof T];
        }
        return undefined;
      },
      set(target, property, value) {
        if (typeof property === "string" && property in target) {
          target[property as keyof T] = value;
          self.trigger(handlerName(property), value);
          return true;
        }
        return false;
      },
    }) as T & WatchedObject<T>;
  }
}
```

> **팁**: `Proxy.get` 트랩에서는 `on*Changed` 형태로 접근한 경우 이벤트 등록 함수를 반환한다. `Proxy.set` 트랩은 실제 값을 갱신한 뒤 이벤트를 트리거한다. 타입 시스템이 메서드의 존재와 콜백 시그니처를 보장해 주기 때문에 감시 기능이 일관성 있게 작동한다.

```ts
const system = new EventSystem();
const person = { name: "Stefan", age: 40 };
const watchedPerson = system.watch(person);

watchedPerson.onAgeChanged((ev) => {
  console.log(ev.val, "changed!!");
});

watchedPerson.age = 41; // 콘솔: "41 changed!!"
```

## 6.3 포맷 함수 구현하기

**문제** 포맷 문자열을 받아 실제 값으로 플레이스홀더를 치환하는 함수의 형식을 만들어야 한다.

**해결** 문자열 템플릿 리터럴 형식에서 플레이스홀더 명을 추론하는 조건부 형식을 만든다.

```ts
type FormatKeys<T extends string> =
  T extends `${string}{${infer Key}}${infer Rest}`
    ? Key | FormatKeys<Rest> // 모든 플레이스홀더 이름을 수집
    : never;

function format<T extends string, K extends Record<FormatKeys<T>, unknown>>(
  fmt: T,
  params: K
): string {
  let ret = fmt;
  for (const key in params) {
    ret = ret.replaceAll(`{${key}}`, String(params[key])); // 플레이스홀더를 실제 값으로 치환
  }
  return ret;
}
```

**논의**
`{placeholder}` 패턴을 갖는 문자열을 분석하려면 재귀 조건부 타입으로 모든 플레이스홀더 키를 수집하면 된다.

`FormatKeys`가 작동하는 과정:

1. 문자열이 `{...}` 패턴을 포함하면 `infer Key`가 중괄호 안의 텍스트를 추출하고, `infer Rest`는 그 이후의 잔여 문자열을 잡아 둔다.
2. 재귀 분기는 `Key | FormatKeys<Rest>`로 이어진다. 첫 번째 플레이스홀더 이름을 수집하고, 나머지 문자열에서도 동일한 과정을 반복해 모든 키를 합집합으로 만든다.
3. 더 이상 `{`가 발견되지 않으면 `never`로 귀결돼 재귀가 종료된다.

```ts
type GreetingKeys = FormatKeys<"Hello {world}. I'm {you}.">;
// GreetingKeys === "world" | "you"

type EmptyKeys = FormatKeys<"Hello">;
// EmptyKeys === never
```

> **팁**: `format("Hello {world}.", { world: "World" })`는 통과하지만 `world` 키가 빠지면 컴파일 타임에 오류가 발생한다. 문자열을 타입으로 파싱해 요구사항을 명시적으로 선언한 셈이다.

> **2025 업데이트**: TypeScript 5.0+에서 `const` 타입 매개변수와 함께 사용하면 포맷 문자열의 리터럴 타입을 더 정확하게 추론할 수 있다:
> ```ts
> function format<const T extends string>(
>   fmt: T,
>   params: Record<FormatKeys<T>, unknown>
> ): string { ... }
> ```


## 6.4 포맷 매개변수 형식 추출하기

**문제** 플레이스홀더의 형식을 정의할 수 있도록 6.3절의 포맷 함수를 확장하려 한다.

**해결** 중첩된 조건부 형식을 만들고 형식 맵으로 형식을 찾는다.

```ts
type MapFormatType = {
  string: string; // {key:string} 형태 대응
  number: number; // {key:number} 형태 대응
  boolean: boolean; // {key:boolean} 형태 대응
  [kind: string]: { toString(): string }; // 기본값은 최소한 toString을 구현해야 함
};

type FormatObj<T extends string> =
  T extends `${string}{${infer Raw}}${infer Rest}`
    ? Raw extends `${infer Key}:${infer Kind}`
      ? { [K in Key]: MapFormatType[Kind] } & FormatObj<Rest> // 타입이 지정된 플레이스홀더를 매핑
      : { [K in Raw]: { toString(): string } } & FormatObj<Rest> // 타입이 없는 플레이스홀더 허용
    : {};

function format<T extends string, K extends FormatObj<T>>(
  fmt: T,
  params: K
): string {
  let ret = fmt;
  for (const key in params) {
    const pattern = new RegExp(`{${key}(?::[^}]+)?}`, "g"); // 선택적인 타입 주석을 포함한 플레이스홀더 매칭
    ret = ret.replaceAll(pattern, params[key].toString()); // 타입 조건을 지키면서 치환
  }
  return ret;
}
```

**논의**
`{key:type}`처럼 타입 힌트를 명시하면 각 플레이스홀더에 들어갈 실제 타입을 결정할 수 있다.

- `MapFormatType`은 플레이스홀더에 붙는 문자열(`string`, `number`, `boolean` 등)과 실제 타입 간의 대응표다. 미리 정의되지 않은 키는 `{ toString(): string }`으로 매핑해 최소한 문자열로 변환 가능한 값만 허용한다.
- `FormatObj<T>`는 포맷 문자열을 왼쪽에서 오른쪽으로 훑는다. `{key:type}` 패턴을 만나면 `Key`와 `Kind`를 분리하고, `MapFormatType[Kind]`을 통해 올바른 값 타입을 가져온다.
- 재귀가 진행될수록 `{ [K in Key]: ... } & FormatObj<Rest>`처럼 누적 교집합이 만들어진다.

```ts
type FormatShape = FormatObj<"{name:string} is {age:number}">;
/*
  {
    name: string;
    age: number;
  }
*/

type LooseShape = FormatObj<"{value}">;
// { value: { toString(): string } }
```

> **팁**: `format("{name:string} is {age:number}", { name: "Stefan", age: 40 })`는 올바르지만 `age: "40"`처럼 잘못된 타입을 넣으면 컴파일러가 즉시 규칙 위반을 알려 준다.


## 6.5 재귀 한계 처리하기

**문제** 문자열을 유효한 프로퍼티 키로 변환하는 문자열 템플릿 리터럴 형식을 만들었다. 헬퍼 형식을 설정하다 보니 재귀 한계에 다다랐다.

**해결** 누적 기법을 이용해 꼬리 호출 최적화를 진행한다.

타입 시스템에서도 재귀 조건부 타입을 사용할 수 있지만, 반복 깊이가 과도해지면 TypeScript가 `ts(2589)` 경고("형식 인스턴스화 깊이가 매우 깊습니다")를 내고 평가를 중단한다.

```ts
type Trim<T extends string> = T extends ` ${infer Rest}`
  ? Trim<Rest>
  : T extends `${infer Rest} `
  ? Trim<Rest>
  : T;

type Trimmed = Trim<" key ">; // "key"
```

**논의**
문자열을 "공백 제거 → 낙타 표기법 변환 → 허용 문자 검증" 같은 여러 단계로 가공하려고 재귀를 겹겹이 쌓으면 금세 한계에 도달한다.

### 공백 제거와 낙타 표기법 변환

```ts
type RemoveWhiteSpace<T extends string> = T extends `${infer A} ${infer B}`
  ? RemoveWhiteSpace<`${Uncapitalize<A>}${Capitalize<B>}`>
  : T;

type Compact = RemoveWhiteSpace<"Hello World!">; // "helloWorld!"
```

### 허용 가능한 문자 집합 만들기

```ts
type StringSplit<T extends string> = T extends `${infer Char}${infer Rest}`
  ? Capitalize<Char> | Uncapitalize<Char> | StringSplit<Rest>
  : never;

type Chars = StringSplit<"abcdefghijklmnopqrstuvwxyz">;
// "a" | "A" | "b" | "B" | ... | "z" | "Z"
```

### 누적자(accumulator)로 꼬리 호출 형태 만들기

재귀를 안전하게 유지하려면 중간 결과를 별도 매개변수에 담아 다음 호출로 전달해야 한다.

```ts
type CreateIdentifier<
  T extends string,
  Acc extends string = ""
> = RemoveWhiteSpace<T> extends `${infer A extends Chars}${infer Rest}`
  ? CreateIdentifier<Rest, `${Acc}${A}`>
  : RemoveWhiteSpace<T> extends `${infer _}${infer Rest}`
  ? CreateIdentifier<Rest, Acc>
  : Acc;

type SafeIdentifier = CreateIdentifier<"Hello Wor!ld!">; // "helloWorld"
```

> **팁**: 각 재귀 호출이 독립적으로 평가되기 때문에 컴파일러가 더 이상 깊은 재귀 경고를 내지 않는다. 모든 문자를 확인하고 나면 누적자 `Acc`에 쌓인 문자열이 최종 결과로 반환된다.

| 재귀 패턴 | 특징 | 깊은 재귀 가능 |
|----------|------|---------------|
| 일반 재귀 | 중간 결과를 템플릿에 포함 | 제한적 |
| 꼬리 호출 (누적자) | 중간 결과를 별도 매개변수로 전달 | 가능 |

> **2025 업데이트**: TypeScript 4.5 이후 꼬리 호출 최적화가 적용된 재귀 타입은 최대 1000 단계까지 처리할 수 있다. 이전에는 약 50 단계가 한계였다.


## 6.6 템플릿 리터럴을 구별자로 사용하기

**문제** 백엔드 요청 상태를 pending에서 error나 success로 변경하는 상태 머신을 모델링하려 한다. 다양한 백엔드 요청에 이들 상태를 적용하면서 내부 형식은 하나로 유지해야 한다.

**해결** 문자열 템플릿 리터럴을 구별된 유니온의 구별자로 사용한다.

```ts
type Data = {
  user: User | null;
  order: Order | null;
};

type RequestConstants = keyof Data; // 백엔드 리소스 키 집합

type Pending = { state: `${Uppercase<RequestConstants>}_PENDING` }; // 대기 상태 문자열 패턴
type Err = { state: `${Uppercase<RequestConstants>}_ERROR`; message: string }; // 오류 상태와 메시지

type Success = {
  [K in RequestConstants]: {
    state: `${Uppercase<K>}_SUCCESS`;
    data: NonNullable<Data[K]>; // 해당 리소스의 실제 데이터 타입
  };
}[RequestConstants];

type BackendRequest = Pending | Err | Success; // 상태 머신용 판별 유니온
```

**논의**
상태 머신에서 `state` 프로퍼티가 분기 기준이 된다면 문자열 패턴을 고정해 두는 편이 안전하다.

- `${Uppercase<...>}_STATUS` 형태로 정의하면 정해진 접두/접미사를 반드시 갖는 값만 허용할 수 있다.
- `Success` 타입은 매핑 타입과 인덱스 접근을 조합해 각 리소스별로 정확한 데이터 타입을 연결한다.
- `switch (req.state)` 문에서 각 분기마다 정확한 데이터 타입으로 좁혀진다.

> **팁**: 새로운 요청 종류를 `Data`에 추가하면 관련된 상태 문자열과 응답 타입이 동시에 확장되어 일관성을 유지할 수 있다. 예를 들어 `case "USER_SUCCESS": login(req.data);`처럼 데이터 접근이 자연스럽다.

---

## 템플릿 리터럴 타입 패턴 요약

| 패턴 | 용도 | 예시 |
|-----|------|------|
| 접두사 강제 | 이벤트명, API 경로 | `` `on${string}` `` |
| 키 재매핑 | 와쳐, getter/setter | `` `on${Capitalize<K>}Changed` `` |
| 플레이스홀더 추출 | 포맷 함수, i18n | `` `${string}{${infer Key}}${infer Rest}` `` |
| 구별자 패턴 | 상태 머신, Redux 액션 | `` `${Uppercase<K>}_SUCCESS` `` |
| 재귀 파싱 | 문자열 변환, 유효성 검사 | 누적자 + infer |
