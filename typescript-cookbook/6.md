# 6장 문자열 템플릿 리터럴 형식

## 6.1 사용자 정의 이벤트 시스템 정의하기

**문제** 사용자 정의 이벤트 시스템을 만들 때 모든 이벤트 명은 "on"으로 시작하도록 이름 규칙을 정하려 한다.

**해결** 문자열 템플릿 리터럴 형식을 이용해 문자열 패턴을 기술한다.

템플릿 리터럴 타입은 자바스크립트 템플릿 문자열의 문법을 타입 차원에서 다시 활용한다. `` type EventName = `on${string}`; ``처럼 정의하면 `on`으로 시작하는 모든 문자열만 허용된다. 이 규칙을 `EventSystem`에 적용하면 잘못된 이벤트 이름이 빌드 단계에서 차단된다.

```ts
type EventName = `on${string}`; // `on` 접두사를 강제

type EventObject<T> = { val: T }; // 콜백에 전달되는 페이로드 래퍼
type Callback<T = unknown> = (ev: EventObject<T>) => void; // 이벤트 리스너 시그니처

type Events = {
  [key in EventName]?: Callback[]; // 유효한 이벤트 이름마다 콜백 배열 저장
};

class EventSystem {
  private events: Events = {}; // 메모리 기반 이벤트 저장소

  defineEventHandler(ev: EventName, cb: Callback) {
    // 이벤트 리스너를 등록
    this.events[ev] ??= [];
    this.events[ev]!.push(cb);
  }

  trigger(ev: EventName, value: unknown) {
    // 값을 포함해 이벤트를 발생
    this.events[ev]?.forEach((cb) => cb({ val: value }));
  }
}
```

예를 들어 `system.defineEventHandler("click", ...)`는 즉시 타입 오류가 나지만 `system.defineEventHandler("onClick", ...)`은 정상 동작한다. 문자열 패턴을 타입으로 적어 두면 런타임에 도달하기 전에 일관성을 보장할 수 있다.

위 선언에는 몇 가지 포인트가 숨어 있다.

- `` `on${string}` ``은 “`on`으로 시작하는 어떤 문자열이든 허용”이라는 규칙을 한 줄로 표현한다. 이벤트 이름이 늘어날수록 오탈자 가능성이 커지는데, 템플릿 리터럴 타입으로 이를 컴파일 단계에서 차단한다.
- `Events` 매핑 타입은 `EventName`을 키로 사용한다. 따라서 `events["click"]`처럼 잘못된 접근을 시도하면 타입 검사가 즉시 실패한다.
- `defineEventHandler`에서는 `??=`로 콜백 배열을 초기화한 뒤 푸시한다. 모든 인덱스가 템플릿 규칙을 통과한 이름이기 때문에 런타임에서도 제한된 문자열만 저장된다.
- `trigger`는 등록된 콜백을 순회하면서 `{ val: value }` 형태의 래퍼를 전달한다. 이 구조를 다음 절에서 감시 기능과 결합해 재사용한다.

실제로 사용하면 다음과 같이 동작한다.

```ts
const system = new EventSystem();

system.defineEventHandler("onLogin", (ev) => {
  console.log("로그인 값:", ev.val);
});

// system.defineEventHandler("login", () => {}); // 타입 오류

system.trigger("onLogin", { user: "Stefan" });
```

템플릿 리터럴 타입을 기반으로 한 `EventSystem` 덕분에 런타임 이전에 잘못된 이벤트 이름을 차단하고, 허용된 이벤트만 정의·실행할 수 있다.

## 6.2 문자열 조작 형식과 키 매핑으로 이벤트 콜백 만들기

**문제** 아무 객체를 받아 각 프로퍼티에 와쳐 함수를 추가하는 `watch` 함수를 제공해서 이벤트 콜백을 정의하도록 허용하려 한다.

**해결** 키 매핑을 이용해 새 문자열 프로퍼티 키를 만든다. 와쳐 함수가 적절한 낙타 표기법을 사용하도록 문자열 조작 형식을 이용한다.

6.1절에서 만든 이벤트 시스템에 감시 기능을 얹으려면 원본 객체의 키를 `on{Name}Changed` 형태로 재구성해야 한다. 우선 어떤 객체든 감시 대상으로 넘길 수 있어야 하므로 `watch`가 반환할 새로운 메서드 집합을 타입 단계에서 먼저 정의한다.

```ts
type WatchedObject<T> = {
  [K in string & keyof T as `on${Capitalize<K>}Changed`]: (
    ev: EventObject<T[K]>
  ) => void;
};
```

이 매핑된 타입에 담긴 의미를 하나씩 뜯어보면 다음과 같다.

1. `K in string & keyof T`는 `T`의 키 중 문자열인 것만 선택한다. 숫자 키나 심벌 키는 감시 대상이 아니므로 교집합을 사용해 걸러낸다.
2. `as` 구문은 “키 재매핑”을 뜻한다. 원래 키 `K`를 바로 쓰는 대신 `` `on${...}Changed` ``라는 새 문자열 키로 바꿔서 결과 타입에 넣는다.
3. `Capitalize<K>` 덕분에 `name`이 `onNameChanged`처럼 낙타 표기법으로 변환된다. `Lowercase`, `Uppercase`, `Uncapitalize` 같은 내장 문자열 조작 형식도 같은 방식으로 사용할 수 있다.
4. 각 프로퍼티 값은 `(ev: EventObject<T[K]>) => void` 타입의 콜백이다. 콜백이 받는 `EventObject`의 제네릭 파라미터가 `T[K]`로 지정되므로, 원본 객체에서 해당 키가 가리키는 값의 타입을 그대로 전달한다.

`WatchedObject`를 확인해 보면 `system.watch({ name: "Stefan", age: 40 })` 호출 결과의 타입이 다음처럼 계산된다.

```ts
type WatchedPerson = {
  onNameChanged: (ev: EventObject<string>) => void;
  onAgeChanged: (ev: EventObject<number>) => void;
};
```

여기까지는 타입 이야기다. 동일한 규칙을 런타임에서도 재현해야 실제로 동작하는 감시 객체가 만들어진다. 문자열 조작을 위해 두 개의 헬퍼 함수를 준비한다.

```ts
function capitalize(inp: string): string {
  return inp.charAt(0).toUpperCase() + inp.slice(1);
}

function handlerName(name: string): EventName {
  return `on${capitalize(name)}Changed` as EventName;
}
```

`capitalize`는 문자열의 첫 글자를 대문자로 바꾸고, `handlerName`은 타입에서 했던 템플릿 조합을 그대로 수행한다. `as EventName` 단언은 런타임 문자열이 `EventName` 패턴을 지킨다는 사실을 컴파일러에 알려 주기 위해 필요하다.

이제 `watch` 구현에서 `Proxy`로 `get`과 `set`을 가로채 이벤트 등록과 트리거를 연결한다.

```ts
class EventSystem {
  // ...defineEventHandler, trigger 생략...
  watch<T extends object>(obj: T): T & WatchedObject<T> {
    const self = this;
    return new Proxy(obj, {
      get(target, property) {
        if (typeof property === "string") {
          if (property.startsWith("on") && property.endsWith("Changed")) {
            return (cb: Callback) =>
              self.defineEventHandler(property as EventName, cb);
          }
          return target[property as keyof T];
        }
        return undefined;
      },
      set(target, property, value) {
        if (typeof property === "string" && property in target) {
          target[property as keyof T] = value;
          self.trigger(handlerName(property), value);
          return true;
        }
        return false;
      },
    }) as T & WatchedObject<T>;
  }
}
```

`Proxy.get` 트랩에서는 `on*Changed` 형태로 접근한 경우 이벤트 등록 함수를 반환한다. 나머지 프로퍼티는 원래 값에 접근하도록 그대로 돌려보낸다. `Proxy.set` 트랩은 실제 값을 갱신한 뒤 `handlerName`으로 계산한 이벤트 이름을 `trigger`에 전달해 모든 등록된 콜백을 실행한다.

전체 흐름은 아래 예제처럼 동작한다.

```ts
const system = new EventSystem();
const person = { name: "Stefan", age: 40 };
const watchedPerson = system.watch(person);

watchedPerson.onAgeChanged((ev) => {
  console.log(ev.val, "changed!!");
});

watchedPerson.age = 41; // 콘솔: "41 changed!!"
```

타입 시스템이 `onAgeChanged` 메서드의 존재와 콜백 시그니처를 보장해 주고, 런타임 코드가 동일한 규칙으로 이벤트를 연결해 주기 때문에 감시 기능이 일관성 있게 작동한다.

## 6.3 포맷 함수 구현하기

**문제** 포맷 문자열을 받아 실제 값으로 플레이스홀더를 치환하는 함수의 형식을 만들어야 한다.

**해결** 문자열 템플릿 리터럴 형식에서 플레이스홀더 명을 추론하는 조건부 형식을 만든다.

`{placeholder}` 패턴을 갖는 문자열을 분석하려면 재귀 조건부 타입으로 모든 플레이스홀더 키를 수집하면 된다. 그 결과를 이용해 `params` 객체가 항상 필요한 속성을 포함하도록 강제한다.

```ts
type FormatKeys<T extends string> =
  T extends `${string}{${infer Key}}${infer Rest}`
    ? Key | FormatKeys<Rest> // 모든 플레이스홀더 이름을 수집
    : never;

function format<T extends string, K extends Record<FormatKeys<T>, unknown>>(
  fmt: T,
  params: K
): string {
  let ret = fmt;
  for (const key in params) {
    ret = ret.replaceAll(`{${key}}`, String(params[key])); // 플레이스홀더를 실제 값으로 치환
  }
  return ret;
}
```

`format("Hello {world}.", { world: "World" })`는 통과하지만 `world` 키가 빠지면 컴파일 타임에 오류가 발생한다. 문자열을 타입으로 파싱해 요구사항을 명시적으로 선언한 셈이다.

`FormatKeys`가 작동하는 과정을 차근히 보면 다음과 같다.

1. 문자열이 `{...}` 패턴을 포함하면 `infer Key`가 중괄호 안의 텍스트를 추출하고, `infer Rest`는 그 이후의 잔여 문자열을 잡아 둔다.
2. 재귀 분기는 `Key | FormatKeys<Rest>`로 이어진다. 첫 번째 플레이스홀더 이름을 수집하고, 나머지 문자열에서도 동일한 과정을 반복해 모든 키를 합집합으로 만든다.
3. 더 이상 `{` 가 발견되지 않으면 `never`로 귀결돼 재귀가 종료된다.

컴파일러가 실제로 어떤 키를 추론하는지 살펴보면 이해가 빠르다.

```ts
type GreetingKeys = FormatKeys<"Hello {world}. I'm {you}.">;
// GreetingKeys === "world" | "you"

type EmptyKeys = FormatKeys<"Hello">;
// EmptyKeys === never
```

`format` 함수의 두 번째 제네릭 인수 `K`는 `Record<FormatKeys<T>, unknown>`을 기반으로 한다. 즉, `params` 객체는 플레이스홀더 이름을 모두 포함해야 하며, 키가 빠지면 곧장 타입 오류가 난다. 반대로 `FormatKeys<T>`가 `never`인 상황에서는 `Record<never, unknown>`이 `{}`와 같아지므로, 플레이스홀더가 없는 문자열에서는 빈 객체만 허용된다.

런타임 구현은 간단히 `replaceAll`로 플레이스홀더를 치환하지만, 타입 단계에서 이미 키 유효성을 검사했기 때문에 함수 내부에서 추가 검증이 필요 없다.

## 6.4 포맷 매개변수 형식 추출하기

**문제** 플레이스홀더의 형식을 정의할 수 있도록 6.3절의 포맷 함수를 확장하려 한다.

**해결** 중첩된 조건부 형식을 만들고 형식 맵으로 형식을 찾는다.

`{key:type}`처럼 타입 힌트를 명시하면 각 플레이스홀더에 들어갈 실제 타입을 결정할 수 있다. 먼저 `MapFormatType`으로 문자열 키를 실제 타입에 대응시키고, 그 다음 `FormatObj`가 포맷 문자열을 파싱해 객체 타입을 만들어 낸다.

```ts
type MapFormatType = {
  string: string; // {key:string} 형태 대응
  number: number; // {key:number} 형태 대응
  boolean: boolean; // {key:boolean} 형태 대응
  [kind: string]: { toString(): string }; // 기본값은 최소한 toString을 구현해야 함
};

type FormatObj<T extends string> =
  T extends `${string}{${infer Raw}}${infer Rest}`
    ? Raw extends `${infer Key}:${infer Kind}`
      ? { [K in Key]: MapFormatType[Kind] } & FormatObj<Rest> // 타입이 지정된 플레이스홀더를 매핑
      : { [K in Raw]: { toString(): string } } & FormatObj<Rest> // 타입이 없는 플레이스홀더 허용
    : {};

function format<T extends string, K extends FormatObj<T>>(
  fmt: T,
  params: K
): string {
  let ret = fmt;
  for (const key in params) {
    const pattern = new RegExp(`{${key}(?::[^}]+)?}`, "g"); // 선택적인 타입 주석을 포함한 플레이스홀더 매칭
    ret = ret.replaceAll(pattern, params[key].toString()); // 타입 조건을 지키면서 치환
  }
  return ret;
}
```

이제 `format("{name:string} is {age:number}", { name: "Stefan", age: 40 })`는 올바르지만 `age: "40"`처럼 잘못된 타입을 넣으면 컴파일러가 즉시 규칙 위반을 알려 준다.

여기서 핵심이 되는 요소를 정리하면 다음과 같다.

- `MapFormatType`은 플레이스홀더에 붙는 문자열(`string`, `number`, `boolean` 등)과 실제 타입 간의 대응표다. 미리 정의되지 않은 키는 `{ toString(): string }`으로 매핑해 최소한 문자열로 변환 가능한 값만 허용한다.
- `FormatObj<T>`는 포맷 문자열을 왼쪽에서 오른쪽으로 훑는다. `{key:type}` 패턴을 만나면 `Key`와 `Kind`를 분리하고, `MapFormatType[Kind]`을 통해 올바른 값 타입을 가져온다. 타입 힌트가 없으면 기본 fallback(`{ toString(): string }`)으로 처리한다.
- 재귀가 진행될수록 `{ [K in Key]: ... } & FormatObj<Rest>`처럼 누적 교집합이 만들어진다. 덕분에 서로 다른 플레이스홀더 키가 하나의 객체 타입 안에서 결합된다.

예를 들어 다음과 같은 타입이 계산된다.

```ts
type FormatShape = FormatObj<"{name:string} is {age:number}">;
/*
  {
    name: string;
    age: number;
  }
*/

type LooseShape = FormatObj<"{value}">;
// { value: { toString(): string } }
```

함수 구현에서는 정규식 `new RegExp(\`{${key}(?::[^}]+)?}\`, "g")`로 `{key}`와 `{key:type}`두 경우를 동시에 찾아 치환한다. 타입 시스템이 이미`params[key]`의 형태를 보증하므로, 런타임에서는 `toString()`으로 문자열을 얻어 안전하게 치환만 수행하면 된다.

## 6.5 재귀 한계 처리하기

**문제** 문자열을 유효한 프로퍼티 키로 변환하는 문자열 템플릿 리터럴 형식을 만들었다. 헬퍼 형식을 설정하다 보니 재귀 한계에 다다랐다.

**해결** 누적 기법을 이용해 꼬리 호출 최적화를 진행한다.

타입 시스템에서도 재귀 조건부 타입을 사용할 수 있지만, 반복 깊이가 과도해지면 TypeScript가 `ts(2589)` 경고(“형식 인스턴스화 깊이가 매우 깊습니다”)를 내고 평가를 중단한다. 예를 들어 문자열 양쪽 공백을 제거하는 간단한 `Trim` 타입은 문제없이 동작한다.

```ts
type Trim<T extends string> = T extends ` ${infer Rest}`
  ? Trim<Rest>
  : T extends `${infer Rest} `
  ? Trim<Rest>
  : T;

type Trimmed = Trim<" key ">; // "key"
```

하지만 문자열을 “공백 제거 → 낙타 표기법 변환 → 허용 문자 검증” 같은 여러 단계로 가공하려고 재귀를 겹겹이 쌓으면 금세 한계에 도달한다. 책의 시나리오는 임의의 문자열을 안전한 식별자로 만드는 것이다.

### 공백 제거와 낙타 표기법 변환

먼저 공백을 찾아 앞 단어는 소문자, 뒤 단어는 대문자로 이어붙이는 재귀 타입을 만든다.

```ts
type RemoveWhiteSpace<T extends string> = T extends `${infer A} ${infer B}`
  ? RemoveWhiteSpace<`${Uncapitalize<A>}${Capitalize<B>}`>
  : T;

type Compact = RemoveWhiteSpace<"Hello World!">; // "helloWorld!"
```

### 허용 가능한 문자 집합 만들기

허용된 문자인지 검사하려면 알파벳 목록을 유니온 타입으로 변환해야 한다. 문자열을 한 글자씩 잘라 대문자/소문자를 모두 포함시키는 재귀를 작성한다.

```ts
type StringSplit<T extends string> = T extends `${infer Char}${infer Rest}`
  ? Capitalize<Char> | Uncapitalize<Char> | StringSplit<Rest>
  : never;

type Chars = StringSplit<"abcdefghijklmnopqrstuvwxyz">;
// "a" | "A" | "b" | "B" | ... | "z" | "Z"
```

이제 공백을 제거한 문자열이 `Chars` 집합 안의 문자로만 구성됐는지를 검사하는 `CreateIdentifier`를 만들 수 있다.

```ts
type CreateIdentifier<T extends string> =
  RemoveWhiteSpace<T> extends `${infer A extends Chars}${infer Rest}`
    ? `${A}${CreateIdentifier<Rest>}`
    : RemoveWhiteSpace<T> extends `${infer _}${infer Rest}`
    ? CreateIdentifier<Rest>
    : T;
```

그러나 이 버전은 `<"Hello Wor!ld!">` 같은 입력을 처리하다 보면 재귀가 깊어져 `ts(2589)` 경고가 발생한다. 재귀 호출이 매번 문자열 보간을 포함해 “꼬리 호출 최적화”가 불가능하기 때문이다.

### 누적자(accumulator)로 꼬리 호출 형태 만들기

재귀를 안전하게 유지하려면 중간 결과를 별도 매개변수에 담아 다음 호출로 전달해야 한다. 이때 도입하는 두 번째 타입 매개변수를 “누적자”라고 부른다.

```ts
type CreateIdentifier<
  T extends string,
  Acc extends string = ""
> = RemoveWhiteSpace<T> extends `${infer A extends Chars}${infer Rest}`
  ? CreateIdentifier<Rest, `${Acc}${A}`>
  : RemoveWhiteSpace<T> extends `${infer _}${infer Rest}`
  ? CreateIdentifier<Rest, Acc>
  : Acc;

type SafeIdentifier = CreateIdentifier<"Hello Wor!ld!">; // "helloWorld"
```

각 재귀 호출이 독립적으로 평가되기 때문에 컴파일러가 더 이상 깊은 재귀 경고를 내지 않는다. 모든 문자를 확인하고 나면 누적자 `Acc`에 쌓인 문자열이 최종 결과로 반환된다. 이렇게 꼬리 호출 형태로 재귀를 정리하면 템플릿 리터럴 타입으로도 꽤 복잡한 문자열 파이프라인을 안정적으로 구현할 수 있다.

## 6.6 템플릿 리터럴을 구별자로 사용하기

**문제** 백엔드 요청 상태를 pending에서 error나 success로 변경하는 상태 머신을 모델링하려 한다. 다양한 백엔드 요청에 이들 상태를 적용하면서 내부 형식은 하나로 유지해야 한다.

**해결** 문자열 템플릿 리터럴을 구별된 유니온의 구별자로 사용한다.

상태 머신에서 `state` 프로퍼티가 분기 기준이 된다면 문자열 패턴을 고정해 두는 편이 안전하다. `${Uppercase<...>}_STATUS` 형태로 정의하면 정해진 접두/접미사를 반드시 갖는 값만 허용할 수 있다. 또한 요청별 데이터를 한 곳에서 관리하도록 `keyof`와 인덱스 접근 타입을 조합한다.

```ts
type Data = {
  user: User | null;
  order: Order | null;
};

type RequestConstants = keyof Data; // 백엔드 리소스 키 집합

type Pending = { state: `${Uppercase<RequestConstants>}_PENDING` }; // 대기 상태 문자열 패턴
type Err = { state: `${Uppercase<RequestConstants>}_ERROR`; message: string }; // 오류 상태와 메시지

type Success = {
  [K in RequestConstants]: {
    state: `${Uppercase<K>}_SUCCESS`;
    data: NonNullable<Data[K]>; // 해당 리소스의 실제 데이터 타입
  };
}[RequestConstants];

type BackendRequest = Pending | Err | Success; // 상태 머신용 판별 유니온
```

이 구조를 사용하면 `switch (req.state)` 문에서 각 분기마다 정확한 데이터 타입으로 좁혀진다. 예를 들어 `case "USER_SUCCESS": login(req.data);`처럼 데이터 접근이 자연스럽다. 새로운 요청 종류를 `Data`에 추가하면 관련된 상태 문자열과 응답 타입이 동시에 확장되어 일관성을 유지할 수 있다.
