# **3. 형식 시스템**

- 타입스크립트의 목표: **자바스크립트의 유연성을 해치지 않으면서 코드 의미를 명확화**.
- 형식(타입)을 **값의 집합**으로 보는 관점이 핵심 정신모델.
- 이 장에서 다루는 것:
  - **값의 집합을 넓히거나(Union) 좁히는(Intersection) 방법**
  - **흐름 제어**에 따른 타입 좁히기
  - **구조적 타입 시스템**의 활용과 예외(규칙을 “깨야” 할 시점)
  - 실전에서 유용한: **구별된 유니온**, **exhaustive check(assertNever)**, **const 컨텍스트(as const)**

---

# **3.1 유니온/인터섹션/리터럴 타입으로 데이터 모델링하기**

## **핵심 아이디어**

- **유니온 타입(Union)**: 가능한 값의 집합을 **합집합**으로 확장
  type Toy = Doll | BoardGame | Puzzle
- **인터섹션 타입(Intersection)**: 두 타입 모두와 호환되는 값 → **교집합**으로 **좁힘**
  type BoardGame = ToyBase & { players: number }
- **리터럴 타입(Literal)**: 딱 **특정 값만** 허용하는 하위 집합
  type Material = "plush" | "plastic"

## **예시: 장난감 모델**

```tsx
type ToyBase = {
  name: string;
  price: number;
  quantity: number;
  minimumAge: number;
};

type BoardGame = ToyBase & { players: number };
type Puzzle = ToyBase & { pieces: number };
type Doll = ToyBase & { material: 'plush' | 'plastic' };

type Toy = Doll | BoardGame | Puzzle;
```

### **왜 필요한가?**

- 상위 타입(ToyBase)만 받는 함수는 **공통 속성만** 다룰 수 있어 정보 손실 발생.
- Toy를 **유니온**으로 선언하면 **구체 타입별 속성**을 안전하게 활용 가능(타입 좁히기 전제).

### **추가 메모**

- string & number 같은 **모순 교집합**은 never가 됨(값이 존재하지 않음).
- 구조적 타입 시스템에서 **하위 타입은 상위 타입 집합의 부분집합**으로 이해.

---

# **3.2 구별된 유니온(Discriminated Union)으로 명시적 모델 정의**

## **문제**

- 단순한 속성 유무 체크로는 유니온 구성요소를 **명확히 구분하기 어려움**
  (예: Triangle과 Square가 x를 공유하면 분기 실수 발생 가능)
  ```tsx
  type Circle = {
    radius: number;
  };

  type Square = {
    x: number;
  };

  type Triangle = {
    x: number;
    y: number;
  };

  type Shape = Circle | Triangle | Square;

  function area(shape: Shape) {
    if ('radius' in shape) {
      return Math.PI * shape.radius * shape.radius;
    } else if ('y' in shape) {
      return (shape.x * shape.y) / 2;
    } else {
      return shape.x * shape.x;
    }
  }
  ```

## **해결:**

## **식별자 필드**

## **추가**

- 모든 변형(variant)에 **공통의 식별 필드** kind를 **문자열 리터럴**로 부여

```tsx
type Circle = { radius: number; kind: 'circle' };
type Square = { x: number; kind: 'square' };
type Triangle = { x: number; y: number; kind: 'triangle' };

type Shape = Circle | Square | Triangle;
```

## **사용 패턴**

- switch (shape.kind)로 **안전하고 읽기 쉬운 분기**:

```tsx
function area(shape: Shape) {
  switch (shape.kind) {
    case 'circle':
      return Math.PI * shape.radius * shape.radius;
    case 'triangle':
      return (shape.x * shape.y) / 2;
    case 'square':
      return shape.x * shape.x;
    default:
      throw Error('not possible');
  }
}
```

## **장점**

- 새로운 변형(예: Rectangle) 추가 시 **컴파일 단계에서 누락된 분기**를 쉽게 발견.
- **타입 겹침 제거**로 분기 로직 단순화.

---

# **3.3. assertNever 로 완전(Exhaustive) 검사하기**

## **배경**

- 시간이 지나 유니온에 **새 변형**이 추가되면, 관련 분기를 **모두** 업데이트해야 함.
- default에서 throw만 하는 방식은 **누락을 컴파일 단계에서 강제**하지 못함.

## **패턴:**

## **assertNever**

```tsx
function assertNever(x: never): never {
  // 로깅 등
  throw new Error('Not possible');
}

type Rectangle = { x: number; y: number; kind: 'rectangle' };
type Shape = Circle | Square | Triangle | Rectangle;

function area(shape: Shape) {
  switch (shape.kind) {
    case 'circle':
      return Math.PI * shape.radius * shape.radius;
    case 'triangle':
      return (shape.x * shape.y) / 2;
    case 'square':
      return shape.x * shape.x;
    case 'rectangle':
      return shape.x * shape.y;
    default:
      // shape의 타입이 여기서 never여야 함. 아니라면 누락 분기 존재!
      return assertNever(shape);
  }
}
```

### **포인트**

- default에서 assertNever(shape) 호출 시, **컴파일러가 shape가 never임을 요구**.
  → 새 변형 추가 후 분기 누락 시 **오류로 즉시 감지**.
- never: 타입 계층의 바닥. **호환 가능한 값이 존재하지 않는 집합**.

---

# **3.4 const 컨텍스트로 리터럴 타입 고정하기**

## **문제**

- 구별된 유니온에 **객체 리터럴**을 넘길 때, kind가 그냥 string으로 **넓혀짐** → 타입 불일치.
  - const circle = { radius: 2, kind: "circle" } 는 기본적으로 { radius: number; kind: string }로 추론.

## **해결 1: 명시적 애너테이션/어서션**

```tsx
// 변수 애너테이션
const circle: Circle = { radius: 2, kind: 'circle' };

// 객체 전체에 타입 어서션
const circle2 = { radius: 2, kind: 'circle' } as Circle;
```

## **해결 2:**

## **속성 단위 리터럴 고정**

```tsx
const circle = {
  radius: 2,
  kind: 'circle' as 'circle',
};
```

## **해결 3:**

## **as const 사용 (권장)**

```tsx
// 속성만 고정
const circle = { radius: 2, kind: 'circle' as const };

// 객체 전체 고정(읽기 전용)
const circleRO = {
  radius: 2,
  kind: 'circle',
} as const;
// circleRO.kind = "rectangle"; // 오류: 읽기 전용
```

### **요점**

- as const는 **리터럴 타입을 그대로 고정**하여 **구별된 유니온과 궁합**이 좋음.
- 객체 전체에 as const를 쓰면 **읽기 전용**이 되므로 변경 의도가 있으면 **속성만 고정**하는 방식을 선택.

---

# **3.5 형식 찬반형(Type Predicate)으로 형식 좁히기**

## **문제 & 배경**
- 런타임 검증을 이미 통과했더라도, 타입 시스템은 여전히 **넓은 타입**(예: number)을 유지한다.
- 유효한 값 집합을 리터럴 유니온으로 표현할 수 있지만, **if 문 검사가 타입에 반영되지 않는** 것이 답답하다.

## **핵심 아이디어**
- 헬퍼 함수 시그니처에 **형식 찬반형(type predicate)**을 선언하여 `boolean` 대신 `value is NarrowType`을 반환한다.
- 조건식이 true일 때 전달된 값이 어떤 하위 타입인지 컴파일러에 알려줄 수 있다.

```ts
type Dice = 1 | 2 | 3 | 4 | 5 | 6;

function isDice(value: number): value is Dice {
  return [1, 2, 3, 4, 5, 6].includes(value);
}

function rollDice(input: number) {
  if (isDice(input)) {
    // 여기서 input 타입은 Dice
  } else {
    // 여기서 input 타입은 number
  }
}
```

## **사용 시 주의점**
- **더 넓은 타입으로는 좁힐 수 없다.** 매개변수 타입보다 좁은 집합만 반환 가능하다. (예: string 입력을 Dice로 지정하면 오류)
- 타입 시스템이 좁혀 준다고 해서 **런타임 검증이 올바르다는 보장이 없다.** 체크 로직이 잘못되면 (예: 범위만 비교해서 3.1415를 허용) 타입은 안전하지만 값은 잘못될 수 있다.
- `return true;`처럼 항상 참을 돌려도 타입은 좁혀지므로, **테스트로 type guard의 동작을 검증**해야 한다.

---

# **3.6 void 이해하기**

## **자바스크립트의 void**
- `void expr`는 표현식을 평가한 뒤 **항상 undefined를 반환**한다.
- 즉시 실행 함수(IIFE)나 반환값을 강제로 버리고 싶을 때 활용한다.

```ts
void function () {
  console.log('side effect only');
}();
```

## **타입스크립트의 void**
- `void`는 타입 계층에서 **undefined의 상위 집합**으로 취급된다.
- 함수가 값을 반환하지 않음을 표현하지만, 실제 자바스크립트 함수는 항상 **어떤 값(기본은 undefined)**을 반환한다.

```ts
function handler(statusCode: number, results: number[]): void {
  // 반환값을 사용하지 않음
}

function fetchResults(
  callback: (status: number, results: number[]) => void,
) {
  const didItWork = callback(200, []);
  // didItWork의 실제 값은 있지만, 타입은 여전히 undefined
}
```

## **활용 포인트**
- 콜백 시그니처가 `() => void`이면 **반환값이 있는 함수도 전달 가능**하다. (반환값이 무시되므로 void로 대체 가능)
- `void` 파라미터는 `undefined`만 받을 수 있으므로, **콜백 보안 게이트**처럼 사용할 수도 있다.
- `void`와 `undefined`는 비슷하지만, 선택적 프로퍼티처럼 다양한 맥락에서 **타입 호환성 규칙이 다르다**는 점을 기억한다.

---

# **3.7 catch 구문으로 오류 형식 처리하기**

## **왜 어려운가?**
- JavaScript에서는 **모든 값이 throw 가능**하다. (문자열, 숫자, 임의 객체…)
- `try` 하나당 `catch`가 하나뿐이므로, `catch` 매개변수 타입을 좁히기 어렵다.

## **권장 패턴**
1. `catch (e: unknown)` 또는 `catch (e: any)`로 받는다.
2. 분기 안에서 `instanceof`, `typeof`, 커스텀 type guard 등을 통해 좁힌다.

```ts
try {
  await axios.get('/resource');
} catch (e: unknown) {
  if (axios.isAxiosError(e)) {
    // AxiosError로 좁혀짐
  } else if (e instanceof TypeError) {
    // 브라우저 내장 오류
  } else if (typeof e === 'string') {
    // throw 'message'
  } else {
    // 알 수 없는 오류
  }
}
```

## **핵심 정리**
- Promise `.catch`에서도 동일하게 적용된다. (거절 이유는 어떤 타입이든 가능)
- **커스텀 오류 클래스**를 정의했다면 `instanceof`로 좁힐 수 있도록 내보내고, 라이브러리가 제공하는 type guard가 있다면 적극 활용한다.
- `catch (e: AxiosError)`처럼 **특정 타입으로 바로 애너테이션하면 오류**가 발생한다는 점을 기억한다.

---

# **3.8 선택형 never로 배타적 논리합 모델 만들기**

## **문제 상황**
- 기존 API 제약 때문에 구별 프로퍼티(kind)를 추가할 수 없을 때, **서로 겹치지 않는 유니온**을 구현하고 싶다.
- 단일 선택 vs 다중 선택을 모두 지원하는 모델에서 `value`와 `values`를 동시에 받지 않도록 강제하고자 한다.

## **해결책: 선택 프로퍼티에 never 지정**
```ts
type SelectBase = {
  options: string[];
};

type SingleSelect = SelectBase & {
  value: string;
  values?: never;
};

type MultipleSelect = SelectBase & {
  value?: never;
  values: string[];
};

type SelectProps = SingleSelect | MultipleSelect;
```

- `value`가 존재하면 `values`는 `never`이므로 **동시에 올 수 없다**.
- 반대로 `values`가 있으면 `value`가 `never`이기 때문에 역시 배타적이다.
- 기존 `selectCallback` 등은 `in` 체크로 분기하면 된다.

---

# **3.9 형식 어서션 효과적으로 사용하기**

## **언제 필요한가?**
- 타입 추론이 너무 넓을 때 (예: `Math.random()` 결과는 number지만, 실제로는 Dice 유니온), 개발자가 **더 좁은 집합임을 알고 있을 때**.

```ts
type Dice = 1 | 2 | 3 | 4 | 5 | 6;

function rollDice(): Dice {
  const num = Math.floor(Math.random() * 6) + 1;
  return num as Dice;
}
```

## **주의할 점**
- 어서션은 단순히 타입 시스템에 힌트를 주는 것이며, **값 자체는 변환되지 않는다**.
- 교집합이 존재하지 않는 타입으로 어서션하면 경고가 발생한다. (`num as unknown as string`처럼 두 번 어서션하면 우회 가능하지만 위험)
- 객체 생성 시 `{}`에 `as Person`을 붙이고 나중에 프로퍼티를 채우는 패턴은 **필드 추가 시 누락을 놓칠 수 있다.** 가능하면 애너테이션이나 팩토리 함수로 안전하게 작성한다.

```ts
type Person = {
  name: string;
  age: number;
  profession: string;
};

function createPerson(name: string): Person {
  return {
    name,
    age: Math.floor(Math.random() * 95),
    profession: 'unknown',
  };
}
```

## **비동기 데이터와 어서션**
- `fetch`처럼 결과 타입이 `any`인 API는 **어서션이 불가피**한 경우가 많다.
- `as Person[]`을 명시해 두면, 백엔드 모델이 바뀌었을 때 **코드 상단에서 위험 지점을 빠르게 찾을 수 있다.**

---

# **3.10 인덱스 시그니처 사용하기**

## **문제**
- 키 집합은 열려 있지만, **값의 모양은 일정한 객체 컬렉션**을 다루고 싶다.

```ts
type Metrics = {
  ttfb: number;
  fcp: number;
  si: number;
  lcp: number;
  tti: number;
  tbt: number;
};

type MetricCollection = {
  [domain: string]: Metrics | undefined;
};
```

## **활용 예시**
- `keyof Metrics`로 메트릭 이름을 안전하게 전달하고, 루프에서 `collection[domain]`을 읽으면 `Metrics | undefined` 타입이 나온다.
- 값이 없을 수 있으므로 `if (timing && timing[key] < result.value)`처럼 **undefined 체크**가 필요하다.
- Optional 체이닝(`?.`)이나 null 병합(`??`)을 조합하면 런타임 안정성이 올라간다.

## **추가 개념**
- **매핑된 타입(mapped type)**을 사용하면 “키의 하위 집합”을 선언할 수 있다.
- 인덱스 시그니처에 다른 프로퍼티를 추가하려면, 그 프로퍼티 역시 인덱스 시그니처 타입의 부분집합이어야 한다.

---

# **3.11 빠진 프로퍼티와 undefined 구별하기**

## **상황**
- 선택 프로퍼티는 존재하지 않을 수도 있고, 명시적으로 `undefined`일 수도 있다. 이 둘은 **런타임 의미가 다르다.**

```ts
type Settings = {
  language: 'en' | 'de' | 'fr';
  theme?: 'dracula' | 'monokai' | 'github';
};
```

- `in` 연산자는 프로퍼티 존재 여부만 확인하므로, `theme`가 `undefined`로 설정된 경우 true를 반환하지 않는다.
- `settings.theme ?? 'default'`처럼 **null 병합 연산자**를 사용하면 두 경우를 모두 처리할 수 있다.

## **exactOptionalPropertyTypes 옵션**
- `tsconfig.json`에서 `exactOptionalPropertyTypes: true`로 설정하면, 선택 프로퍼티에 `undefined`를 직접 대입할 수 없다.
- 즉, “프로퍼티가 없을 수도 있다”와 “프로퍼티가 있는데 값이 undefined다”를 엄격히 구분하여 **모호한 버그를 줄일 수 있다.**

---

# **3.12 열거형 사용하기**

## **기본 개념**
- `enum`은 값과 타입 네임스페이스를 동시에 생성한다. (런타임에도 객체가 생김)
- `const enum`을 쓰면 컴파일 단계에서 값이 인라인되어 **추가 코드가 생성되지 않는다.**

```ts
const enum Direction {
  Up,
  Down,
  Left,
  Right,
}

function move(dir: Direction) {}
move(Direction.Up); // 컴파일 시 move(0 /* Direction.Up */)로 치환
```

## **숫자 vs 문자열 enum**
- 숫자 enum은 기본적으로 0부터 시작하며, 값이 넓게 허용되어 플래그를 만들 때 편리하지만 **예상치 못한 값도 들어올 수 있다**는 점을 고려해야 한다. (TS 5.0 이후 더 엄격해짐)
- 문자열 enum은 선언한 문자열만 허용한다. 대신 서로 값이 같아도 **명목상 타입**이라 다른 enum과 호환되지 않는다.

## **대안: 리터럴 유니온 + const 객체**
- 많은 경우 `as const` 객체와 `keyof typeof` 패턴이 더 직관적이고 트리 셰이크에도 유리하다.

```ts
const Direction = {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
} as const;

type Direction = (typeof Direction)[keyof typeof Direction];
```

- 또는 단순히 `type Status = 'Admin' | 'User' | 'Moderator';`처럼 문자열 유니온으로 표현하는 것도 좋은 선택이다.

---

# **3.13 구조적 타입 시스템에 명목상 타입 정의하기**

## **필요성**
- 타입스크립트는 구조적 타입 시스템이라 **모양이 같으면 같은 타입**으로 취급한다. 하지만 의미적으로 다른 값(계좌번호 vs 잔고)을 혼동하고 싶지 않을 수 있다.

## **접근법 1: 래퍼 클래스 + private 필드**
```ts
class Balance {
  private _nominal: void = undefined;
  constructor(public value: number) {}
}

class AccountNumber {
  private _nominal: void = undefined;
  constructor(public value: number) {}
}
```

- `private` 멤버가 존재하면 동일한 선언을 공유할 때만 호환되므로, **의미가 다른 값이 섞이지 않는다.**
- 단점은 값을 사용하려면 항상 `.value`를 꺼내야 한다는 것.

## **접근법 2: 브랜딩(branding) 타입**
```ts
type Credits = number & { _kind: 'credits' };
type AccountNumber = number & { _kind: 'accountNumber' };

const account = 12345678 as AccountNumber;
let balance = 10_000 as Credits;
```

- 인터섹션으로 “기본 타입 + 브랜드”를 만들고, 필요한 지점에서 `as`로 어서션한다.
- 산술 연산 후에는 다시 해당 브랜드로 어서션해야 한다는 점을 유의한다.

---

# **3.14 문자열 하위 집합의 느슨한 자동완성 활성화하기**

## **상황**
- API는 임의의 문자열을 받아야 하지만, 몇 가지 **대표 옵션을 자동완성**으로 제시하고 싶다.

## **기술**
```ts
type ContentType = 'post' | 'page' | 'asset' | (string & {});

function retrieve(content: ContentType) {
  // ...
}
```

- `string & {}`는 실제 값 집합을 바꾸지 않고, 타입스크립트가 리터럴 유니온을 일반 string으로 **넓히는 것을 막아준다.**
- 따라서 API 사용자에게 `post`, `page`, `asset` 제안을 제공하면서도 여전히 **커스텀 문자열을 허용**할 수 있다.

---

> 위 내용은 장의 후반부를 더 촘촘히 정리한 것으로, 필요 시 원문 코드와 함께 참고하면 학습에 도움이 된다.
