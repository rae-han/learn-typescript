# **3. 형식 시스템**

- 타입스크립트의 목표: **자바스크립트의 유연성을 해치지 않으면서 코드 의미를 명확화**.
- 형식(타입)을 **값의 집합**으로 보는 관점이 핵심 정신모델.
- 이 장에서 다루는 것:
  - **값의 집합을 넓히거나(Union) 좁히는(Intersection) 방법**
  - **흐름 제어**에 따른 타입 좁히기
  - **구조적 타입 시스템**의 활용과 예외(규칙을 “깨야” 할 시점)
  - 실전에서 유용한: **구별된 유니온**, **exhaustive check(assertNever)**, **const 컨텍스트(as const)**

---

# **3.1 유니온/인터섹션/리터럴 타입으로 데이터 모델링하기**

## **핵심 아이디어**

- **유니온 타입(Union)**: 가능한 값의 집합을 **합집합**으로 확장
  type Toy = Doll | BoardGame | Puzzle
- **인터섹션 타입(Intersection)**: 두 타입 모두와 호환되는 값 → **교집합**으로 **좁힘**
  type BoardGame = ToyBase & { players: number }
- **리터럴 타입(Literal)**: 딱 **특정 값만** 허용하는 하위 집합
  type Material = "plush" | "plastic"

## **예시: 장난감 모델**

```tsx
type ToyBase = {
  name: string;
  price: number;
  quantity: number;
  minimumAge: number;
};

type BoardGame = ToyBase & { players: number };
type Puzzle = ToyBase & { pieces: number };
type Doll = ToyBase & { material: 'plush' | 'plastic' };

type Toy = Doll | BoardGame | Puzzle;
```

### **왜 필요한가?**

- 상위 타입(ToyBase)만 받는 함수는 **공통 속성만** 다룰 수 있어 정보 손실 발생.
- Toy를 **유니온**으로 선언하면 **구체 타입별 속성**을 안전하게 활용 가능(타입 좁히기 전제).

### **추가 메모**

- string & number 같은 **모순 교집합**은 never가 됨(값이 존재하지 않음).
- 구조적 타입 시스템에서 **하위 타입은 상위 타입 집합의 부분집합**으로 이해.

---

# **3.2 구별된 유니온(Discriminated Union)으로 명시적 모델 정의**

## **문제**

- 단순한 속성 유무 체크로는 유니온 구성요소를 **명확히 구분하기 어려움**
  (예: Triangle과 Square가 x를 공유하면 분기 실수 발생 가능)
  ```tsx
  type Circle = {
    radius: number;
  };

  type Square = {
    x: number;
  };

  type Triangle = {
    x: number;
    y: number;
  };

  type Shape = Circle | Triangle | Square;

  function area(shape: Shape) {
    if ('radius' in shape) {
      return Math.PI * shape.radius * shape.radius;
    } else if ('y' in shape) {
      return (shape.x * shape.y) / 2;
    } else {
      return shape.x * shape.x;
    }
  }
  ```

## **해결:**

## **식별자 필드**

## **추가**

- 모든 변형(variant)에 **공통의 식별 필드** kind를 **문자열 리터럴**로 부여

```tsx
type Circle = { radius: number; kind: 'circle' };
type Square = { x: number; kind: 'square' };
type Triangle = { x: number; y: number; kind: 'triangle' };

type Shape = Circle | Square | Triangle;
```

## **사용 패턴**

- switch (shape.kind)로 **안전하고 읽기 쉬운 분기**:

```tsx
function area(shape: Shape) {
  switch (shape.kind) {
    case 'circle':
      return Math.PI * shape.radius * shape.radius;
    case 'triangle':
      return (shape.x * shape.y) / 2;
    case 'square':
      return shape.x * shape.x;
    default:
      throw Error('not possible');
  }
}
```

## **장점**

- 새로운 변형(예: Rectangle) 추가 시 **컴파일 단계에서 누락된 분기**를 쉽게 발견.
- **타입 겹침 제거**로 분기 로직 단순화.

---

# **3.3. assertNever 로 완전(Exhaustive) 검사하기**

## **배경**

- 시간이 지나 유니온에 **새 변형**이 추가되면, 관련 분기를 **모두** 업데이트해야 함.
- default에서 throw만 하는 방식은 **누락을 컴파일 단계에서 강제**하지 못함.

## **패턴:**

## **assertNever**

```tsx
function assertNever(x: never): never {
  // 로깅 등
  throw new Error('Not possible');
}

type Rectangle = { x: number; y: number; kind: 'rectangle' };
type Shape = Circle | Square | Triangle | Rectangle;

function area(shape: Shape) {
  switch (shape.kind) {
    case 'circle':
      return Math.PI * shape.radius * shape.radius;
    case 'triangle':
      return (shape.x * shape.y) / 2;
    case 'square':
      return shape.x * shape.x;
    case 'rectangle':
      return shape.x * shape.y;
    default:
      // shape의 타입이 여기서 never여야 함. 아니라면 누락 분기 존재!
      return assertNever(shape);
  }
}
```

### **포인트**

- default에서 assertNever(shape) 호출 시, **컴파일러가 shape가 never임을 요구**.
  → 새 변형 추가 후 분기 누락 시 **오류로 즉시 감지**.
- never: 타입 계층의 바닥. **호환 가능한 값이 존재하지 않는 집합**.

---

# **3.4 const 컨텍스트로 리터럴 타입 고정하기**

## **문제**

- 구별된 유니온에 **객체 리터럴**을 넘길 때, kind가 그냥 string으로 **넓혀짐** → 타입 불일치.
  - const circle = { radius: 2, kind: "circle" } 는 기본적으로 { radius: number; kind: string }로 추론.

## **해결 1: 명시적 애너테이션/어서션**

```tsx
// 변수 애너테이션
const circle: Circle = { radius: 2, kind: 'circle' };

// 객체 전체에 타입 어서션
const circle2 = { radius: 2, kind: 'circle' } as Circle;
```

## **해결 2:**

## **속성 단위 리터럴 고정**

```tsx
const circle = {
  radius: 2,
  kind: 'circle' as 'circle',
};
```

## **해결 3:**

## **as const 사용 (권장)**

```tsx
// 속성만 고정
const circle = { radius: 2, kind: 'circle' as const };

// 객체 전체 고정(읽기 전용)
const circleRO = {
  radius: 2,
  kind: 'circle',
} as const;
// circleRO.kind = "rectangle"; // 오류: 읽기 전용
```

### **요점**

- as const는 **리터럴 타입을 그대로 고정**하여 **구별된 유니온과 궁합**이 좋음.
- 객체 전체에 as const를 쓰면 **읽기 전용**이 되므로 변경 의도가 있으면 **속성만 고정**하는 방식을 선택.

---
