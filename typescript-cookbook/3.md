# 3장 형식 시스템

## 3.1 유니온과 인터섹션으로 데이터 모델링하기
**문제** 도메인 객체가 여러 형태를 가질 수 있어 명확한 타입 정의가 어렵다.

**해결** 유니온과 인터섹션을 이용해 가능한 모양을 모두 선언하고, 필요하면 공통 속성을 묶는다.

`type`을 이용하면 여러 구조를 하나의 타입으로 통합하거나 공통 속성을 공유하는 교차 타입을 만들 수 있다. 이렇게 모델을 명시하면 제어 흐름에서 안전하게 분기할 수 있다.

```ts
type ToyBase = {
  name: string;
  price: number;
};

type Puzzle = ToyBase & { pieces: number };
type Doll = ToyBase & { material: "plush" | "plastic" };
type Toy = Puzzle | Doll;

function describeToy(toy: Toy) {
  if ("pieces" in toy) {
    console.log(`${toy.name} 퍼즐`, toy.pieces);
  } else {
    console.log(`${toy.name} 인형`, toy.material);
  }
}
```

유니온·인터섹션 조합을 설계할 때는 다음 순서를 따르자.

1. **공통 속성 추출**: `ToyBase`처럼 모든 항목이 공유하는 필드를 먼저 정리한다. 중복을 줄이고, 공통 로직에서 사용할 수 있는 속성 집합을 명확히 한다.
2. **특화 타입 정의**: 카테고리별로 추가되는 속성을 별도 타입으로 분리하고, `ToyBase & { ... }` 형태로 교차시킨다. 이렇게 하면 기본 속성을 자동으로 상속받는다.
3. **유니온으로 통합**: `type Toy = Puzzle | Doll;`처럼 가능한 경우를 나열한다. IDE는 해당 유니온을 기반으로 자동 완성 목록을 좁혀 준다.
4. **제어 흐름으로 좁히기**: `if ("pieces" in toy)`나 `if (toy.material === "plush")`처럼 런타임 체크를 통해 타입을 좁힌다. 타입스크립트는 이러한 조건문을 이해하고 이후 분기에서 타입을 고정한다.

이 모델링 방식은 데이터가 늘어나도 타입 정의가 명확히 확장되므로, 도메인 로직을 안전하게 유지할 수 있다.

## 3.2 구별된 유니온으로 모델 명시하기
**문제** 유니온 멤버가 비슷한 속성을 공유해 분기 코드가 복잡해진다.

**해결** 멤버마다 `kind` 같은 리터럴 속성을 추가해 구별된(discriminated) 유니온을 만든다.

구별된 유니온은 `switch`나 연속된 `if`에서 안전하게 분기할 수 있으며, 새로운 멤버를 추가해도 기존 코드가 쉽게 적응한다.

```ts
type Circle = { kind: "circle"; radius: number };
type Square = { kind: "square"; size: number };
type Triangle = { kind: "triangle"; width: number; height: number };

type Shape = Circle | Square | Triangle;

function area(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.size ** 2;
    case "triangle":
      return (shape.width * shape.height) / 2;
  }
}
```

구별된 유니온을 구축할 때 기억할 점:

- **리터럴 속성 추가**: `kind`처럼 모든 멤버에 공통으로 존재하지만 값은 서로 다른 리터럴이 되도록 한다. 이름이 달라도 상관없지만, 일관된 명명 규칙(`type`, `variant`, `state` 등)을 유지하면 가독성이 높아진다.
- **`switch`를 기본 분기 도구로 사용**: `switch (shape.kind)`는 각 분기마다 타입을 자동으로 좁혀 준다. 모든 케이스를 다루지 않으면 컴파일러가 경고할 수 있도록 `assertNever` 패턴(3.3절)을 같이 사용한다.
- **새 멤버 추가 시 영향도**: 유니온에 새로운 도형을 추가하면 컴파일러가 `switch` 문에서 빠진 분기를 지적한다. 덕분에 런타임 버그 없이 안전하게 확장할 수 있다.
- **리터럴 유니온 재활용**: `type ShapeKind = Shape["kind"];`처럼 구별자 값만 뽑아 다른 함수(예: 메뉴 표시)에서도 재사용할 수 있다.

이 패턴은 네트워크 응답, 상태 머신, 이벤트 타입 등 “케이스별로 구분되는 데이터”를 표현할 때 특히 효과적이다.


## 3.3 assertNever로 완전 검사하기
**문제** 구별된 유니온에 새 멤버가 추가되면 `switch` 문을 빠뜨리기 쉽다.

**해결** `assertNever` 헬퍼를 만들어 디폴트 분기에서 호출하면 빠진 케이스가 있을 때 컴파일 오류를 발생시킨다.

```ts
function assertNever(x: never): never {
  throw new Error(`예상하지 못한 값: ${x}`);
}

function render(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return `원 (${shape.radius})`;
    case "square":
      return `정사각형 (${shape.size})`;
    case "triangle":
      return `삼각형 (${shape.width}x${shape.height})`;
    default:
      return assertNever(shape); // 새로운 멤버 누락 시 오류 발생
  }
}
```

`assertNever`는 타입 안전성과 리팩터링 체감을 크게 높여 준다.

- 기본적으로 `never` 타입은 “발생할 수 없는 값”을 의미한다. 모든 분기를 처리하면 `shape`의 타입이 `never`로 좁혀져야 하므로, 그렇지 않은 경우 컴파일러가 오류를 보고한다.
- `default` 분기에만 `assertNever`를 호출하고, 함수는 `never`를 반환하도록 만든다. 이렇게 하면 실수로 `return undefined;` 같은 코드를 작성해도 즉시 경고를 받는다.
- 새로운 멤버가 추가되었는데 `switch` 문을 업데이트하지 않으면, `assertNever` 호출에서 “`Shape` 타입은 `circle | square | triangle | newShape`인데 `never`과 호환되지 않는다”는 오류가 발생한다.
- 동일한 헬퍼를 다른 구별된 유니온에도 재사용할 수 있다. 제네릭으로 확장하려면 `function assertNever(x: never): never { ... }`처럼 선언만 해 두면 된다.

이 패턴은 테스트에서 놓치기 쉬운 “분기 누락”을 컴파일 단계에서 차단하는 대표적인 기법이다.


## 3.4 const 컨텍스트로 형식 고정하기
**문제** 객체 리터럴이 넓은 타입으로 추론돼 의도한 리터럴 값을 잃는다.

**해결** `as const`나 `const` 컨텍스트를 사용해 값을 리터럴 타입으로 고정한다.

```ts
const STATUS = {
  READY: "ready",
  RUNNING: "running",
  DONE: "done"
} as const; // 값과 타입이 모두 상수로 고정됨

type Status = typeof STATUS[keyof typeof STATUS];

function setStatus(status: Status) {
  console.log(status);
}

setStatus(STATUS.READY);
// setStatus("READY"); // 오류: 대소문자까지 체크
```

`as const` 컨텍스트는 다음과 같은 효과를 제공한다.

- **값과 타입 동시 고정**: 객체의 각 프로퍼티가 리터럴 타입으로 변환되고, 프로퍼티도 `readonly`가 된다. 배열에 적용하면 튜플처럼 각 요소가 고정된다.
- **상수 사전 패턴**: `typeof STATUS[keyof typeof STATUS]` 패턴은 상수 객체에서 가능한 값 집합을 추출하는 표준적인 방식이다. 상수 목록을 한 곳에서 유지하면서 타입도 자동으로 업데이트된다.
- **`satisfies`와 조합**: TypeScript 4.9 이상에서는 `const STATUS = { ... } as const satisfies Record<string, string>;`처럼 작성해 구조를 검증하면서도 리터럴 타입을 유지할 수 있다.
- **API 계약 고정**: REST 엔드포인트, 상태 머신, Redux 액션 타입 등 재사용되는 문자열을 상수 객체로 정의하면 오탈자를 줄이고 자동 완성도 강화된다.

리터럴 값이 의도치 않게 넓은 문자열 타입으로 추론되는 문제를 예방하고 싶다면 항상 `as const` 사용 여부를 검토하자.


## 3.5 형식 찬반 함수로 형식 좁히기
**문제** 복잡한 조건으로 타입을 좁히는 코드가 반복된다.

**해결** 사용자 정의 타입 가드(`value is Type`)를 만들어 재사용한다.

```ts
type ApiError = { status: number; message: string };

type Result<T> = T | ApiError;

function isApiError(result: unknown): result is ApiError {
  return (
    typeof result === "object" &&
    !!result &&
    "status" in result &&
    typeof (result as any).status === "number"
  );
}

function handle<T>(result: Result<T>) {
  if (isApiError(result)) {
    console.error(result.status, result.message);
    return;
  }
  console.log("성공", result);
}
```

타입 가드를 설계할 때는 다음 원칙을 지키면 좋다.

- **반드시 불리언 반환**: 시그니처에 `result is ApiError`를 명시하면, 함수 본문은 `true`/`false`를 반환해야 한다. `if (isApiError(result))` 이후 분기에서는 자동으로 `ApiError`로 좁혀진다.
- **런타임 검증 포함**: `typeof`, `Array.isArray`, `in` 연산자 등을 활용해 런타임에서도 실제 구조가 맞는지 확인한다. 단순히 `return true as boolean`처럼 형식만 속이면 아무 의미가 없다.
- **재사용 가능한 함수로 추출**: 여러 위치에서 동일한 검증을 반복한다면 별도의 타입 가드로 묶는다. 테스트를 작성해 허용/거부 케이스를 검증하면 신뢰도가 높아진다.
- **`unknown`과 함께 사용**: API 응답이나 JSON 파싱 결과처럼 타입을 알 수 없는 값은 `unknown`으로 받고, 타입 가드에서 원하는 도메인 타입으로 좁힌다. 이렇게 하면 `any` 없이도 타입 안전성을 유지할 수 있다.

타입 가드는 제어 흐름 기반 타입 좁히기를 사용자 정의 로직으로 확장하는 핵심 도구다.


## 3.6 void 이해하기
**문제** `void`와 `undefined`를 혼동해 함수 반환 타입을 잘못 지정한다.

**해결** `void`는 “반환값을 사용하지 않는다”는 의미이며, 호출자가 값을 기대하지 않을 때 사용한다. 내부에서는 `return;` 또는 `return undefined;`가 허용되지만, 반환값을 체이닝하면 안 된다.

```ts
function log(message: string): void {
  console.log(message);
  return; // 반환값을 명시하지 않음
}

const value = log("완료");
// value.toString(); // 오류: void에는 속성이 없음
```

`void`를 사용할 때 주의할 점:

- 함수 선언에서 `: void`를 지정하면 호출부가 반환값을 사용하지 않는다는 계약을 의미한다. 내부에서 `return "value";`처럼 값을 반환하더라도 컴파일러는 허용하지만, 호출자는 그 값을 쓸 수 없다.
- 콜백 함수(예: `Array.prototype.forEach`)의 인수 타입에도 자주 등장한다. `forEach`는 콜백의 반환값을 무시하므로, 콜백에서 값을 반환하더라도 의미가 없다.
- `Promise<void>`는 “비동기 작업이 완료되었지만 결과값은 없다”는 뜻이다. `Promise<undefined>`와 엄밀히 동일한 것은 아니지만, 실무에서는 결과를 사용하지 않는 비동기 API에 관용적으로 사용한다.
- `--noImplicitReturns`와 함께 사용하면 모든 코드 경로에서 `return` 문이 존재하는지 확인할 수 있다. 의도치 않은 `undefined` 반환을 막고 싶을 때 유용하다.


## 3.7 catch 구문으로 오류 형식 처리하기
**문제** `catch (error)`로 잡은 값이 암묵적 `any`라 안전하게 다루기 어렵다.

**해결** `--useUnknownInCatchVariables` 또는 기본 설정을 이용해 `error`를 `unknown`으로 취급하고, 타입 가드나 `instanceof`로 좁힌다.

```ts
try {
  JSON.parse("invalid");
} catch (error) {
  if (error instanceof SyntaxError) {
    console.error("JSON 파싱 실패", error.message);
  } else {
    console.error("알 수 없는 오류", error);
  }
}
```

ES2022부터 타입스크립트는 기본적으로 `catch` 변수의 타입을 `unknown`으로 간주한다(`useUnknownInCatchVariables` 옵션). 안전하게 다루려면 다음과 같은 패턴을 활용한다.

- `instanceof`로 표준 오류 타입을 판별한다. `SyntaxError`, `TypeError`, `DOMException` 등 내장 오류는 런타임 클래스이므로 `instanceof`가 잘 동작한다.
- 커스텀 오류를 사용할 경우 `class AppError extends Error { ... }`처럼 정의한 뒤 `error instanceof AppError`로 좁힌다.
- 예상치 못한 값(예: 문자열, 숫자)이 들어올 수 있으므로 마지막 `else` 분기에서는 로그만 남기고 다시 던지거나 기본 메시지를 출력한다.
- 반복되는 에러 핸들링 로직은 헬퍼 함수로 추출하고, 반환 타입을 `error is AppError` 형태로 지정하면 호출처에서 안전하게 처리할 수 있다.

이렇게 하면 `any`로 다운캐스팅하지 않고도 다양한 오류 시나리오를 엄격하게 모델링할 수 있다.


## 3.8 선택형 never로 배타적 논리 만들기
**문제** 두 속성 중 하나만 설정되어야 하는 객체를 표현하기 어렵다.

**해결** 각 경우에 허용되지 않는 속성에는 `never`를 부여해 상호 배타적인 타입을 구성한다.

```ts
type WithId = { id: string; slug?: never };
type WithSlug = { slug: string; id?: never };

type RouteRef = WithId | WithSlug;

const byId: RouteRef = { id: "123" };
const bySlug: RouteRef = { slug: "main" };
// const invalid: RouteRef = { id: "1", slug: "dup" }; // 오류: never 충돌
```

선택형 `never` 패턴의 요점은 “허용되지 않는 속성을 명시적으로 막는 것”이다.

- `slug?: never`는 `slug`가 존재하면 안 된다는 뜻이다. 존재하더라도 타입이 `never`여서 어떤 값도 할당할 수 없다.
- 반대로 `slug`만 허용하는 케이스에서는 `id?: never`로 막는다. 이렇게 하면 두 속성이 동시에 존재하는 잘못된 객체를 컴파일 단계에서 차단할 수 있다.
- 이 패턴은 Form 입력에서 “파일 업로드 vs URL 입력”처럼 상호 배타적인 옵션을 모델링할 때 유용하다. 각 경우 별로 허용되는 필드를 명확히 해 두면 런타임 검증 코드가 간결해진다.
- 타입 정의가 복잡해지면 `type RouteRef = ({ id: string; slug?: never } | { slug: string; id?: never }) & { locale?: string };`처럼 공통 속성을 교차 타입으로 묶어 재사용할 수도 있다.


## 3.9 형식 어서션 효과적으로 사용하기
**문제** 타입스크립트가 알 수 없는 값에 안전하게 접근해야 한다.

**해결** 실제로 값이 존재함을 확신할 때만 `as`를 사용하고, 가능하면 타입 가드나 런타임 검사를 먼저 수행한다.

```ts
const el = document.querySelector("#submit");

if (!(el instanceof HTMLButtonElement)) {
  throw new Error("버튼을 찾을 수 없습니다.");
}

el.addEventListener("click", () => {
  // 여기서는 버튼임을 보장
});
```

형식 어서션(`as`)은 강력하지만 다음 원칙을 반드시 지켜야 한다.

- **검증 선행**: 런타임 체크(`instanceof`, 속성 존재 여부 등`) 후에 어서션을 적용한다. 검증 없이 `as HTMLButtonElement`로 단언하면 타입스크립트가 더 이상 보호해 주지 않는다.
- **좁은 범위 적용**: 필요한 최소 범위(예: if 블록 내부)에서만 어서션을 사용하고, 외부로 넓히지 않는다. 그렇게 하면 잠재적 오류가 국소화된다.
- **동일한 값에 두 번 어서션 금지**: `value as unknown as Foo`같은 이중 어서션은 타입 시스템을 완전히 무시하므로 지양한다. 정말 필요하다면 안전한 유틸리티 함수를 작성하거나 타입 설계를 재검토한다.
- **대안 고려**: `document.querySelector<HTMLButtonElement>("#submit")`처럼 제네릭 인수를 받을 수 있는 API를 활용하면 어서션 없이도 원하는 타입을 얻을 수 있다. 또는 타입 가드를 작성해 재사용한다.

이 방식으로 어서션을 절제하면 타입 시스템과 런타임 안전성을 모두 확보할 수 있다.


## 3.10 인덱스 시그니처 사용하기
**문제** 키가 동적으로 늘어나는 객체를 타이핑하기 어렵다.

**해결** 인덱스 시그니처(`[key: string]: Type`)를 사용하되, 구체적인 속성 정의와 함께 쓰면 더욱 안전하다.

```ts
type Settings = {
  theme: "dark" | "light";
  [key: string]: string | number | boolean; // 추가 설정 허용
};

const config: Settings = {
  theme: "dark",
  retries: 3,
  beta: true
};
```

인덱스 시그니처를 사용할 때 유의할 점:

- 구체적인 프로퍼티(`theme`)는 먼저 선언해 두고, 마지막에 인덱스 시그니처를 추가한다. 이렇게 하면 `theme`가 `string | number | boolean`으로 넓어지지 않고, 정확한 리터럴 유니온을 유지한다.
- 값 타입을 넓게 잡을수록 검증이 느슨해진다. 가능하다면 `type SettingsValue = string | number | boolean;`처럼 별칭을 선언해 재사용하고, 필요한 경우 `value is string` 같은 타입 가드로 좁힌다.
- 인덱스 시그니처는 객체의 키를 모두 같은 타입으로 취급한다. 서로 다른 타입을 갖는 키가 많다면 `Record<string, T>`나 매핑 타입을 이용해 구체적으로 선언하는 편이 낫다.
- `noUncheckedIndexedAccess` 옵션을 켜면 인덱스 시그니처를 통해 접근할 때 `undefined` 가능성이 자동으로 포함된다. 런타임 존재 여부를 체크해야 하는 상황에서 유용하다.

## 3.11 빠진 프로퍼티와 undefined 구별하기
**문제** 선택 속성이 존재하지 않는 것인지 `undefined`인지 구분하고 싶다.

**해결** `in` 연산자나 `Partial`, `Required` 같은 유틸리티 타입을 활용해 존재 여부를 먼저 확인한다. `exactOptionalPropertyTypes`를 활성화하면 `undefined`를 명시적으로 다룰 수 있다.

```ts
interface Profile {
  name: string;
  nickname?: string; // 있을 수도 있고 없을 수도 있음
}

function printNickname(profile: Profile) {
  if ("nickname" in profile) {
   console.log(profile.nickname ?? "(비공개)");
  } else {
    console.log("(미입력)");
  }
}
```

선택 속성을 다룰 때는 다음 기법을 조합하면 좋다.

- `in` 연산자는 객체에 속성이 실제로 존재하는지 확인한다. 선택 속성이 `undefined`로 설정된 경우에도 `true`를 반환하므로, 값이 `undefined`인지 여부는 `profile.nickname ?? "(비공개)"`처럼 별도로 처리한다.
- `exactOptionalPropertyTypes` 옵션을 켜면 `nickname?: string`과 `nickname?: string | undefined`의 동작 차이가 생긴다. 전자는 “속성이 없거나 문자열”, 후자는 “속성이 있고 문자열 또는 undefined”를 의미한다.
- `Partial<Profile>`은 모든 속성을 선택형으로 바꾸고, `Required<Profile>`은 다시 필수로 돌려놓는다. 이러한 유틸리티 타입을 이용해 업데이트 DTO나 폼 입력 타입을 쉽게 만들 수 있다.
- API 응답을 다룰 때는 “속성이 아예 빠진 경우”와 “속성이 존재하지만 값이 null/undefined인 경우”를 구분해야 한다. 각각의 의미가 다르므로 타입 정의에서 명확히 표현한다.

## 3.12 열거형 사용하기
**문제** 여러 상수를 하나의 타입으로 묶고 싶다.

**해결** `enum`이나 리터럴 유니온을 사용해 의미 있는 상수 집합을 만든다. `const enum`은 빌드 시 값으로 인라인된다.

```ts
enum Step {
  Idle,
  Running,
  Done
}

function next(step: Step) {
  switch (step) {
    case Step.Idle:
      return Step.Running;
    case Step.Running:
      return Step.Done;
    case Step.Done:
      return Step.Done;
  }
}
```

열거형을 사용할 때 고려할 사항:

- `enum`은 런타임 객체이기도 하다. 따라서 `Step.Idle` 값은 숫자 `0`이지만, 타입스크립트는 `Step` 타입으로 인식한다. 이중 매핑(`Step[0] === "Idle"`)도 생성되므로 디버깅에 유용하다.
- `const enum`을 선언하면 컴파일 시 값이 인라인되어 런타임 객체가 생성되지 않는다. 대신 디버깅 시 이름이 사라지니, 라이브러리보다는 애플리케이션 코드에 적합하다.
- 리터럴 유니온(`type Step = "Idle" | "Running" | "Done";`)도 동일한 목적을 달성할 수 있다. 트리쉐이킹이나 번들 크기가 중요하다면 리터럴 유니온이 가벼운 선택이다.
- 혼합 사용도 가능하다. `enum Step { Idle = "Idle", Running = "Running", Done = "Done" }`처럼 문자열 enum을 정의하면 직렬화·로그 출력 시 값이 더 명확해진다.

프로젝트 규칙에 맞춰 `enum`과 리터럴 유니온 중 하나를 선택하고, 일관되게 사용하는 것이 중요하다.


## 3.13 구조적 시스템에 명목형 추가하기
**문제** 구조적 타이핑 때문에 서로 다른 식별자가 혼동된다.

**해결** `brand` 프로퍼티를 추가해 명목형처럼 취급하도록 만든다.

```ts
type Brand<K, T> = T & { readonly __brand: K };

type UserId = Brand<"UserId", string>;

enum Prefix {
  User = "user_"
}

function makeUserId(raw: string): UserId {
  return (Prefix.User + raw) as UserId;
}

function loadUser(id: UserId) {
  console.log("load", id);
}

const id = makeUserId("123");
loadUser(id);
// loadUser("user_123"); // 오류: 브랜드가 다름
```

브랜딩 패턴은 구조적 타입 시스템에 “명목형 제약”을 추가하는 대표적인 방법이다.

- `Brand<K, T>`는 실제 값은 `T`이지만, `__brand`라는 `readonly` 프로퍼티 덕분에 동일한 구조라도 다른 브랜드를 가진 값과 호환되지 않는다.
- 사용자에게 브랜드 프로퍼티를 직접 수정할 수 없도록 `readonly`로 선언하고, 함수 내부에서만 브랜드를 부여한다. 이렇게 하면 잘못된 문자열이 API 경계로 들어오는 것을 막을 수 있다.
- 복수의 브랜드를 더하고 싶다면 `Brand<"UserId", string> & Brand<"OrderId", string>`처럼 교차 타입을 만들거나, `type Brand<K, T> = T & { __brand: K };`를 중첩해 사용한다.
- 런타임에는 브랜드 프로퍼티가 존재하지만, 외부로 노출할 필요가 없다면 `interface` 대신 `type`과 `unique symbol`을 조합해 `declare const UserIdBrand: unique symbol; type UserId = string & { [UserIdBrand]: true };` 방식으로 숨길 수도 있다.

이 기법은 데이터베이스 ID, 통화 단위, 단위가 다른 수치값 등을 혼동 없이 처리하는 데 큰 도움이 된다.


## 3.14 문자열 하위 집합의 느슨한 자동 완성 활성화하기
**문제** 문자열 리터럴 유니온이 자동 완성에 유리하지만 새로운 값 추가가 번거롭다.

**해결** 상수 배열과 `satisfies`를 이용해 값 목록을 유지하면서, 타입은 배열에서 자동으로 생성한다.

```ts
const STATUSES = ["pending", "running", "done"] as const;
type Status = (typeof STATUSES)[number];

const current: Status = "pending";
const next: Status = "running";
// const invalid: Status = "idle"; // 오류: 리스트 밖
```

리터럴 배열과 `as const`를 조합하면 “값 목록과 타입 정의를 한 곳에서 관리”할 수 있다.

- `const STATUSES = [...] as const`는 배열 요소를 리터럴 타입으로 고정한다. 이후 `(typeof STATUSES)[number]` 패턴으로 가능한 값 집합을 추출한다.
- 값 목록을 검증하고 싶다면 `const STATUSES = ["pending", "running", "done"] as const satisfies readonly string[];`처럼 `satisfies`를 붙인다. 배열 구조가 문자열 배열이라는 사실을 확인하면서도 리터럴 타입은 유지된다.
- 새로운 값이 필요하면 배열에만 추가하면 된다. 타입 정의는 자동으로 갱신되므로 코드 전반에서 최신 목록이 반영된다.
- API 응답을 검증할 때 `function isStatus(value: string): value is Status { return STATUSES.includes(value as Status); }`처럼 재사용 가능한 타입 가드를 작성하면 런타임 보증까지 더할 수 있다.

이 패턴 덕분에 문자열 유니온을 수동으로 관리할 때 생기는 실수를 줄이고, 자동 완성도 기대한 목록만 표시하게 된다.
