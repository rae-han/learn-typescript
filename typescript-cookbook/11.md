# 11장 클래스

2012년에 처음으로 타입스크립트가 출시되었을 때의 자바스크립트 생태계와 자바스크립트 언어의 기능은 오늘날과 비교할 수 없을 정도로 달랐다. 타입스크립트는 형식 시스템의 모양뿐만 아니라 모듈, 네임스페이스, 형식에 걸쳐 코드의 일부를 추상화할 수 있는 가능성을 더욱 풍부하게 만드는 문법도 도입했다.

이러한 특징 중 하나로 객체 지향 프로그래밍의 주요 요소인 클래스를 꼽을 수 있다. 타입스크립트 클래스는 원래 C#에서 많은 영향을 받았는데, 두 프로그래밍 언어의 배후에 있는 사람들의 정체를 안다면 이는 전혀 놀라운 일이 아니다. C#과 타입스크립트 모두 마이크로소프트에서 만들었고, 아네르스 하일스베르는 두 프로그래밍 언어에 크게 기여했다. 그러나 버려진 ECMAScript 4 제안서의 개념을 기반으로 이들을 설계했다.

시간이 흐르면서 자바스크립트는 타입스크립트와 다른 언어들이 개척한 많은 언어 기능을 얻었다. 클래스는 비공개 필드, 정적 블록, 데코레이터와 함께 이제 ECMAScript 표준의 일부가 되었고 브라우저와 서버의 언어 런타임으로 배포되었다.

덕분에 타입스크립트는 초기 언어에 가져온 혁신과 표준이라는 두 마리 토끼를 붙잡을 수 있었으며, 타입스크립트 팀은 앞으로 일어날 모든 형식 시스템의 기능 변화의 기준점으로 삼을 수 있었다. 원래 디자인은 자바스크립트와 가깝지만, 중요한 몇 가지 차이점이 있다.

이 장에서는 타입스크립트와 자바스크립트에서 클래스가 어떻게 동작하는지, 스스로 표현해야 할 부분은 무엇인지, 표준 디자인과 원래 디자인의 다른 점이 무엇인지 알아본다. 키워드, 형식, 제네릭을 살펴보고, 타입스크립트가 자바스크립트에 무엇을 추가하는지, 자체적으로 무엇을 제공하는지 스스로 찾아내는 능력을 기르도록 훈련한다.

> **2025 업데이트**: 이 장에서 다루는 많은 기능들이 현재는 ECMAScript 표준의 일부가 되었다. 특히 비공개 필드(#)는 모든 주요 브라우저에서 완전히 지원되며, ES 데코레이터는 TypeScript 5.0부터 플래그 없이 사용할 수 있다. 각 절에서 관련 업데이트를 확인할 수 있다.

---

## 11.1 올바른 가시성 변경자 선택하기

**문제** 타입스크립트에서는 프로퍼티 가시성과 접근을 두 가지 방법으로 제어한다. 하나는 `public`, `protected`, `private`이라는 특별한 키워드를 이용하는 방법이고, 다른 하나는 실제 자바스크립트 문법을 이용하는 방법(해시 기호로 시작하는 프로퍼티)이다. 어떤 방법을 선택해야 할까?

**해결** 런타임에 놓치고 싶지 않은 몇 가지 의미 때문에 자바스크립트 네이티브 문법을 선호할 때가 있다. 가시성 변경자 변형을 포함하는 복잡한 설정을 사용하는 상황이라면 타입스크립트를 사용하자. 이들은 사라지지 않는다.

**논의** 타입스크립트의 클래스는 꽤 오래 전에 등장했고 몇 년 후에는 ECMAScript 클래스에서 큰 영감을 얻었지만, 타입스크립트 팀은 당시 전통적인 클래스 기반 객체 지향 프로그래밍에서 유용하고 인기가 많았던 기능들도 타입스크립트에 도입하기로 했다.

이러한 기능 중 하나는 접근 변경자(access modifier)라고도 하는 프로퍼티 가시성 변경자(property visibility modifier)다. 가시성 변경자는 멤버(프로퍼티와 메서드) 앞에 추가할 수 있는 특별한 키워드다. 컴파일러에 소프트웨어의 다른 부분에서 어떻게 멤버를 보고 접근할 수 있는지 지시한다.

> **노트**: 프로퍼티뿐 아니라 메서드에도 모든 가시성 변경자와 자바스크립트 비공개 필드를 사용할 수 있다.

### public 변경자

기본 가시성 변경자는 `public`이며 명시적으로 표현하거나 생략할 수 있다.

```ts
class Person {
  public name: string; // 변경자 public은 선택형

  constructor(name: string) {
    this.name = name;
  }
}

const myName = new Person('Stefan');
```

### protected 변경자

또 다른 변경자는 `protected`이며, 클래스 및 하위 클래스의 가시성을 설정한다.

```ts
class Person {
  protected name: string;

  constructor(name: string) {
    this.name = name;
  }

  getName() {
    // 접근 동작함
    return this.name;
  }
}

const myName = new Person('Stefan').name;
// 오류: 'name' 속성은 보호된 속성이며 'Person' 클래스 및
// 해당 하위 클래스 내에서만 접근할 수 있습니다. ts(2445)

class Teacher extends Person {
  constructor(name: string) {
    super(name);
  }

  getFullName() {
    // 접근 동작함
    return `Professor ${this.name}`;
  }
}
```

`protected`는 파생된 클래스에서 `public`으로 덮어쓸 수 있다. 또한 `protected`는 같은 하위 클래스가 아닌 클래스 참조에서 멤버에 접근하는 것을 금지한다. 따라서 다음 코드는 동작한다:

```ts
class Player extends Person {
  constructor(name: string) {
    super(name);
  }

  pair(p: Player) {
    // 동작함 - 같은 하위 클래스의 인스턴스
    return `Pairing ${this.name} with ${p.name}`;
  }
}
```

기본 클래스나 다른 하위 클래스에서는 동작하지 않는다:

```ts
class Player extends Person {
  constructor(name: string) {
    super(name);
  }

  pair(p: Person) {
    return `Pairing ${this.name} with ${p.name}`;
    // 오류: 'name' 속성은 보호되며 'Player' 클래스의 인스턴스를
    // 통해서만 접근할 수 있습니다. 이는 'Person'
    // 클래스의 인스턴스입니다. ts(2446)
  }
}
```

### private 변경자

마지막 가시성 변경자는 `private`으로, 같은 클래스 내에서만 접근할 수 있다.

```ts
class Person {
  private name: string;

  constructor(name: string) {
    this.name = name;
  }
}

const myName = new Person('Stefan').name;
// 오류: 'name' 속성은 private이며 'Person' 클래스
// 내에서만 접근할 수 있습니다. ts(2341)

class Teacher extends Person {
  constructor(name: string) {
    super(name);
  }

  getFullName() {
    return `Professor ${this.name}`;
    // 오류: 'name' 속성은 private이며 'Person' 클래스
    // 내에서만 접근할 수 있습니다. ts(2341)
  }
}
```

### 생성자 단축 문법

생성자에서 가시성 변경자를 특성을 정의하고 초기화하는 지름길로 사용할 수도 있다.

```ts
class Category {
  constructor(public title: string, public id: number, private reference: bigint) {}
}

// 다음으로 트랜스파일됨
class Category {
  constructor(title, id, reference) {
    this.title = title;
    this.id = id;
    this.reference = reference;
  }
}
```

여기에 설명하는 모든 기능을 포함해, 타입스크립트의 가시성 변경자는 컴파일 후에는 사라지는 컴파일 타임용 애너테이션이라는 점에 유의해야 한다. 이전 예제에서 보았듯이 클래스 설명이 아니라 생성자에서 프로퍼티를 초기화하면 전체 프로퍼티 선언이 사라질 수 있다.

또한 이들은 컴파일 타임 검사 시에만 유효하므로, 컴파일 이후에는 자바스크립트에서 타입스크립트의 `private` 프로퍼티에 자유롭게 접근할 수 있다. 따라서 인스턴스를 `as any`로 어서션해 `private` 접근 검사를 우회하거나 코드가 컴파일되면 직접 접근할 수 있다. 또한 프로퍼티를 열거할 수 있으므로 `JSON.stringify`나 `Object.getOwnPropertyNames`로 직렬화될 때 이름과 값이 표시된다. 즉, 이때 형식 시스템에서 벗어나 일반 자바스크립트 클래스 멤버처럼 동작한다.

> **노트**: 가시성 변경자 외에도 `readonly` 변경자를 클래스 프로퍼티에 추가할 수 있다.

### 자바스크립트 비공개 필드 (#)

프로퍼티 접근 제한은 형식 시스템뿐 아니라 일반적으로도 유용한 기능이므로 ECMAScript는 비공개 필드라는 개념을 일반 자바스크립트 클래스에 도입했다.

비공개 필드는 가시성 변경자 대신 멤버의 이름 앞에 해시(`#`) 기호를 붙이는 새로운 문법을 사용한다.

> **팁**: 새로운 문법을 도입해 비공개 필드를 지원하면서 커뮤니티 내에서는 해시 기호의 유쾌함과 미학에 관한 열띤 논쟁이 벌어졌다. 일부 참여자들은 이를 엉망진창이라 부르기도 했다. 만약 해시 기호에 익숙해지기 힘들다면, 해시 기호를 모든 사람이 접근하지 않았으면 하는 것들 앞에 놓는 작은 울타리로 생각하면 도움이 된다.

해시 기호는 프로퍼티 이름의 일부이므로 프로퍼티에 접근할 때 앞에 있는 기호를 포함해야 함을 의미한다.

```ts
class Person {
  #name: string;

  constructor(name: string) {
    this.#name = name;
  }

  // 게터를 사용할 수 있음!
  get name(): string {
    return this.#name.toUpperCase();
  }
}

const me = new Person('Stefan');

console.log(me.#name);
// 오류: '#name' 속성은 프라이빗 식별자를 포함하기 때문에
// 'Person' 클래스 외부에서 접근할 수 없습니다. ts(18013)

console.log(me.name); // 동작함 - 게터를 통해 접근
```

비공개 필드는 자바스크립트 전체에 적용되며, 타입스크립트 컴파일러는 컴파일 이후에도 아무것도 제거하지 않고 그대로 기능을 유지(클래스 내부로 정보를 은닉)한다. 최신 ECMAScript 버전을 대상으로 한 컴파일된 결과물은 형식 애너테이션 없이도 타입스크립트 버전과 거의 비슷해 보인다.

```js
class Person {
  #name;

  constructor(name) {
    this.#name = name;
  }

  get name() {
    return this.#name.toUpperCase();
  }
}
```

비공개 필드는 런타임 코드에서 접근할 수 없으며, 열거할 수도 없다. 즉, 콘텐츠의 정보가 어떤 방식으로든 유출되지 않는다.

### 어떤 것을 선택해야 할까?

문제는 이제 비공개 가시성 변경자와 비공개 필드가 모두 타입스크립트에 존재한다는 점이다. 가시성 변경자는 오랫동안 사용해 왔으며 `protected` 멤버들과 결합하여 더 다양해졌다. 반면 비공개 필드는 자바스크립트에 아주 가까이 있으며, '형식을 표현하는 자바스크립트 문법'이라는 타입스크립트의 목표와 더불어 언어의 장기적인 계획이 거의 완벽하다.

어떤 변경자를 선택하든 둘 다 컴파일 시점에 프로퍼티 접근이 있어서는 안 되는 곳에 프로퍼티 접근이 일어나면 이를 알려준다는 목표를 달성할 수 있다. 이는 무언가 잘못되었을 수 있음을 알려주는 첫 피드백이며, 이것이 바로 타입스크립트를 사용하는 이유기도 하다.

하지만 더 자세히 살펴보면 설정에 따라 상황이 달라진다:

- 이미 정교한 공개 규칙으로 프로젝트를 설정했다면 네이티브 자바스크립트 버전으로 즉시 마이그레이션하지 못할 수도 있다
- 자바스크립트는 `protected` 가시성을 지원하지 않으므로 문제가 될 수 있다
- 이미 작동하는 프로젝트라면 굳이 바꿀 필요가 없다

숨기고 싶은 세부 정보가 런타임에 표시되는 데 문제가 있는 상황이거나 우리 코드를 라이브러리로 사용하는 사람이 모든 내부 정보에 접근할 수 없어야 한다면 비공개 필드를 사용하는 것이 좋다.

> **2025 업데이트**: 비공개 필드(`#`)는 이제 모든 주요 브라우저(Chrome, Firefox, Safari, Edge)와 Node.js에서 완전히 지원된다. 더 이상 폴리필이 필요하지 않으며, 새 프로젝트에서는 진정한 런타임 프라이버시가 필요한 경우 `#` 문법을 사용하는 것을 권장한다.
>
> **가시성 변경자 vs 비공개 필드 비교표**:
> | 특성 | private 키워드 | # 비공개 필드 |
> |------|---------------|--------------|
> | 런타임 접근 차단 | X (컴파일 타임만) | O |
> | 열거 가능 | O | X |
> | protected 지원 | O | X |
> | JSON.stringify 노출 | O | X |
> | 하위 브라우저 지원 | 폴리필 불필요 | ES2022+ 필요 |

---

## 11.2 메서드 재정의를 명시적으로 정의하기

**문제** 기본 클래스를 확장한 하위 클래스에서 특정 메서드를 재정의한다. 기본 클래스를 리팩터링할 때 기본 클래스가 변경되었음을 알려줄 방법이 없으므로 사용하지 않는 오래된 메서드를 그대로 가져와야 할 수 있다.

**해결** `noImplicitOverride` 플래그를 켜고 `override` 키워드로 재정의함을 알린다.

**논의** 캔버스에 도형을 그리려 한다. 소프트웨어는 x와 y 좌표를 포함하는 점 컬렉션을 받아 특정 렌더링 함수를 기반으로 HTML 캔버스에 다각형, 직사각형 등의 요소를 그린다.

기본 클래스 `Shape`이 임의의 `Point` 요소 목록을 받아 이들을 선으로 연결하는 클래스 계층 구조를 사용하기로 했다. 이 클래스는 세터와 게터로 필요한 작업을 처리하며 `render` 함수도 구현한다.

```ts
type Point = {
  x: number;
  y: number;
};

class Shape {
  points: Point[];
  fillStyle: string = 'white';
  lineWidth: number = 10;

  constructor(points: Point[]) {
    this.points = points;
  }

  set fill(style: string) {
    this.fillStyle = style;
  }

  set width(width: number) {
    this.lineWidth = width;
  }

  render(ctx: CanvasRenderingContext2D) {
    if (this.points.length) {
      ctx.fillStyle = this.fillStyle;
      ctx.lineWidth = this.lineWidth;
      ctx.beginPath();
      let point = this.points[0];
      ctx.moveTo(point.x, point.y);
      for (let i = 1; i < this.points.length; i++) {
        point = this.points[i];
        ctx.lineTo(point.x, point.y);
      }
      ctx.closePath();
      ctx.stroke();
    }
  }
}
```

HTML 캔버스 요소에서 2D 컨텍스트와 새 `Shape` 인스턴스를 만든 다음 `render` 함수에 컨텍스트를 전달해 이 기능을 사용한다.

```ts
const canvas = document.getElementsByTagName('canvas')[0];
const ctx = canvas?.getContext('2d');

const shape = new Shape([
  { x: 50, y: 140 },
  { x: 150, y: 60 },
  { x: 250, y: 140 },
]);

shape.fill = 'red';
shape.width = 20;
shape.render(ctx);
```

이제 준비된 기본 클래스를 이용해 직사각형처럼 특정 모양을 대표하는 하위 클래스를 파생하려고 한다. 기타 작업을 처리하는 메서드는 그대로 유지하며, 특히 `constructor`와 `render` 메서드는 재정의한다.

```ts
class Rectangle extends Shape {
  constructor(points: Point[]) {
    if (points.length !== 2) {
      throw Error(`Wrong number of points, expected 2, got ${points.length}`);
    }
    super(points);
  }

  render(ctx: CanvasRenderingContext2D) {
    ctx.fillStyle = this.fillStyle;
    ctx.lineWidth = this.lineWidth;
    let a = this.points[0];
    let b = this.points[1];
    ctx.strokeRect(a.x, a.y, b.x - a.x, b.y - a.y);
  }
}
```

`Shape`과 같은 방법으로 `Rectangle`을 사용한다.

```ts
const rectangle = new Rectangle([
  { x: 130, y: 190 },
  { x: 170, y: 250 },
]);

rectangle.render(ctx);
```

### 문제 상황: 기본 클래스 변경

소프트웨어가 발전함에 따라 클래스, 메서드, 함수가 필연적으로 바뀌었으며, 누군가 `render` 메서드의 이름을 `draw`로 바꾸었다.

```ts
class Shape {
  // 이전 코드 참조
  draw(ctx: CanvasRenderingContext2D) {
    if (this.points.length) {
      ctx.fillStyle = this.fillStyle;
      ctx.lineWidth = this.lineWidth;
      ctx.beginPath();
      let point = this.points[0];
      ctx.moveTo(point.x, point.y);
      for (let i = 1; i < this.points.length; i++) {
        point = this.points[i];
        ctx.lineTo(point.x, point.y);
      }
      ctx.closePath();
      ctx.stroke();
    }
  }
}
```

이름 변경 자체로는 문제가 되지 않는다. 하지만 이 소프트웨어를 라이브러리로 게시하면서 테스트를 포함해 코드의 어느 곳에서도 `Rectangle`의 `render` 메서드를 사용하지 않는 상태라고 가정해 보자. 원래 클래스는 바뀌었음에도 `Rectangle`의 `render` 메서드가 어딘가에 여전히 존재할 가능성이 있으며 이를 경고해 줄 장치가 전혀 없다.

### override 키워드

이런 이유로 타입스크립트에서는 재정의하려는 메서드에 `override` 키워드로 애너테이션을 추가한다. 이는 타입스크립트에서 확장한 문법이므로 타입스크립트가 코드를 자바스크립트로 트랜스파일하는 순간 사라진다.

`override` 키워드를 메서드에 추가하면 타입스크립트는 기본 클래스에 이름과 시그니처가 같은 메서드가 존재하는지 확인한다. 이름을 `render`에서 `draw`로 바꾸면 타입스크립트는 기본 클래스 `Shape`에 `render` 메서드가 선언되지 않았음을 경고한다.

```ts
class Rectangle extends Shape {
  // 이전 코드 참고
  override render(ctx: CanvasRenderingContext2D) {
    // 오류: 이 멤버는 포함하는 클래스 'Rectangle'이(가) 다른 클래스를
    // 확장하지 않으므로 'override' 한정자를 포함할 수 없습니다. ts(4112)
    ctx.fillStyle = this.fillStyle;
    ctx.lineWidth = this.lineWidth;
    let a = this.points[0];
    let b = this.points[1];
    ctx.strokeRect(a.x, a.y, b.x - a.x, b.y - a.y);
  }
}
```

이 오류는 이름을 바꾸거나 리팩토링할 때 기존 계약이 깨지지 않도록 하는 훌륭한 안전 장치다.

> **노트**: `constructor`도 재정의된 메서드로 볼 수 있지만, 의미가 다르며 이를 처리하는 다른 규칙이 존재한다(예: 하위 클래스를 인스턴스화할 때 `super`를 호출해야 함).

### noImplicitOverride 플래그

`tsconfig.json`에서 `noImplicitOverride` 플래그를 켜면 `override` 키워드로 함수를 표시해야 함을 강제할 수 있다. 그렇지 않으면, 타입스크립트에서 다른 오류가 발생한다.

```ts
class Rectangle extends Shape {
  // 이전 코드 참고
  draw(ctx: CanvasRenderingContext2D) {
    // 오류: 이 멤버는 기본 클래스 'Shape'의 멤버를 재정의하므로 'override' 한정자를
    // 포함해야 합니다. ts(4114)
    ctx.fillStyle = this.fillStyle;
    ctx.lineWidth = this.lineWidth;
    let a = this.points[0];
    let b = this.points[1];
    ctx.strokeRect(a.x, a.y, b.x - a.x, b.y - a.y);
  }
}
```

> **노트**: 클래스의 기본 형태를 정의하는 인터페이스 구현 기술은 이런 문제를 방지하는 확실한 기준을 제공하므로 클래스 계층 구조를 만들 때는 `override` 키워드와 `noImplicitOverride`를 추가 안전 장치로 사용하는 것이 좋다.

클래스 계층 구조에 의존하는 소프트웨어를 구현할 때는 `noImplicitAny`와 함께 `override`를 사용하면 사소한 일도 잊어버리지 않게 할 수 있다. 클래스 계층 구조는 다른 계층 구조와 마찬가지로 시간이 지남에 따라 복잡해지는 경향이 있으므로 가능한 한 모든 안전 장치를 마련하자.

---

## 11.3 생성자 및 프로토타입 설명하기

**문제** 특정 추상 클래스의 하위 클래스를 동적으로 인스턴스화하고 싶지만, 타입스크립트는 추상 클래스의 인스턴스화를 허용하지 않는다.

**해결** 생성자 인터페이스(constructor interface) 패턴으로 클래스를 기술한다.

**논의** 타입스크립트에서 클래스 계층 구조를 사용할 때, 타입스크립트의 구조적 특징이 때때로 방해가 될 수 있다. 예를 들어, 다양한 규칙에 따라 요소 집합을 필터링하는 다음 클래스 계층 구조를 살펴보자.

```ts
abstract class FilterItem {
  constructor(private property: string) {}
  someFunction() {
    /* ... */
  }
  abstract filter(): void;
}

class AFilter extends FilterItem {
  filter() {
    /* ... */
  }
}

class BFilter extends FilterItem {
  filter() {
    /* ... */
  }
}
```

`FilterItem` 추상 클래스는 다른 클래스에서 구현해야 한다. 이 예제에서는 `FilterItem`를 구체화한 `AFilter`와 `BFilter`를 기준으로 사용한다.

```ts
const some: FilterItem = new AFilter('a filter');
```

### 동적 인스턴스화 문제

인스턴스로 바로 작업하지 않을 때 상황이 흥미로워진다. AJAX 호출에서 가져온 토큰을 기반으로 새 필터를 인스턴스화한다고 가정해 보자. 더 쉽게 필터를 선택할 수 있도록 모든 필터를 맵에 저장한다.

```ts
declare const filterMap: Map<string, typeof FilterItem>;

filterMap.set('number', AFilter);
filterMap.set('stuff', BFilter);
```

맵의 제네릭은 `string`(백엔드의 토큰으로 사용)과 `FilterItem`의 형식 시그니처를 보완하는 모든 것으로 설정한다. 여기서는 `typeof` 키워드를 사용해 객체가 아닌 클래스를 맵에 추가한다. 결국 나중에 클래스를 인스턴스화해야 하기 때문이다.

지금까지는 모든 것이 예상대로 동작한다. 맵에서 클래스를 가져와 새 객체를 만들려고 할 때 문제가 발생한다.

```ts
let obj: FilterItem;

// 생성자 얻기
const ctor = filterMap.get('number');

if (typeof ctor !== 'undefined') {
  obj = new ctor();
  // 오류: 추상 클래스의 인스턴스를 만들 수 없습니다. ts(2511)
}
```

이것이 문제다! 타입스크립트는 이 시점에서 `FilterItem`을 반환한다는 사실을 알지만, `FilterItem`은 인스턴스화할 수 없다.

### 정적 측면과 인스턴스 측면

추상 클래스는 형식 정보(형식 네임스페이스)와 실제 구현(값 네임스페이스)을 혼합한다. 첫 번째 단계로 형식을 살펴보자. `filterMap`은 무엇을 반환할까? `FilterItem`의 모양을 정의하는 인터페이스(또는 형식 별칭)를 만들어 보자.

```ts
interface IFilter {
  new (property: string): IFilter;
  someFunction(): void;
  filter(): void;
}

declare const filterMap: Map<string, IFilter>;
```

`new` 키워드에 주목하자. 타입스크립트에서는 `new` 키워드로 생성자 함수의 형식 시그니처를 정의한다. 추상 클래스를 실제 인터페이스로 대체하면 많은 오류가 나타나기 시작한다. `implements IFilter` 구문을 어디에 넣어도 계약을 만족하는 구현을 찾을 수 없다.

```ts
abstract class FilterItem implements IFilter {
  /* ... */
}
// 오류: 'FilterItem' 클래스가 'IFilter' 인터페이스를 잘못 구현합니다.
// 'FilterItem' 형식에 'IFilter' 형식의 someFunction,
// filter 속성이 없습니다. ts(2420)

filterMap.set('number', AFilter);
// 오류: 'typeof AFilter' 형식의 인수는 'IFilter' 형식의 매개변수에
// 할당될 수 없습니다.
// 'typeof AFilter' 형식에 'IFilter' 형식의 someFunction, filter
// 속성이 없습니다. ts(2345)
```

무슨 일이 일어나는 걸까? 구현이나 클래스 자체로는 인터페이스 선언에 정의된 모든 프로퍼티와 함수를 가져올 수 없는 것 같다.

자바스크립트 클래스는 특별하다. 자바스크립트 클래스는 하나의 형식이 아니라 두 가지 형식(정적 측면 형식과 인스턴스 측면 형식)을 포함한다. 클래스를 ES6 이전의 생성자 함수와 프로토타입으로 트랜스파일하면 더 명확하게 이를 이해할 수 있다.

```js
function AFilter(property) {
  // 정적 측면 형식
  this.property = property; // 인스턴스 측면 형식
}

// 인스턴스 측면 함수
AFilter.prototype.filter = function () {
  /* ... */
};

// 예제의 일부는 아니지만, 정적 측면 코드를 보여준다.
AFilter.something = function () {
  /* ... */
};
```

> **추가 설명**: 자바스크립트에서 클래스는 사실 특별한 함수다. 클래스를 정의하면 두 가지가 생긴다:
>
> 1. **정적 측면**: 클래스 자체(생성자 함수). `static` 메서드와 프로퍼티가 여기에 속한다.
> 2. **인스턴스 측면**: `new`로 생성된 객체. 일반 메서드와 프로퍼티가 여기에 속한다.
>
> ```
> +-------------------+       +-------------------+
> |   정적 측면       |       |   인스턴스 측면    |
> | (클래스 자체)     |       | (new로 생성된 객체)|
> +-------------------+       +-------------------+
> | - constructor     |  new  | - 일반 메서드     |
> | - static 메서드   | ----> | - 일반 프로퍼티   |
> | - static 프로퍼티 |       | - prototype 체인  |
> +-------------------+       +-------------------+
> ```

### 형식 분할

즉, 객체를 만드는 데 필요한 형식 한 개와 객체 자체의 형식 한 개가 있다. 이제 이를 두 개의 형식 선언으로 분할해 보자.

```ts
interface FilterConstructor {
  new (property: string): IFilter;
}

interface IFilter {
  someFunction(): void;
  filter(): void;
}
```

첫 번째 형식인 `FilterConstructor`는 생성자 인터페이스이다. 생성자 인터페이스는 모든 정적 프로퍼티와 생성자 함수를 포함한다. 생성자 함수는 `IFilter` 인스턴스를 반환한다. `IFilter`는 인스턴스 측의 형식 정보를 포함한다. `IFilter`는 선언하는 모든 함수를 포함한다.

이를 분할하면 이후의 형식도 훨씬 더 명확해진다.

```ts
declare const filterMap: Map<string, FilterConstructor>; /* 1 */

filterMap.set('number', AFilter);
filterMap.set('stuff', BFilter);

let obj: IFilter; /* 2 */

const ctor = filterMap.get('number');
if (typeof ctor !== 'undefined') {
  obj = new ctor('a');
}
```

1. `FilterConstructor` 형식의 인스턴스를 맵에 추가한다. 즉, 원하는 객체를 생성하는 클래스만 추가할 수 있다.
2. 결국 원하는 것은 `IFilter`의 인스턴스다. 생성자 함수를 `new` 호출하면 `IFilter` 인스턴스를 반환한다.

코드가 다시 컴파일되고 원하는 모든 자동 완성 및 도구 기능을 사용할 수 있다. 추상 클래스는 유효한 인스턴스를 생성하지 않으므로 맵에 추가할 수 없다는 장점이 있다.

```ts
filterMap.set('notworking', FilterItem);
// 오류: 추상 생성자 형식을 비추상 생성자 형식에 할당할 수 없습니다. ts(2345)
```

타입스크립트와 표준 라이브러리 전체에서 생성자 인터페이스 패턴을 사용한다. `lib.es5.d.ts`의 `ObjectConstructor` 인터페이스를 살펴보면 더 많은 아이디어를 얻을 수 있다.

---

## 11.4 클래스에서 제네릭 사용하기

**문제** 타입스크립트 제네릭은 적절하게 추론되도록 설계되었지만, 클래스에서 항상 동작하는 것은 아니다.

**해결** 매개변수로 제네릭을 유추할 수 없으면 인스턴스화 시 제네릭에 명시적으로 애너테이션을 추가한다. 그렇지 않으면 기본값이 `unknown`으로 설정되므로 광범위한 값을 허용한다. 제네릭 제약 조건과 기본 매개변수를 사용해 추가 안전성을 확보한다.

**논의** 클래스에서도 제네릭을 사용할 수 있다. 함수뿐만 아니라 클래스에도 제네릭 형식 매개변수를 추가할 수 있다. 클래스 메서드의 제네릭 형식 매개변수는 함수 범위에서만 유효하지만, 클래스의 제네릭 형식 매개변수는 클래스 전체에서 유효하다.

일부 편의 함수를 포함하는 집합으로 배열을 감싸는 간단한 컬렉션을 만들어 보자. `Collection`의 클래스 정의에 `T`를 추가한 다음 전체 클래스에서 이 형식 매개변수를 재사용한다.

```ts
class Collection<T> {
  items: T[];

  constructor() {
    this.items = [];
  }

  add(item: T) {
    this.items.push(item);
  }

  contains(item: T): boolean {
    return this.items.includes(item);
  }
}
```

이제 `T`를 제네릭 형식 애너테이션으로 명시적으로 치환할 수 있다. 예를 들어 숫자나 문자열을 저장하는 컬렉션만 허용한다.

```ts
const numbers = new Collection<number>();
numbers.add(1);
numbers.add(2);

const strings = new Collection<string>();
strings.add('Hello');
strings.add('World');
```

### unknown으로 추론되는 문제

개발자는 제네릭 형식 매개변수에 명시적으로 애너테이션을 추가할 필요가 없다. 타입스크립트는 보통 사용법에서 제네릭 형식을 유추하려 시도한다. 제네릭 형식 매개변수를 추가하는 것을 잊어버리면 타입스크립트는 이를 `unknown`으로 설정하므로 모든 것을 추가할 수 있게 된다.

```ts
const unknowns = new Collection();
unknowns.add(1);
unknowns.add('World');
```

잠시 이 부분을 살펴보자. 타입스크립트는 아주 정직하다. `Collection`의 새 인스턴스를 만들 때 우리는 항목의 형식을 알 수 없다. 컬렉션의 상태를 가장 정확하게 묘사하는 형식은 `unknown`이다. 하지만 `unknown` 형식에는 무엇이든 추가할 수 있고 값을 검색할 때마다 형식 검사를 수행해야 한다는 단점도 있다.

### 초깃값으로 추론하기

타입스크립트의 클래스 추론은 함수에서와 같은 방식으로 동작한다. 특정 형식의 매개변수가 있으면 타입스크립트는 이 형식을 취해 제네릭 형식 매개변수를 대체한다. 클래스는 상태를 유지하도록 설계되었으므로 클래스 사용 중에 상태가 바뀐다. 상태는 또한 제네릭 형식 매개변수 `T`를 정의한다. `T`를 올바르게 추론하려면 클래스를 만들 때 매개변수(초깃값일 수 있음)를 요구해야 한다.

```ts
class Collection<T> {
  items: T[];

  constructor(initial: T) {
    this.items = [initial];
  }

  add(item: T) {
    this.items.push(item);
  }

  contains(item: T): boolean {
    return this.items.includes(item);
  }
}

// T는 number!
const numbersInf = new Collection(0);
numbersInf.add(1);
```

이 방법은 동작은 하지만 API 설계상 많은 아쉬움이 남는다. 초깃값이 없다면 어떨까?

### never 기본값으로 해결

`Collection`에서는 애너테이션으로 형식을 제공하는 일이 절대적으로 중요하다. 이제 남은 유일한 방법은 애너테이션 추가를 잊지 않도록 하는 것이다. 타입스크립트의 제네릭 기본 매개변수와 바닥 형식 `never`를 사용해 이 문제를 해결한다.

```ts
class Collection<T = never> {
  items: T[];

  constructor() {
    this.items = [];
  }

  add(item: T) {
    this.items.push(item);
  }

  contains(item: T): boolean {
    return this.items.includes(item);
  }
}
```

제네릭 형식 매개변수 `T`의 기본값을 `never`로 설정하여 클래스에 아주 흥미로운 동작을 추가했다. 여전히 명시적 애너테이션을 이용해 `T`를 원하는 형식으로 대체할 수 있으므로 이전과 똑같이 작동하지만, 애너테이션을 잊어버리는 순간 형식은 `unknown`이 아니라 `never`가 된다. 즉, 컬렉션과 호환되는 값이 없으므로 무언가를 추가하려고 하는 순간 많은 오류가 발생한다.

```ts
const nevers = new Collection();

nevers.add(1);
// 오류: 'number' 형식의 인수는 'never' 형식의
// 매개변수에 할당될 수 없습니다. ts(2345)

nevers.add('World');
// 오류: 'string' 형식의 인수는 'never' 형식의
// 매개변수에 할당될 수 없습니다. ts(2345)
```

이 폴백을 사용하면 제네릭 클래스를 훨씬 더 안전하게 사용할 수 있다.

> **추가 설명**: `never` 기본값 패턴은 "의도적으로 실패하게 만들기" 전략이다. 개발자가 형식을 지정하지 않으면 아무것도 할 수 없게 되어, 실수를 빠르게 발견할 수 있다. 이는 `unknown`보다 더 안전한 접근 방식이다.

---

## 11.5 클래스나 네임스페이스 사용 시기 결정하기

**문제** 타입스크립트는 네임스페이스나 정적 및 추상 클래스와 같은 객체 지향 개념을 지원하는 다양한 문법을 제공한다. 이러한 기능은 자바스크립트에는 존재하지 않는데 어떻게 해야 할까?

**해결** 형식을 추가 선언할 때는 네임스페이스 선언과 함께 사용하며, 가능하면 추상 클래스를 사용하지 않는다. 그리고 정적 클래스 대신 ECMAScript 모듈을 주로 사용한다.

**논의** Java나 C#과 같은 전통적인 객체 지향 프로그래밍 언어를 많이 사용한 사람들은 보통 모든 것을 클래스로 감싸려는 경향이 있다. 자바에서는 코드를 구조화하는 유일한 방법이 클래스이므로 대안이 없다. 자바스크립트(그리고 타입스크립트)에서는 추가 작업을 하지 않고도 원하는 작업을 수행할 수 있는 여러 대안이 있다.

### 정적 클래스 vs 모듈

그중 하나가 정적 클래스 또는 정적 메서드를 포함하는 클래스다.

```ts
// Environment.ts
export default class Environment {
  private static variableList: string[] = [];

  static variables(): string[] {
    /* ... */
  }
  static setVariable(key: string, value: any): void {
    /* ... */
  }
  static getValue(key: string): unknown {
    /* ... */
  }
}

// 다른 파일에서 사용
import Environment from './Environment';
console.log(Environment.variables());
```

이는 제대로 동작하는 코드이며 형식 애너테이션을 빼면 유효한 자바스크립트다. 하지만 평범하고, 특별하지 않은 함수에 너무 많은 장식이 붙었다.

```ts
// Environment.ts
const variableList: string[] = [];

export function variables(): string[] {
  /* ... */
}
export function setVariable(key: string, value: any): void {
  /* ... */
}
export function getValue(key: string): unknown {
  /* ... */
}

// 다른 파일에서 사용
import * as Environment from './Environment';
console.log(Environment.variables());
```

사용자 관점에서 두 코드의 인터페이스는 같다. 클래스의 정적 프로퍼티에 접근하듯이 모듈 범위 변수에 접근할 수 있지만, 이때는 모듈 범위가 자동으로 지정된다. 타입스크립트 필드 변경자가 아니라 익스포트할 항목과 표시할 항목을 결정한다. 또한 아무 작업도 하지 않는 `Environment` 인스턴스를 만들 필요가 없다.

구현도 더 쉬워진다. `variables()`의 클래스 버전을 확인하자:

```ts
export default class Environment {
  private static variableList: string[] = [];

  static variables(): string[] {
    return this.variableList;
  }
}
```

다음 모듈 버전과 비교해 보자:

```ts
const variableList: string[] = [];

export function variables(): string[] {
  return variableList;
}
```

`this`가 없으므로 생각해야 할 내용이 적어진다. 덕분에 번들러는 더 쉽게 트리 셰이킹(tree shaking)을 수행할 수 있으므로 실제로 사용하는 항목만 남는다.

```ts
// variables 함수와 variableList만 번들에 남는다
import { variables } from './Environment';
console.log(variables());
```

이런 이유로 사람들은 정적 필드와 메서드를 포함하는 클래스보다는 적절한 모듈을 항상 선호한다. 정적 필드는 아무런 장점이 없는 상용구일 뿐이다.

### 네임스페이스 사용 지양

정적 클래스와 마찬가지로 Java나 C#에 익숙한 사람들은 네임스페이스에 집착한다. 네임스페이스는 ECMAScript 모듈이 표준화되기 훨씬 전에 타입스크립트에서 코드를 정리할 수 있도록 도입한 기능이다. 네임스페이스는 파일을 여러 개로 분할하고 참조 마커로 다시 합치는 기능을 제공한다.

```ts
// users/models.ts 파일
namespace Users {
  export interface Person {
    name: string;
    age: number;
  }
}

// users/controller.ts 파일
/// <reference path="./models.ts" />
namespace Users {
  export function updateUser(p: Person) {
    // 나머지 작업 수행
  }
}
```

당시에는 타입스크립트가 번들링 기능도 포함했으며 이는 여전히 동작한다. 하지만 앞서 언급했듯이 이는 ECMAScript가 모듈을 도입하기 전의 일이다. 이제 모듈로 나머지 자바스크립트 생태계와 호환되는 코드를 구성하고 구조화할 수 있는 방법(장점)이 생겼다.

네임스페이스가 필요한 이유는 무엇일까? 예를 들어, 네임스페이스는 노드 모듈 내부에 있는 서드파티 종속성의 정의를 확장할 때도 유효하다. 전역 JSX 네임스페이스를 확장하고 `img` 요소에 대체 텍스트를 포함한다고 가정해 보자.

```ts
declare namespace JSX {
  interface IntrinsicElements {
    img: HTMLAttributes & {
      alt: string;
      src: string;
      loading?: 'lazy' | 'eager' | 'auto';
    };
  }
}
```

또는 앰비언트 모듈에서 정교한 형식 정의를 구현하고 싶을 수도 있다. 하지만 그 외에는 사용할 일이 많지 않다.

네임스페이스는 여러분의 정의를 객체로 감싸 다음과 같은 형태로 만든다.

```ts
export namespace Users {
  type User = {
    name: string;
    age: number;
  };

  export function createUser(name: string, age: number): User {
    return { name, age };
  }
}

// 트랜스파일 결과
export var Users;
(function (Users) {
  function createUser(name, age) {
    return { name, age };
  }
  Users.createUser = createUser;
})(Users || (Users = {}));
```

이렇게 하면 불필요한 코드를 추가할 뿐 아니라 번들러의 트리 셰이킹 작업을 방해한다! 또한 사용법도 더 복잡해진다.

```ts
import * as Users from './users';
Users.Users.createUser('Stefan', '39');
```

이들을 삭제하면 일이 훨씬 쉬워진다. 자바스크립트가 제공하는 기능에 충실해지자. 선언 파일 외부에서 네임스페이스를 사용하지 않으면 코드를 명확하고, 간단하며, 깔끔하게 유지할 수 있다.

> **2025 업데이트**: TypeScript 팀은 네임스페이스 사용을 더욱 강력히 권장하지 않고 있다. ESM(ECMAScript Modules)이 표준이 되면서 네임스페이스의 필요성이 거의 사라졌다. 새 프로젝트에서는 반드시 ESM을 사용하자.
>
> **네임스페이스 대신 ESM 사용하기**:
>
> ```ts
> // 이전 (네임스페이스)
> namespace Utils {
>   export function helper() {
>     /* ... */
>   }
> }
>
> // 현재 (ESM)
> // utils.ts
> export function helper() {
>   /* ... */
> }
>
> // 사용
> import { helper } from './utils';
> ```

### 추상 클래스 사용 주의

마지막으로 추상 클래스가 있다. 추상 클래스는 일부 동작은 미리 정의하지만 일부 기능은 추상 클래스를 확장하는 클래스에 맡기므로 더 복잡한 클래스 계층 구조를 구성한다.

```ts
abstract class Lifeform {
  age: number;

  constructor(age: number) {
    this.age = age;
  }

  abstract move(): string;
}

class Human extends Lifeform {
  move() {
    return 'Walking, mostly...';
  }
}
```

이 코드는 `Lifeform`의 모든 하위 클래스가 `move`를 구현하도록 강제한다. 이는 기본적으로 모든 클래스 기반 프로그래밍 언어에 존재하는 개념이다. 다만 자바스크립트가 전통적으로 클래스 기반이 아니라는 점이 문제다. 예를 들어, 다음과 같은 추상 클래스는 유효한 자바스크립트 클래스를 생성하지만 타입스크립트에서는 인스턴스화할 수 없다.

```ts
abstract class Lifeform {
  age: number;

  constructor(age: number) {
    this.age = age;
  }
}

const lifeform = new Lifeform(20);
// 오류: 추상 클래스의 인스턴스를 만들 수 없습니다. ts(2511)
```

일반 자바스크립트 코드를 구현하지만 다음의 함수 코드처럼 타입스크립트를 활용해 암묵적 문서 형태로 정보를 제공한다면 의도하지 않은 상황이 발생할 수 있다.

```ts
declare function moveLifeform(lifeform: Lifeform);
```

1. 사용자는 `moveLifeform` 함수에 `Lifeform` 객체를 전달하라는 의미로 이해할 것이다. 내부적으로는 `Lifeform.move()`를 호출한다.
2. `Lifeform`은 유효한 클래스이므로 자바스크립트에서 인스턴스화할 수 있다.
3. `Lifeform`에는 `move` 메서드가 존재하지 않으므로 애플리케이션이 깨진다!

이는 잘못된 보안 의식 때문이다. 프로토타입 체인에 미리 정의된 구현을 넣은 다음 예상하는 사항을 알려주는 계약을 만드는 것이 좋다.

```ts
interface Lifeform {
  move(): string;
}

class BasicLifeForm {
  age: number;

  constructor(age: number) {
    this.age = age;
  }
}

class Human extends BasicLifeForm implements Lifeform {
  move() {
    return 'Walking';
  }
}
```

`Lifeform`을 탐색하는 순간 인터페이스를 포함해 모든 예상 내용을 볼 수 있지만, 실수로 잘못된 클래스를 인스턴스화하는 상황은 거의 발생하지 않는다.

### 언제 클래스를 사용해야 할까?

클래스와 네임스페이스를 사용하지 말아야 할 때를 모두 언급했는데, 그러면 언제 이들을 사용해야 할까? 같은 객체(내부 상태가 객체의 기능에 가장 중요한 역할을 함)의 여러 인스턴스가 필요할 때 사용한다.

---

## 11.6 정적 클래스 작성하기

**문제** 클래스 기반 객체 지향 프로그래밍으로 특정 기능에는 정적 클래스를 사용하도록 배웠는데, 타입스크립트는 이러한 원칙을 어떻게 지원하는지 궁금하다.

**해결** 타입스크립트는 고전적인 정적 클래스를 지원하지 않는 대신 다양한 용도로 사용하도록 클래스에서 정적 변경자를 제공한다.

**논의** 정적 클래스는 구체적인 객체로 인스턴스화할 수 없다. 정적 클래스는 단 한 개만 존재하며 어느 위치의 코드에서 접근해도 같은 메서드와 멤버를 제공한다. Java나 C#처럼 클래스를 추상화 수단으로만 사용하는 프로그래밍 언어에는 정적 클래스가 꼭 필요하다. 자바스크립트와 타입스크립트에서는 이를 더 다양한 방법으로 표현할 수 있다.

타입스크립트에서는 클래스를 `static`으로 선언할 수는 없지만 클래스에 `static` 멤버를 정의할 수는 있다. 메서드나 프로퍼티는 객체의 일부가 아니며 대신 클래스 자체에서 접근할 수 있다.

11.5절에서 살펴봤듯이 정적 멤버만 있는 클래스는 타입스크립트에서 안티패턴이다. 그 대신 함수를 만들고, 모듈별로 상태를 유지할 수 있다. 보통 익스포트한 함수와 모듈 범위의 항목을 조합하는 것이 좋다.

```ts
// 안티패턴
export default class Environment {
  private static variableList: string[] = [];
  static variables(): string[] {
    /* ... */
  }
  static setVariable(key: string, value: any): void {
    /* ... */
  }
  static getValue(key: string): unknown {
    /* ... */
  }
}

// 더 좋은 방법: 모듈 범위의 함수와 변수
const variableList: string[] = [];
export function variables(): string[] {
  /* ... */
}
export function setVariable(key: string, value: any): void {
  /* ... */
}
export function getValue(key: string): unknown {
  /* ... */
}
```

### 적절한 static 사용 사례

하지만 클래스의 `static`을 사용할 때도 있다. 클래스는 정적 멤버와 동적 멤버를 포함한다. `constructor`는 클래스의 정적 기능의 일부이고 프로퍼티와 메서드는 동적 기능의 일부이다. `static` 키워드를 사용하면 정적 기능에 무언가를 추가할 수 있다.

2차원 공간에서 한 점을 가리키는 `Point`라는 클래스를 생각해 보자. 이 클래스에는 x와 y 좌표가 있는데, 여기에 한 점과 다른 점 사이의 거리를 계산하는 메서드를 만들어 보자.

```ts
class Point {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }

  distanceTo(point: Point): number {
    const dx = this.x - point.x;
    const dy = this.y - point.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
}

const a = new Point(0, 0);
const b = new Point(1, 5);
const distance = a.distanceTo(b);
```

잘 동작한다. 하지만 시작점과 끝점 중 어느 쪽이 먼저 오더라도 거리는 같으므로 API가 약간 이상하게 느껴질 수 있다. `Point`의 정적 메서드 `distance`는 순서를 따지지 않는 두 개의 인수를 받는다.

```ts
class Point {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }

  distanceTo(point: Point): number {
    const dx = this.x - point.x;
    const dy = this.y - point.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  static distance(p1: Point, p2: Point): number {
    return p1.distanceTo(p2);
  }
}

const a = new Point(0, 0);
const b = new Point(1, 5);
const distance = Point.distance(a, b);
```

### 정적 비공개 필드와 정적 블록

클래스는 생성자 함수/프로토타입 패턴의 문법적 설탕에 불과한 것이 아니다. 클래스는 일반 객체로 표현할 수 없는 비공개 필드를 포함함으로써 클래스 및 그 인스턴스와 실제로 관련된 작업을 수행할 수 있다.

예를 들어, 사용할 메서드를 혼동하지 않도록 `distanceTo` 메서드는 숨기고 정적 메서드만 사용하도록 만든다. `distanceTo` 앞에 비공개 변경자를 추가하면 외부에서는 접근할 수 없지만, 내부 정적 멤버는 문제없이 이를 사용할 수 있다.

```ts
class Point {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }

  #distanceTo(point: Point): number {
    const dx = this.x - point.x;
    const dy = this.y - point.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  static distance(p1: Point, p2: Point): number {
    return p1.#distanceTo(p2);
  }
}
```

가시성은 다른 방향으로도 확장된다. 시스템에 특정 `Task`를 표현하는 클래스가 있는데, 존재하는 작업의 수를 제한하고 싶다고 가정해 보자.

0에서 시작하는 `nextId`라는 정적 비공개 필드를 사용하며, 인스턴스 `Task`가 생성될 때마다 `nextId`를 높인다. 100에 도달하면 에러가 발생한다.

```ts
class Task {
  static #nextId = 0;
  #id: number;

  constructor() {
    if (Task.#nextId > 99) {
      throw 'Max number of tasks reached';
    }
    this.#id = Task.#nextId++;
  }
}
```

동적인 값을 얻어와 그에 따라 정적 비공개 필드를 갱신하는 `static` 인스턴스화 블록을 사용해 백엔드에서 제공하는 동적인 값으로 인스턴스 수를 제한할 수 있다.

```ts
type Config = {
  instances: number;
};

class Task {
  static #nextId = 0;
  static #maxInstances: number;
  #id: number;

  static {
    fetch('/available-slots')
      .then((res) => res.json())
      .then((result: Config) => {
        Task.#maxInstances = result.instances;
      });
  }

  constructor() {
    if (Task.#nextId > Task.#maxInstances) {
      throw 'Max number of tasks reached';
    }
    this.#id = Task.#nextId++;
  }
}
```

타입스크립트는 인스턴스의 필드 외에 정적 필드가 인스턴스화되었는지를 확인하지 않는다. 예를 들어 백엔드에서 사용할 수 있는 슬롯 수를 비동기로 로드한 다음 인스턴스를 생성하는데, 이때 최대 슬롯에 도달했는지 확인할 수 없는 순간이 존재한다.

따라서 타입스크립트는 정적 클래스의 구조체를 지원하지 않으며, 정적 전용 클래스를 안티패턴으로 간주함에도 다양한 상황에서 정적 멤버를 유용하게 사용할 수 있다.

> **2025 업데이트**: 정적 초기화 블록(`static { }`)은 ES2022 표준으로 확정되었으며, 모든 주요 브라우저와 Node.js 16+에서 지원된다. 복잡한 정적 초기화 로직이 필요할 때 유용하게 사용할 수 있다.

---

## 11.7 엄격한 프로퍼티 초기화 작업하기

**문제** 클래스가 상태를 유지하는데, 이 상태가 초기화되고 있는지를 알려주는 장치가 없다.

**해결** `tsconfig`에서 `strictPropertyInitialization`을 `true`로 설정하여 엄격한 프로퍼티 초기화를 활성화한다.

**논의** 클래스는 객체를 만드는 코드 템플릿이다. 먼저 클래스의 프로퍼티와 메서드를 정의한 다음 인스턴스화해야 실젯값을 할당할 수 있다. 타입스크립트 클래스는 기본 자바스크립트 클래스에 더 많은 문법을 추가하여 형식을 정의한다. 예를 들어 타입스크립트를 사용하면 형식이나 인터페이스와 비슷한 방식으로 인스턴스의 프로퍼티를 정의할 수 있다.

```ts
type State = 'active' | 'inactive';

class Account {
  id: number;
  userName: string;
  state: State;
  orders: number[];
}
```

그러나 이 표기법은 모양만 정의할 뿐, 구체적인 값은 설정하지 않는다. 일반 자바스크립트로 트랜스파일할 때 이러한 프로퍼티는 모두 지워지고 형식 네임스페이스에만 남는다.

이 표기법은 가독성이 뛰어나므로 개발자는 어떤 프로퍼티를 기대하는지 알 수 있다. 하지만 해당 프로퍼티가 실제로 존재한다는 보장은 없다. 초기화하지 않은 모든 프로퍼티는 누락되거나 `undefined`가 된다.

### strictPropertyInitialization 활성화

타입스크립트는 이런 상황을 예방하는 안전 장치를 제공한다. `tsconfig.json`에서 `strictPropertyInitialization` 플래그를 `true`로 설정하면 타입스크립트는 클래스에서 새 객체를 만들 때 모든 예상 프로퍼티가 실제로 초기화되는지 확인한다.

> **노트**: `strictPropertyInitialization`은 타입스크립트의 `strict` 모드의 일부다. `tsconfig`에서 `strict`를 `true`로 설정하면(당연히 설정해야 함) 엄격한 프로퍼티 초기화도 활성화된다.

이 기능을 활성화하면 여러 개의 물결선이 나타난다.

```ts
class Account {
  id: number;
  // 오류: 속성 'id'은(는) 이니셜라이저가 없고 생성자에 할당되어 있지
  // 않습니다. ts(2564)
  userName: string;
  // 오류: 속성 'userName'은(는) 이니셜라이저가 없고 생성자에 할당되어 있지
  // 않습니다. ts(2564)
  state: State;
  // 오류: 속성 'state'은(는) 이니셜라이저가 없고 생성자에 할당되어 있지
  // 않습니다. ts(2564)
  orders: number[];
  // 오류: 속성 'orders'은(는) 이니셜라이저가 없고 생성자에 할당되어 있지
  // 않습니다. ts(2564)
}
```

### 도메인 규칙에 따른 해결

이제 모든 프로퍼티가 값을 받을 수 있도록 해야 한다. `Account` 예를 살펴보면 애플리케이션의 도메인에 의거해 몇 가지 제약 조건이나 규칙을 정의할 수 있다.

1. `id`와 `userName`은 백엔드와의 통신을 제어하고 내용을 표시하는 데 필요하다.
2. `state`도 설정해야 하며 기본값은 `active` 상태다. 의도적으로 `inactive`으로 설정하지 않는 한 일반적으로 소프트웨어의 계정은 활성 상태다.
3. `orders`는 주문 아이디를 포함하는 배열이지만, 주문이 없다면 어떻게 해야 할까? 빈 배열도 잘 동작하거나 `orders`가 아직 정의되지 않았다고 설정할 수 있다.

이러한 제약 조건을 고려하면 이미 두 가지 오류를 해결할 수 있다. `state`의 기본값을 `active`로 설정하고 `orders`는 선택형으로 설정했다.

```ts
class Account {
  id: number; // 여전히 오류 발생
  userName: string; // 여전히 오류 발생
  state: State = 'active'; // 동작함
  orders?: number[]; // 동작함
}
```

다른 두 프로퍼티는 여전히 오류를 일으킨다. `constructor`를 추가하고 이들 프로퍼티를 초기화하면 나머지 오류도 없앨 수 있다.

```ts
class Account {
  id: number;
  userName: string;
  state: State = 'active';
  orders?: number[];

  constructor(userName: string, id: number) {
    this.userName = userName;
    this.id = id;
  }
}
```

### 생성자 단축 문법

제대로 된 타입스크립트 클래스를 만들었다! 타입스크립트에서는 생성자 매개변수에 `public`, `private`, `protected`와 같은 가시성 접근자를 추가해 이름과 값이 같은 클래스 프로퍼티으로 변환할 수 있는 생성자 단축 기능을 제공한다. 많은 상용구 코드를 제거하는 편리한 기능이다. 이때 클래스 모양에 같은 프로퍼티를 정의하지 말아야 한다.

```ts
class Account {
  state: State = 'active';
  orders?: number[];

  constructor(public userName: string, public id: number) {}
}
```

현재 클래스를 보면 타입스크립트 기능에만 의존함을 알 수 있다. 자바스크립트에 해당하는 트랜스파일된 클래스는 많이 달라 보인다.

```js
class Account {
  constructor(userName, id) {
    this.userName = userName;
    this.id = id;
    this.state = 'active';
  }
}
```

`constructor`가 인스턴스를 정의하므로, 모든 것이 `constructor` 안에 있다.

> **경고**: 타입스크립트 단축 기능과 클래스 문법은 멋져 보이지만, 너무 많이 사용하지 않도록 주의해야 한다. 최근 몇 년 동안 일반 자바스크립트에 형식을 제공하는 문법 확장으로 타입스크립트의 방향을 전환했지만, 수년 동안 존재해 온 클래스 기능을 아직도 사용할 수 있으며 때로는 예상과 다른 의미를 코드에 부여한다. 코드를 '형식이 있는 자바스크립트'라고 생각한다면 특히 타입스크립트 클래스 기능을 깊이 있게 다룰 때 주의해야 한다.

### 비동기 초기화 처리

엄격한 프로퍼티 초기화는 `constructor`로 호출되는 함수 내에서 프로퍼티를 설정하는 것과 같은 복잡한 시나리오도 이해한다. 또한 비동기 클래스 때문에 클래스가 잠재적으로 초기화되지 않은 상태로 남을 수 있다는 점도 이해한다.

`id` 프로퍼티로 클래스를 초기화하고 백엔드에서 `userName`을 가져온다고 가정해 보자. 생성자에서 비동기 호출을 수행하고 `fetch` 호출이 완료되어 `userName`을 설정했는데도 여전히 엄격한 프로퍼티 초기화 오류가 발생한다.

```ts
type User = {
  id: number;
  userName: string;
};

class Account {
  userName: string;
  // 오류: 속성 'userName'은(는) 이니셜라이저가 없고 생성자에 할당되어 있지
  // 않습니다. ts(2564)
  state: State = 'active';
  orders?: number[];

  constructor(public id: number) {
    fetch(`/api/getName?id=${id}`)
      .then((res) => res.json())
      .then((data: User) => (this.userName = data.userName ?? 'not-found'));
  }
}
```

이는 사실이다! `fetch` 호출이 성공한다는 보장이 없으며, 오류를 `catch`로 잡아 프로퍼티를 폴백값으로 초기화하더라도 일정 시간 동안은 객체가 초기화되지 않은 `userName`을 포함한 상태로 유지되기 때문이다.

### 해결 방법 1: 정적 팩토리 함수

비동기적으로 동작하는 정적 팩토리 함수를 사용하여 데이터를 먼저 가져온 다음 두 프로퍼티를 모두 기대하는 생성자를 호출하는 방법이다.

```ts
class Account {
  state: State = 'active';
  orders?: number[];

  constructor(public id: number, public userName: string) {}

  static async create(id: number) {
    const user: User = await fetch(`/api/getName?id=${id}`).then((res) => res.json());
    return new Account(id, user.userName);
  }
}
```

이렇게 하면 두 프로퍼티에 모두 접근할 수 있을 때 바로 객체를 인스턴스화할 수 있고, `id`만 사용할 수 있을 때는 비동기 컨텍스트에서 인스턴스화할 수 있다. 이렇게 생성자 업무를 나누어 주면서 생성자의 `async`를 제거했다.

### 해결 방법 2: 확정 할당 어서션

초기화되지 않은 상태를 단순히 무시하는 방법도 있다. `userName`의 상태가 애플리케이션과 전혀 관련이 없으며 필요할 때만 접근하는 프로퍼티라면 어떻게 해야 할까? 확정 할당 어서션(definite assignment assertion)(느낌표)을 사용해 이 프로퍼티를 초기화된 것으로 간주하도록 타입스크립트에 알린다.

```ts
class Account {
  userName!: string; // 느낌표로 확정 할당 어서션
  state: State = 'active';
  orders?: number[];

  constructor(public id: number) {
    fetch(`/api/getName?id=${id}`)
      .then((res) => res.json())
      .then((data: User) => (this.userName = data.userName));
  }
}
```

이제 관리 책임은 여러분에게 있으며, 느낌표를 포함한 런타임 오류 등을 안전하지 않은 작업으로 분류할 수 있는 타입스크립트 전용 문법을 얻었다.

---

## 11.8 클래스에서 this 형식으로 작업하기

**문제** 기능을 재사용할 수 있도록 기본 클래스를 확장했으며, 같은 클래스의 인스턴스를 참조하는 메서드 시그니처가 있다. 다른 하위 클래스와 인터페이스가 섞이지 않도록 하고 싶지만, 단지 형식을 바꾸려고 메서드를 오버라이드하고 싶진 않다.

**해결** 실제 클래스 형식 대신 `this`를 형식으로 사용한다.

**논의** 이 예에서는 클래스로 게시판 소프트웨어의 다양한 사용자 역할을 모델링한다. 먼저 식별 기능을 제공하는 사용자 아이디와 토론글을 여는 기능을 포함하는 일반적인 `User`를 만든다.

```ts
class User {
  #id: number;
  static #nextThreadId: number;

  constructor(id: number) {
    this.#id = id;
  }

  equals(user: User): boolean {
    return this.#id === user.#id;
  }

  async openThread(title: string, content: string): Promise<number> {
    const threadId = User.#nextThreadId++;
    await fetch('/createThread', {
      method: 'POST',
      body: JSON.stringify({
        content,
        title,
        threadId,
      }),
    });
    return threadId;
  }
}
```

이 클래스는 `equals` 메서드도 포함한다. 코드베이스 어딘가에서 사용한 두 개의 사용자 참조가 같은지 확인해야 하는데, 사용자를 식별하는 아이디는 `number`이므로 쉽게 비교할 수 있다.

`User`는 모든 사용자의 기본 클래스이므로 `User` 클래스를 상속받아 쉽게 더 많은 권한을 가진 역할을 추가할 수 있다. 예를 들어 `Admin`에는 토론글을 닫는 기능이 있으며, 다른 메서드에서 사용할 수 있는 권한 집합을 저장한다.

```ts
class Admin extends User {
  #privileges: string[];

  constructor(id: number, privileges: string[] = []) {
    super(id);
    this.#privileges = privileges;
  }

  async closeThread(threadId: number) {
    await fetch('/closeThread', {
      method: 'POST',
      body: '' + threadId,
    });
  }
}
```

> **노트**: 프로그래밍 커뮤니티에서는 상속의 이점이 함정보다 많지 않으므로 상속을 무시하는 것이 더 좋을지에 관한 많은 논쟁이 있다. 하지만 웹 컴포넌트와 같은 자바스크립트의 일부 기능은 상속에 의존한다.

`User`를 상속받았으므로 `openThread` 메서드를 다시 구현할 필요가 없으며, 모든 관리자는 사용자이므로 `equals` 메서드를 재사용할 수 있다.

### 비교 방향 문제

클래스를 설정한 다음 클래스를 인스턴스화하여 `User` 및 `Admin` 형식의 새 객체를 만들 수 있다. 또한 `equals` 메서드를 호출하여 두 사용자가 같은지 비교할 수 있다.

```ts
const user = new User(1);
const admin = new Admin(2);

console.log(user.equals(admin));
console.log(admin.equals(user));
```

하지만 비교의 방향과 관련한 한 가지 사소한 문제가 있다. 물론 두 숫자를 비교할 때 순서는 상관이 없으므로 `admin`와 `user`를 표면적으로 비교할 때는 문제가 없다. 하지만 주변 클래스와 하위 형식을 생각하면 개선할 부분이 있다.

- 사용자가 추가 권한을 얻었을 수 있으므로 `user`가 `admin`인지 검사할 수 있다.
- 넓은 상위 형식은 적은 정보를 포함하므로 `admin`을 `user`라고 해야 할지 의문이다.
- `Admin`에 인접한 다른 `Moderator`의 하위 클래스가 있다면 기본 클래스 외부의 프로퍼티를 공유하지 않으므로 서로 비교할 수 없게 하고 싶다.

하지만 현재 개발 중인 `equals`는 모든 비교를 수행한다.

### this 형식 사용

비교 대상의 형식을 바꿔 이를 해결할 수 있다. 입력 매개변수에 `User`로 먼저 애너테이션을 추가했지만, 실제로는 같은 형식의 다른 인스턴스와 비교하고 싶다. 이런 상황에서 `this`라는 형식을 사용할 수 있다.

```ts
class User {
  // ...
  equals(user: this): boolean {
    return this.#id === user.#id;
  }
}
```

이 `this` 매개변수 형식은 2.7절에서 배운 지울 수 있는 `this` 매개변수와는 다르다. `this` 매개변수 형식을 사용하면 함수 범위 안에서 `this` 전역 변수의 구체적인 형식을 설정할 수 있기 때문이다. `this` 형식은 메서드가 속한 클래스를 참조한다. 그리고 `this`는 구현에 따라 바뀐다. 따라서 `User`의 `user`에 `this`로 애너테이션을 추가하면 `User`를 상속하는 클래스에서는 `Admin`이나 `Moderator`가 되는 식으로 변한다. 이를 활용해 `admin.equals`는 다른 `Admin` 클래스를 비교 대상으로 기대하며, 그렇지 않으면 오류가 발생한다.

```ts
console.log(admin.equals(user));
// 오류: 'User' 형식의 인수는 'Admin' 형식의 매개변수에 할당될 수 없습니다.
```

다른 방법도 잘 동작한다. `Admin`은 `User`의 모든 프로퍼티를 포함하므로(결국 하위 클래스이므로) `user.equals(admin)`를 쉽게 수행할 수 있다.

### 반환 형식으로 this 사용

`this` 형식을 반환 형식으로 사용할 수도 있다. 빌더 패턴을 구현하는 이 `OptionBuilder`를 살펴보자.

```ts
class OptionBuilder<T = string | number | boolean> {
  #options: Map<string, T> = new Map();

  constructor() {}

  add(name: string, value: T): OptionBuilder<T> {
    this.#options.set(name, value);
    return this;
  }

  has(name: string) {
    return this.#options.has(name);
  }

  build() {
    return Object.fromEntries(this.#options);
  }
}
```

`OptionBuilder<T>`는 `Map`을 감싸는 소프트 래퍼로 키/값 쌍을 설정할 수 있다. 연쇄할 수 있는 인터페이스를 제공하므로 `add`를 호출하면 현재 인스턴스를 반환하므로 `add`를 호출한 다음 반환 결과에 또 다시 `add`를 호출할 수 있다. 반환 형식에 `OptionBuilder<T>`로 애너테이션을 추가했다.

```ts
const options = new OptionBuilder().add('deflate', true).add('compressionFactor', 10).build();
```

이제 `OptionBuilder`를 상속하면서 요소의 형식을 `string`으로 설정하는 `StringOptionBuilder`를 만든다. 또한 특정 값을 쓰기 전에 값이 이미 설정되었는지 확인하는 `safeAdd` 메서드를 추가해 이전 설정을 오버라이드하지 않도록 한다.

```ts
class StringOptionBuilder extends OptionBuilder<string> {
  safeAdd(name: string, value: string) {
    if (!this.has(name)) {
      this.add(name, value);
    }
    return this;
  }
}
```

새 빌더를 사용해 보면 첫 번째 단계에 `add`가 있을 때 예상과 다르게 `safeAdd`를 사용할 수 없다는 사실을 알게 된다.

```ts
const languages = new StringOptionBuilder()
  .add('en', 'English')
  .safeAdd('de', 'Deutsch')
  // 오류: 'OptionBuilder<string>' 형식에 'safeAdd' 속성이 없습니다. ts(2339)
  .safeAdd('de', 'German')
  .build();
```

타입스크립트는 `OptionBuilder<string>` 형식에 `safeAdd`가 존재하지 않는다고 알려준다. 이 함수는 어디로 사라졌을까? 문제는 `add`에 매우 광범위한 애너테이션을 사용했다는 것이다. 물론 `StringOptionBuilder`는 `OptionBuilder<string>`의 하위 형식이지만, 애너테이션을 사용하면 더 좁은 형식 정보를 잃는다.

`this`를 반환 형식으로 사용하면 이 문제를 해결할 수 있다.

```ts
class OptionBuilder<T = string | number | boolean> {
  // ...
  add(name: string, value: T): this {
    this.#options.set(name, value);
    return this;
  }
}
```

이전 예제와 같은 효과가 일어난다. `this`는 `OptionBuilder<T>`에서 `OptionBuilder<T>`가 되고, `StringOptionBuilder`에서는 `StringOptionBuilder`가 된다. `this`를 반환하고 반환 형식 애너테이션을 생략하면 `this`는 유추된 반환 형식이 된다. 따라서 사용자의 선호에 따라 `this`를 명시적으로 사용할지가 달라진다(2.1절 참조).

---

## 11.9 데코레이터 구현하기

**문제** 텔레메트리(telemetry)에 사용한 메서드의 실행을 기록하고 싶은데, 모든 메서드에 수동 로그를 추가하려니 번거롭다.

**해결** `log`라는 클래스 메서드 데코레이터를 구현한 다음 대상 메서드에 애너테이션을 추가한다.

**논의** 데코레이터(decorator) 디자인 패턴은 유명한 책인 『GoF의 디자인 패턴』(에릭 감마 외)에서 클래스와 메서드를 장식하여(decorate) 특정 동작을 동적으로 추가하거나 덮어쓸 수 있는 기법으로 설명한다.

객체 지향 프로그래밍에서 자연스럽게 등장한 디자인 패턴으로 시작된 데코레이터는 아주 대중화되어 객체 지향 특징이 있는 프로그래밍 언어에서는 특별한 문법으로 데코레이터를 언어에 추가한다. 자바(애너테이션), C#(속성), 자바스크립트에서 그 흔적을 찾을 수 있다.

ECMAScript의 데코레이터 제안은 꽤 오랫동안 제안 상태에 묶여 있었으나, 2022년 마침내 3단계(구현 준비 완료)에 도달했다. 모든 기능이 3단계에 도달하면서 타입스크립트는 새로운 사양을 빠르게 채택한 도구가 되었다.

> **경고**: 타입스크립트에서는 오랫동안 `experimentalDecorators` 컴파일러 플래그로 데코레이터를 지원했다. 타입스크립트 5.0에서는 네이티브 ECMAScript 데코레이터 제안이 완전히 구현되어 플래그 없이 사용할 수 있다. 실제 ECMAScript 구현은 원래 설계와 근본적으로 다르며, 타입스크립트 5.0 이전에 데코레이터를 개발했다면 새 사양에서는 동작하지 않는다. `experimentalDecorators` 플래그를 켜면 ECMAScript 네이티브 데코레이터가 꺼진다는 점에 유의하자. 또한 형식과 관련하여 `lib.decorators.d.ts`는 ECMAScript 네이티브 데코레이터에 대한 모든 형식 정보를 포함하지만, `lib.decorators.legacy.d.ts`의 형식에는 이전 형식 정보를 포함한다. 따라서 프로젝트 설정이 올바른지, 잘못된 정의 파일의 형식을 사용하고 있지 않은지 확인하자.

> **2025 업데이트**: ES 데코레이터는 이제 모든 주요 브라우저와 Node.js에서 지원된다. TypeScript 5.0+를 사용하면 `experimentalDecorators` 플래그 없이 표준 데코레이터를 사용할 수 있다.
>
> **레거시 데코레이터 vs 표준 데코레이터**:
> | 특성 | experimentalDecorators | 표준 데코레이터 (TS 5.0+) |
> |------|----------------------|-------------------------|
> | 플래그 필요 | O | X |
> | 메타데이터 API | reflect-metadata 필요 | 내장 context 제공 |
> | 매개변수 데코레이터 | O | X (아직 미지원) |
> | Angular/NestJS 호환 | O | 마이그레이션 필요 |
>
> **마이그레이션 팁**: Angular, NestJS 등 레거시 데코레이터를 사용하는 프레임워크는 아직 `experimentalDecorators`가 필요할 수 있다. 새 프로젝트에서는 표준 데코레이터 사용을 권장한다.

### 메서드 데코레이터 구현

데코레이터를 사용하면 클래스의 거의 모든 것을 꾸밀 수 있다. 이 예제에서는 메서드 호출 실행을 기록할 수 있는 메서드 데코레이터부터 시작한다.

데코레이터는 값과 컨텍스트(둘 다 데코레이션하려는 클래스 요소의 형식에 의존함)를 받는 함수다. 이러한 데코레이터 함수는 자신의 메서드를 실행하기 전(또는 필드 초기화 이전, 접근자 호출 이전 등)에 실행할 다른 함수를 반환한다.

다음은 간단한 `log` 메서드 데코레이터 코드다.

```ts
function log(value: Function, context: ClassMethodDecoratorContext) {
  return function (this: any, ...args: any[]) {
    console.log(`calling ${context.name.toString()}`);
    return value.call(this, ...args);
  };
}

class Toggler {
  #toggled = false;

  @log
  toggle() {
    this.#toggled = !this.#toggled;
  }
}

const toggler = new Toggler();
toggler.toggle();
```

`log` 함수는 원래 데코레이터 제안에서 정의한 `ClassMethodDecorator` 형식을 따른다.

```ts
type ClassMethodDecorator = (
  value: Function,
  context: {
    kind: 'method';
    name: string | symbol;
    access: { get(): unknown };
    static: boolean;
    private: boolean;
    addInitializer(initializer: () => void): void;
  },
) => Function | void;
```

### 제네릭으로 형식 강화

아직 자세한 형식은 구현하지 않았다. 형식이 아주 복잡해질 수 있으므로 현재는 대부분 `any`를 사용한다. 모든 매개변수에 형식을 추가하려면 제네릭을 많이 사용해야 한다.

```ts
function log<This, Args extends any[], Return>(
  value: (this: This, ...args: Args) => Return,
  context: ClassMethodDecoratorContext,
): (this: This, ...args: Args) => Return {
  return function (this: This, ...args: Args) {
    console.log(`calling ${context.name.toString()}`);
    return value.call(this, ...args);
  };
}
```

전달할 메서드를 설명하는 데 제네릭 형식 매개변수가 필요하다. 다음 형식을 포착하려 한다:

- `This`는 `this` 매개변수 형식(2.7절 참조)에 대응하는 제네릭 형식 매개변수다. 데코레이터는 객체 인스턴스의 컨텍스트에서 실행되므로 `this`를 설정해야 한다.
- 그런 다음 메서드의 인수를 `Args`로 설정한다. 2.4절에서 배웠듯이, 메서드나 함수의 인수는 튜플로 설명할 수 있다.
- 마지막으로, 메서드는 특정 형식의 값을 반환해야 하므로 `Return` 형식 매개변수를 지정해야 한다.

이 세 가지를 모두 사용하면 모든 클래스에 대해 가장 일반적인 방식으로 입력 메서드와 출력 메서드를 설명할 수 있다.

> **노트**: 이 글을 쓰는 현재, 타입스크립트의 ECMAScript 데코레이터는 비교적 새로운 기능이다. 보통 시간이 흐르면서 형식이 개선되므로 여기서 제공하는 형식 정보는 이미 개선되었을 수 있음을 감안하자.

### 필드 데코레이터 추가

또한 `constructor` 메서드를 호출하기 전에 클래스 필드와 관련 초깃값도 기록하려 한다.

```ts
class Toggler {
  @logField #toggled = false;

  @log
  toggle() {
    this.#toggled = !this.#toggled;
  }
}
```

`ClassFieldDecoratorContext`에서 작동하는 `logField`라는 또 다른 데코레이터를 만들어 이 문제를 해결한다. 데코레이터 제안에서는 클래스 필드용 데코레이터를 다음과 같이 설명한다.

```ts
type ClassFieldDecorator = (
  value: undefined,
  context: {
    kind: 'field';
    name: string | symbol;
    access: { get(): unknown; set(value: unknown): void };
    static: boolean;
    private: boolean;
  },
) => (initialValue: unknown) => unknown | void;
```

값은 `undefined`다. 초깃값을 대체 메서드로 전달한다.

```ts
type FieldDecoratorFn = (val: any) => any;

function logField<Val>(value: undefined, context: ClassFieldDecoratorContext): FieldDecoratorFn {
  return function (initialValue: Val): Val {
    console.log(`Initializing ${context.name.toString()} to ${initialValue}`);
    return initialValue;
  };
}
```

### 함수 오버로드로 통합

한 가지 이상한 점이 있다. 왜 멤버의 종류에 따라 다른 데코레이터가 필요할까? `log` 데코레이터로 모든 것을 처리할 수 있어야 하지 않을까? 데코레이터는 특정 데코레이터 컨텍스트에서 호출되며, `kind` 프로퍼티로 올바른 컨텍스트를 식별할 수 있다(3.2절에서 본 패턴). 따라서 컨텍스트에 따라 다른 데코레이터 호출을 수행하는 `log` 함수를 아주 쉽게 구현할 수 있지 않을까?

그렇기도 하고, 아니기도 하다. 물론 상황에 맞게 분기하는 래퍼 함수를 사용하는 방법이 가장 좋지만, 지금까지 살펴본 바와 같이 형식 정의가 아주 복잡하다. 함수 시그니처 하나로 이를 모두 처리하려면 많은 곳에서 `any`를 기본값으로 사용하지 않는 한 거의 불가능에 가깝다.

여러 개의 다른 함수 시그니처는 함수 오버로드 문제를 일으킨다. 따라서 가능한 모든 데코레이터에 적용할 하나의 함수 서명을 찾는 대신 필드 데코레이터와 메서드 데코레이터 등에 대응하는 오버로드를 만든다.

```ts
function log<This, Args extends any[], Return>(
  value: (this: This, ...args: Args) => Return,
  context: ClassMethodDecoratorContext,
): (this: This, ...args: Args) => Return;

function log<Val>(value: Val, context: ClassFieldDecoratorContext): FieldDecoratorFn;

function log(value: any, context: ClassMethodDecoratorContext | ClassFieldDecoratorContext) {
  if (context.kind === 'method') {
    return logMethod(value, context);
  } else {
    return logField(value, context);
  }
}
```

모든 실제 코드를 `if` 브랜치에 끼워 넣는 대신 원래의 메서드를 호출한다. `logMethod`나 `logField` 함수를 모듈에 추가한 다음 `log`만 익스포트하면 두 메서드를 노출하지 않을 수 있다.

> **팁**: 데코레이터 형식은 많으며 각자가 조금씩 다른 다양한 필드를 포함한다. `lib.decorators.d.ts`의 형식 정의도 훌륭하지만, 조금 더 자세한 정보가 필요하다면 TC39에서 원본 데코레이터 제안서(https://github.com/tc39/proposal-decorators)를 확인하자. 모든 형식의 데코레이터와 관련한 광범위한 정보를 제공할 뿐만 아니라 빠진 퍼즐 조각을 완성하는 데 필요한 추가 타입스크립트 형식도 제공한다.

### 비동기 메서드 처리

마지막으로 해야 할 일이 하나 있다. 호출 전후 모든 로그를 기록하도록 `logMethod`를 조정한다. 반환값을 일시적으로 저장해 쉽게 이를 구현한다.

```ts
function logMethod<This, Args extends any[], Return>(
  value: (this: This, ...args: Args) => Return,
  context: ClassMethodDecoratorContext,
): (this: This, ...args: Args) => Return {
  return function (this: This, ...args: Args) {
    console.log(`calling ${context.name.toString()}`);
    const val = value.call(this, ...args);
    console.log(`called ${context.name.toString()}: ${val}`);
    return val;
  };
}
```

하지만 비동기 방식에서는 상황이 좀 더 흥미로워진다. 비동기 호출 시 `Promise`가 반환된다. `Promise` 자체는 이미 실행되었거나 실행이 나중으로 미뤄졌을 수 있다. 이는 이전의 구현을 고수한다면, 호출된 로그 메시지가 메서드가 실제로 값을 산출하기 전에 나타날 수 있음을 의미한다.

`Promise`가 결과를 도출한 후 다음에 로그 메시지를 연결해 이 문제를 해결할 수 있다. 그러려면 먼저 해당 메서드가 실제로 `Promise`인지 확인해야 한다. 자바스크립트의 프로미스는 `then` 메서드를 포함한다. 헬퍼 메서드에서 `then` 메서드 존재 여부를 확인한다.

```ts
function isPromise(val: any): val is Promise<unknown> {
  return typeof val === 'object' && val && 'then' in val && typeof val.then === 'function';
}
```

결과가 `Promise`인지에 따라 직접 기록할지 또는 지연 기록할지 결정한다.

```ts
function logMethod<This, Args extends any[], Return>(
  value: (this: This, ...args: Args) => Return,
  context: ClassMethodDecoratorContext,
): (this: This, ...args: Args) => Return {
  return function (this: This, ...args: Args) {
    console.log(`calling ${context.name.toString()}`);
    const val = value.call(this, ...args);
    if (isPromise(val)) {
      val.then((p: unknown) => {
        console.log(`called ${context.name.toString()}: ${p}`);
        return p;
      });
    } else {
      console.log(`called ${context.name.toString()}: ${val}`);
    }
    return val;
  };
}
```

데코레이터는 아주 복잡해질 수 있지만, 궁극적으로 자바스크립트와 타입스크립트의 클래스를 더 표현력 있게 만드는 유용한 도구다.

### 데코레이터 컨텍스트 형식 요약

다양한 데코레이터 컨텍스트 형식을 사용할 수 있다. `lib.decorator.d.ts`는 다음과 같은 데코레이터를 정의한다:

```ts
type ClassMemberDecoratorContext =
  | ClassMethodDecoratorContext
  | ClassGetterDecoratorContext
  | ClassSetterDecoratorContext
  | ClassFieldDecoratorContext
  | ClassAccessorDecoratorContext;

// 데코레이터에 제공된 데코레이터 컨텍스트 형식
type DecoratorContext = ClassDecoratorContext | ClassMemberDecoratorContext;
```

각 데코레이터의 이름에서 클래스 내의 대상을 정확히 읽을 수 있다.

> **추가 설명**: 데코레이터 컨텍스트의 주요 프로퍼티들:
>
> | 프로퍼티         | 설명                                                                              |
> | ---------------- | --------------------------------------------------------------------------------- |
> | `kind`           | 데코레이터 대상 유형 ("class", "method", "field", "getter", "setter", "accessor") |
> | `name`           | 멤버의 이름 (string \| symbol)                                                    |
> | `static`         | 정적 멤버인지 여부                                                                |
> | `private`        | 비공개 멤버인지 여부                                                              |
> | `access`         | 멤버에 접근하기 위한 get/set 메서드                                               |
> | `addInitializer` | 초기화 시 실행할 함수 등록                                                        |
