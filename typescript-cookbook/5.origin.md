조 건 부 형 식
이 장 에 서 는 타 입 스 크 립 트 의 전 용 기 능 인 조 건 부 형 식 ( c o n d i t i o n a l y p e 을 살 펴 본 다 . 조 건 부 형 식 을 이
용 하 면 하 위 형 식 확 인 을 기 반 으 로 형 식 을 선 택 할 수 있 으 므 로 형 식 공 간 을 자 유 롭 게 이 동 하
고 , 인 터 페 이 스 와 함 수 시 그 니 처 를 좀 더 유 연 하 게 원 하 는 방 식 으 로 설 계 할 수 있 다 .
조 건 부 형 식 을 이 용 하 면 필 요 할 때 바 로 형 식 을 만 들 수 있 다 . 놀 라 움 과 멋 짐 이 공 존 하 는 깃 허
브 이 슈 ( h t t p s : / / o r e i l . l y / i g p h a ) 에 서 보 여 주 듯 이 , 조 건 부 형 식 덕 분 에 타 입 스 크 립 트 의 형 식
시 스 템 튜 링 u n g 이 완 벽 해 진 다 . 너 무 많 은 기 능 이 주 어 진 나 머 지 정 말 로 필 요 한 형 식 이 무 엇 인
지 에 집 중 하 지 못 한 채 막 다 른 길 에 다 다 르 거 나 이 해 하 기 가 너 무 힘 든 형 식 을 만 드 는 상 황 이
발 생 할 수 있 다 . 이 책 에 서 는 조 건 부 형 식 을 사 용 하 는 방 법 을 자 세 히 살 펴 보 며 , 우 리 가 하 는 일
이 실 제 로 원 하 는 목 표 로 이 어 지 는 지 를 항 상 재 평 가 할 것 이 다 .
이 장 은 다 른 장 보 다 내 용 이 적 은 편 이 다 . 이 는 조 건 부 형 식 과 관 련 해 다 룰 내 용 이 적 어 서 가 아
니 라 오 히 려 그 반 대 다 . 실 제 로 이 후 장 들 에 서 조 건 부 형 식 을 어 떻 게 활 용 할 수 있 는 지 살 펴 본
다 . 이 장 에 서 는 조 건 부 형 식 의 핵 심 에 집 중 하 고 형 식 과 관 련 해 사 용 할 용 어 를 정 리 한 다 .
5 장 조 건 부 형 식 1 9 7
5 . 1 복 잡 한 함 수 시 그 니 처 관 리 하 기
문 제 매 개 변 수 와 반 환 형 식 이 다 양 한 함 수 를 구 현 하 려 한 다 . 모 든 가 능 성 을 함 수 오 버 로 드 로 충 당 하 자 니
상 황 이 너 무 복 잡 하 다 .
해 결 조 건 부 형 식 을 이 용 해 매 개 변 수 와 반 환 형 식 의 규 칙 집 합 을 정 의 한 다 .
논 의 사 용 자 정 의 입 력 에 기 반 해 특 정 속 성 을 레 이 블 로 표 시 하 는 소 프 트 웨 어 를 개 발 하 는 중
이 라 고 가 정 하 자 . 다 양 한 필 터 작 업 과 검 색 을 지 원 하 도 록 S t r i n g L a b e L , N u m b e r L a b e l 을 구 분
한 다 .
type StringLabel = {
name: string;
type NumberLabel = {
id: number;
사 용 자 입 력 은 문 자 열 이 나 숫 자 중 한 가 지 다 . c r e a t e L a b e L 함 수 는 기 본 형 식 을 입 력 으 로 받
아 s t r i n g L a b e 1 이 나 N u m b e r L a b e l 객 체 중 하 나 를 만 들 어 반 환 한 다 .
function createLabel(input: number | string): NumberLabel | StringLabel {
i f (typeof input === "number") {
return { id: input };
} else {
return { name: input };
}
}
기 본 기 능 은 완 성 했 지 만 형 식 이 너 무 넓 다 . n u m b e r 를 입 력 하 면 N u m b e r L a b e l 이 반 환 되 는 데 ,
c r e a t e L a b e l 의 형 식 은 여 전 히 N u m b e r L a b e l i S t r i n g L a b e l 이 다 . 이 문 제 를 어 떻 게 해 결 하
야 할 까 ? 2 . 6 절 에 서 배 운 함 수 오 버 로 드 기 법 을 활 용 해 명 확 하 게 형 식 관 계 를 정 의 하 는 함 수 를
추 가 할 수 있 다 .
1 9 8 실 무 로 통 하 는 타 입 스 크 립 트
function createLabel(input: number): NumberLabel;
function createLabel(input: string): StringLabel;
function createLabel(input: number / s t r i n g ) : NumberLabel | StringLabel 1
if (typeof input === "number") {
return { id: input };
} else {
return { name: input };
}
}
각 오 버 로 드 정 의 는 사 용 방 식 에 따 른 형 식 을 정 의 하 지 만 , 가 장 마 지 막 정 의 는 함 수 본 문 을 구
현 하 는 데 필 요 한 형 식 을 정 의 한 다 . c r e a t e L a b e l 함 수 로 s t r i n g 을 전 달 해 S t r i n g L a b e l 을
얻 거 나 n u m b e r 를 전 달 해 N u m b e r L a b e l 을 얻 는 다 . S t r i n g L a b e l 과 N u m b e r L a b e l 은 함 수 외 부
에 서 사 용 할 수 있 는 형 식 이 다 .
하 지 만 미 리 입 력 형 식 을 충 분 히 좁 힐 수 없 는 상 황 이 라 면 현 재 함 수 에 서 문 제 가 발 생 한 다 . 현
재 함 수 는 n u m b e r 또 는 s t r i n g 일 수 있 는 입 력 을 허 용 하 지 않 는 다 .
function inputToLabel(input: string | number) {
return createLabel(input);
/ /
1 / 이 호 출 과 일 치 하 는 오 버 로 드 가 없 습 니 다 .
1 / 오 버 로 드 1 / 2 ( ' ( i n p u t : n u m b e r ) : N u m b e r L a b e l ' ) 에 서 다 음 오 류 가
1 / 발 생 했 습 니 다 .
1 / ' s t r i n g ! n u m b e r " 형 식 의 인 수 는 ' n u m b e r ' 형 식 의 매 개 변 수 에
/ / 할 당 될 수 없 습 니 다 .
1 / ' s t r i n g ' 형 식 은 ' n u m b e r ' 형 식 에 할 당 할 수 없 습 니 다 .
1 / 오 버 로 드 2 / 2 ( i n p u t : s t r i n g ) : S t r i n g L a b e l ' ) 에 서 다 음 오 류 가
1 / 발 생 했 습 니 다 .
1 / ' s t r i n g : n u m b e r ' 형 식 의 인 수 는 ' s t r i n g ' 형 식 의 매 개 변 수 에
/ / 할 당 될 수 없 습 니 다 .
1 / ' n u m b e r ' 형 식 은 ' s t r i n g ' 형 식 에 당 할 수 없 습 니 다 . t s ( 2 7 6 9 )
}
아 주 넓 은 입 력 형 식 을 허 용 하 는 또 다 른 오 버 로 드 를 추 가 해 이 문 제 를 해 결 한 다 .
function createLabel (input: number): NumberLabel;
function createLabel(input: string): StringLabel;
function createLabel(input: number | string): NumberLabel | StringLabel;
5 장 조 건 부 형 식 1 9 9
function createLabel(input: number | string): NumberLabel | StringLabel {
i f (typeof input === "number") {
return { id: input };
} e l s e i
return { name: input };
}
}
벌 써 세 개 의 오 버 로 드 함 수 와 이 기 능 의 가 장 기 본 기 능 을 설 명 하 는 함 수 시 그 니 처 정 의 를 포
함 해 네 개 의 정 의 를 추 가 했 다 . 문 제 는 지 금 부 터 상 황 이 더 나 빠 질 수 있 다 는 점 이 다 .
현 재 함 수 가 기 존 의 S t r i n g L a b e L , N u m b e r L a b e l 객 체 를 복 제 할 수 있 도 록 확 장 하 려 한 다 . 이
를 지 원 하 려 면 오 버 로 드 를 더 추 가 해 야 한 다 .
function createLabel (input: number): NumberLabel;
function createLabel(input: string): StringLabel;
function createLabel(input: StringLabel): StringLabel;
function createLabel(input: NumberLabel): NumberLabel;
function createLabel(input: string | StringLabel): StringLabel;
function createLabel(input: number | NumberLabel): NumberLabel;
function createLabel(
input: number | string | StringLabel | NumberLabel
) : NumberLabel | StringLabel;
function c r e a t e L a b e l
input: number | s t r i n g | StringLabel | NumberLabel
) : NumberLabel | StringLabel {
i f (typeof input === "number") {
return { id: input };
} else i f (typeof input === "string") {
return { name: input };
} else if ("id" in input) {
return { id: input.id };
3 else {
return { name: input.name };
}
}
형 식 힌 트 를 어 떻 게 사 용 하 느 냐 에 따 라 함 수 오 버 로 드 개 수 가 줄 어 들 거 나 늘 어 난 다 . 어 쨌 든 한
가 지 확 실 한 점 은 다 양 성 을 지 원 할 수 록 더 복 잡 한 함 수 시 그 니 처 가 필 요 하 다 는 사 실 이 다 .
2 0 0 실 무 로 통 하 는 타 입 스 크 립 트
이 런 상 황 에 서 는 타 입 스 크 립 트 의 조 건 부 형 식 이 라 는 도 구 를 활 용 하 면 좋 다 . 조 건 부 형 식 을 이
용 하 면 서 브 형 식 검 사 결 과 에 따 라 형 식 을 선 택 할 수 있 다 . 정 해 진 제 네 릭 형 식 매 개 변 수 가 특
정 하 위 형 식 인 지 묻 고 , 그 렇 다 면 t r u e 분 기 에 서 해 당 형 식 을 반 환 하 며 그 렇 지 않 다 면 f a l s e
분 기 에 서 해 당 형 식 을 반 환 한 다 .
예 를 들 어 다 음 은 입 력 매 개 변 수 T 가 s t r i n g ( 모 든 문 자 열 또 는 특 정 문 자 열 ) 의 하 위 형 식 이 면
T 형 식 을 반 환 하 며 그 렇 지 않 으 면 n e v e r 를 반 환 하 는 예 다 .
type IsString<T> = T extends string ? T : never;
type A = IsString<string>; / / string
type B = IsString<"hello" | "world">; / / string
type C = IsString<1000>; / / never
타 입 스 크 립 트 는 자 바 스 크 립 트 의 삼 항 연 산 자 문 법 을 그 대 로 빌 렸 다 . 따 라 서 타 입 스 크 립 트 에 서
는 이 를 이 용 해 특 정 조 건 이 유 효 한 지 검 사 할 수 있 다 . 하 지 만 타 입 스 크 립 트 형 식 시 스 템 은 프
로 그 래 밍 언 어 에 서 아 는 일 반 적 인 집 합 조 건 을 활 용 하 지 않 고 , 입 력 형 식 의 값 이 검 사 대 상 집
합 에 포 함 되 는 지 만 확 인 한 다 .
이 도 구 를 이 용 해 G e t L a b e l < T > 라 부 르 는 조 건 부 형 식 을 구 현 한 다 . 입 력 이 s t r i n g 이 나
S t r i n g L a b e l 중 하 나 인 지 검 사 한 다 . 검 사 결 과 가 참 이 면 S t r i n g L a b e l 을 반 환 하 고 그 렇 지 않
으 면 N u m b e r L a b e l 을 반 환 한 다 .
type GetLabel<T> = T extends string | StringLabel ? StringLabel : NumberLabel;
이 형 식 은 입 력 문 자 열 , S t r i n g L a b e l , n u m b e r L a b e l , N u m b e r L a b e l 이 e l s e 분 기 에 있 는 지 만
확 인 한 다 . N u m b e r L a b e L 을 반 환 할 수 있 는 입 력 형 식 을 검 사 하 는 조 건 부 형 식 을 기 존 조 건 부
형 식 에 중 첩 하 면 조 금 더 완 벽 한 코 드 가 된 다 .
type GetLabel<T> = T extends string | StringLabel
? StringLabel
: T extends number | NumberLabel
? NumberLabel
: never;
5 장 조 건 부 형 식 2 0 1
이 제 지 금 까 지 만 든 제 네 릭 을 활 용 한 다 . C r e a t e L a b e l 에 모 든 가 능 한 입 력 형 식 으 로 제 한 된 새
로 운 제 네 릭 형 식 매 개 변 수 T 를 추 가 한 다 . 이 매 개 변 수 T 는 G e t L a b e l < T > 의 입 력 으 로 사 용 되
며 알 맞 은 반 환 형 식 을 생 산 한 다 .
function createLabel<T extends number | s t r i n g | StringLabel | NumberLabel>(
i n p u t : T
): GetLabelT> {
i f (typeof input === "number") {
return i i d : input a s GetLabel<T>;
} e l s e i f (typeof input === "string") {
return { name: input } as GetLabel<T>;
} else i f ("id" i n input) {
return { id: input.id y as GetLabel<T>;
} else {
return { name: input.name } as GetLabel<T>;
}
}
이 렇 게 한 행 의 코 드 로 모 든 가 능 한 형 식 조 합 을 처 리 할 준 비 를 마 쳤 으 며 , g e t L a b e l 에 서 올 바
른 형 식 을 얻 을 수 있 게 되 었 다 .
코 드 를 조 금 더 자 세 히 살 펴 보 면 반 환 형 식 과 관 련 해 형 식 확 인 작 업 이 조 금 더 필 요 함 을 알 수
있 다 . 안 타 깝 게 도 타 입 스 크 립 트 에 서 제 네 릭 및 조 건 부 형 식 을 사 용 할 때 는 적 절 한 흐 름 제 어
분 석 을 할 수 없 다 . 약 간 의 형 식 어 서 션 을 사 용 해 타 입 스 크 립 트 에 현 재 올 바 른 반 환 형 식 을 처
리 하 고 있 음 을 알 릴 수 있 다 .
조 건 부 형 식 을 가 진 함 수 시 그 니 처 를 기 존 의 넓 은 형 식 을 갖 던 함 수 의 오 버 로 드 로 추 가 하 는 방
법 도 있 다 .
function createLabel<T extends number | string | StringLabel | NumberLabel>(
input: T
) : GetLabel<T>;
function createLabel(
input: number | string | StringLabel | NumberLabel
): NumberLabel | StringLabel {
if (typeof input === "number") {
r e t u r n { i d : input };
3 else if (typeof input === "string") {
return { name: input };
2 0 2 실 무 로 통 하 는 타 입 스 크 립 트
3 else i f ("id" in input) {
return { id: input.id };
} else {
return { name: input.name };
}
}
이 런 방 식 으 로 입 력 에 따 라 정 확 히 어 떤 결 과 를 얻 는 지 바 깥 세 계 에 알 려 주 는 유 연 한 형 식 을
얻 는 다 . 구 현 측 면 에 서 도 넓 은 형 식 집 합 을 활 용 해 완 전 한 유 연 성 을 얻 는 다 .
그 렇 다 면 모 든 상 황 에 함 수 오 버 로 드 보 다 는 조 건 부 형 식 을 사 용 하 는 편 이 좋 다 는 말 일 까 ? 그
렇 진 않 다 . 1 2 . 7 절 에 서 는 함 수 오 버 로 드 를 사 용 하 는 편 이 더 좋 은 상 황 을 설 명 한 다 .
5 . 2 n e v e r 로 거 르 기
문 제 다 양 한 형 식 을 포 함 하 는 유 니 온 이 있 지 만 , 이 대 신 문 자 열 의 모 든 하 위 형 식 이 필 요 하 다 .
해 결 분 배 조 건 부 형 식 을 이 용 해 올 바 른 형 식 으 로 거 른 다 .
논 의 제 이 쿼 리 a u c y 같 은 프 레 임 워 크 를 재 구 현 하 는 예 전 코 드 가 애 플 리 케 이 션 에 남 아 있 다 고
가 정 하 자 . H T M L E L e m e n t 형 식 의 객 체 에 클 래 스 명 을 추 가 또 는 제 거 하 거 나 이 벤 트 리 스 너 를 이
벤 트 로 바 인 딩 하 는 헬 퍼 함 수 를 보 유 한 E l e m e n t L i s t 와 같 은 기 능 도 존 재 한 다 .
인 덱 스 를 이 용 해 목 록 의 각 요 소 에 접 근 할 수 있 다 . 퍼 티 키 로 E l e m e n t L i s t 의 형 식 을 설 명 할 수 있 다 .
숫 자 인 덱 스 접 근 형 식 과 일 반 문 자 열 프 로
type ElementList = {
addClass: (className: string) => ElementList;
removeClass: (className: string) => ElementList;
on: (event: string, callback: (ev: Event) => void) => ElementList;
length: number;
[x: number]: HTMLElement;
5 장 조 건 부 형 식 2 0 3
유 연 한 인 터 페 이 스 를 갖 도 록 자 료 구 조 를 설 계 했 다 . 즉 , a d d C L a s s 나 r e m o v e C L a s s 같 은 메 서
드 를 호 출 하 면 기 존 객 체 가 반 환 되 므 로 메 서 드 를 연 쇄 호 출 할 수 있 다 .
다 음 은 이 들 메 서 드 의 예 제 구 현 코 드 다 .
1 / 발 췌 시 작
addClass: function (className: string): ElementList {
for ( l e t i = 0 ; i < this. length; i++) {
this[i].classList.add(className);
}
return this;
} ,
removeClass: function (className: string): ElementList {
for (let i = 0; i < this. length; i++) {
this[i].classList.remove(className);
}
return this;
on: function (event: string, callback: (ev: Event) => void): ElementList {
for (let i = 0; i < this. length; i++) {
this[i]-addEventListener(event, callback);
}
return this;
} ,
1 / 발 췌 끝
A r r a y , N o d e L i s t 같 은 내 장 컬 렉 션 의 확 장 덕 분 에 H T M L E L e m e n t 객 체 집 합 을 쉽 게 조 작 할 수
있 다 .
declare const myCollection: ElementList;
myCollection
-addClass("toggle-off")
-removeClass ("toggle-on")
•on("click", (e) → > (});
이 제 제 이 쿼 리 구 현 을 유 지 보 수 해 야 하 는 데 , 요 소 에 직 접 접 근 하 는 동 작 은 안 전 하 지 않 다 는
사 실 을 발 견 했 다 . 애 플 리 케 이 션 의 일 부 가 직 접 요 소 를 바 꿀 수 있 으 므 로 E l e m e n t L i s t 자 료 구
조 를 주 의 해 서 설 계 하 지 않 는 다 면 어 디 에 서 상 황 이 바 뀌 었 는 지 알 아 내 기 가 쉽 지 않 다 .
2 0 4 실 무 로 통 하 는 타 입 스 크 립 트
myCollection[1].classList. toggle("toggle-on");
이 미 너 무 많 은 기 능 이 의 존 하 고 있 는 기 존 라 이 브 러 리 코 드 는 바 꾸 기 어 려 우 므 로 , E l e m e n t L i s t 를 P r o x y 로 감 싸 기 로 한 다 .
기 존 의
P r o x y 는 원 본 대 상 객 체 와 접 근 을 어 떻 게 처 리 할 지 정 의 하 는 핸 들 러 객 체 를 인 수 로 받 는 다 .
다 음 은 프 로 퍼 티 키 의 형 식 이 s t r i n g 이 고 , 숫 자 를 표 현 하 는 문 자 열 이 아 닌 상 황 에 서 만 읽 기
전 용 으 로 접 근 을 허 용 하 는 P r o x y 예 다 .
const safeAccessCollection = new Proxy(myCollection, {
get(target, property) {
i f (
typeof property === "string" &
property in target &
' " + parseInt(property) !== property
return target[property as keyof typeof target];
}
return undefined; 3) ;
노 트 P r o x y 의 핸 들 러 객 체 는 오 직 문 자 열 이 나 심 볼 프 로 퍼 티 만 받 는 다 . 0 과 같 은 숫 자 로 인 덱 스 접 근 을 시 도
하 면 자 바 스 크 립 트 는 이 를 문 자 열 0 " 으 로 변 환 한 다 .
자 바 스 크 립 트 에 서 는 문 제 가 없 는 정 상 동 작 이 지 만 , 타 입 스 크 립 트 에 서 는 형 식 이 맞 지 않 는 다 .
P r o x y 생 성 자 의 반 환 형 식 은 E L e m e n t L i s t 이 므 로 숫 자 인 덱 스 접 근 은 그 대 로 유 지 된 다 .
1 / 타 입 스 크 립 트 로 는 동 작 하 지 만 자 바 스 크 립 트 에 서 는 오 류 발 생
safeAccessCollection[0].classList.toggle("toggle-on");
새 형 식 을 정 의 해 서 숫 자 인 덱 스 접 근 을 허 용 하 지 않 는 객 체 를 처 리 하 고 있 음 을 타 입 스 크 립 트
에 알 려 야 한 다 .
5 장 조 건 부 형 식 2 0 5
E l e m e n t L i s t 의 키 를 살 펴 보 자 . K e y o f 연 산 자 를 사 용 하 면 E l e m e n t L i s t 형 식 의 객 체 에 서 저
공 하 는 모 든 접 근 메 서 드 의 유 니 온 형 식 을 얻 는 다 .
1 / " a d d C L a s s " | " r e m o v e C l a s s " : " o n " i " l e n g t h " ! n u m b e r 로 해 석 됨
type ElementListKeys = keyof ElementList;
따 라 서 결 과 유 니 온 은 네 문 자 열 과 n u m b e r 를 포 함 한 다 . 이 유 니 온 을 이 용 해 문 자 열 이 아 닌 모
든 것 을 제 거 하 는 조 건 부 형 식 을 만 든 다 .
type JustStrings<T> = T extends s t r i n g ? T : never;
J u s t S t r i n g s < T > 를 분 배 조 건 부 형 식 ( i s t r i h u i v e c o n d i t o n a l t y p e 이 라 부 른 다 . T 는 객 체 나 배 열 에 감 싸 지
지 않 은 상 태 이 므 로 타 입 스 크 립 트 는 유 니 온 의 조 건 부 형 식 을 조 건 부 형 식 의 유 니 온 으 로 처 리
한 다 . 결 과 적 으 로 타 입 스 크 립 트 는 유 니 온 T 의 모 든 멤 버 에 같 은 조 건 검 사 를 수 행 한 다 .
예 제 에 서 는 k e y o f E l e m e n t L i s t 의 모 든 멤 버 에 이 동 작 을 적 용 해 다 음 과 같 은 결 과 가 나 타 난 다 .
type JustElementListStrings =
I "addClass" extends string? "addClass" : never
I "removeClass" extends string ? "removeClass" : never
I "on" extends string? "on" : never
"length" extends string? "length" : never
I number extends s t r i n g ? number : never;
f a l s e 분 기 로 빠 지 는 유 일 한 조 건 은 바 로 마 지 막 조 건 에 서 n u m b e r 가 s t r i n g 의 하 위 형 식 인 지
검 사 하 는 행 뿐 이 다 ( 물 론 참 이 될 수 없 다 ) . 모 든 조 건 을 해 석 한 결 과 로 새 유 니 온 형 식 이 탄 생
한 다 .
i never;
type JustElementListStrings =
i "addClass"
I "removeClass"
| "on"
/ "length"
2 0 6 실 무 로 통 하 는 타 입 스 크 립 트
n e v e r 를 유 니 온 에 사 용 하 면 n e v e r 가 사 라 진 다 . 가 능 한 값 이 없 는 집 합 을 값 의 집 합 과 유 니 온
으 로 연 결 하 면 값 만 남 기 때 문 이 다 .
type JustElementListStrings =
/ "addClass"
"removeClass"
"on"
| "length";
이 렇 게 안 전 하 게 접 근 할 수 있 는 키 목 록 을 얻 었 다 ! P i c k 헬 퍼 함 수 로 s t r i n g 형 식 의 모 든 키
만 가 져 와 서 E l e m e n t L i s t 의 상 위 형 식 을 만 든 다 .
type SafeAccess = Pick<ElementList, JustStrings<keyof ElementList>>;
편 집 기 로 결 과 형 식 을 확 인 해 보 면 원 하 던 결 과 와 같 음 을 확 인 할 수 있 다 .
type SafeAccess = {
addClass: (className: string) => ElementList;
removeClass: (className: string) → ElementList;
on: (event: string, callback: (ev: Event) => void) => ElementList;
length: number;
{
이 형 식 을 S a f e A c c e s s C o l l e c t i o n 의 애 너 테 이 션 으 로 추 가 해 보 자 . 하 위 형 식 을 상 위 형 식 에
할 당 할 수 있 으 므 로 타 입 스 크 립 트 는 이 시 점 부 터 s a f e A c c e s s C o l L e c t i o n 을 숫 자 인 덱 스 접
근 이 불 가 능 한 형 식 으 로 취 급 한 다 .
const safeAccessCollection: Pick<
ElementList,
JustStrings<keyof ElementList>

> = new Proxy(myCollection, {
> get(target, property) {
> i f (
> typeof property === "string" &
> property in target &&
> " ' + parseInt(property) !== property
> ) {
> 5 장 조 건 부 형 식 2 0 7
> return target[property as keyof typeof target];
> return undefined;
> } ,
> } ) ;
> s a f e A c c e s s C o l L e c t i o n 에 서 요 소 에 접 근 하 려 시 도 하 면 타 입 스 크 립 트 는 오 류 를 일 으 킨 다 .
> safeAccessCollection[1].classList.toggle("toggle-on");
> 1 / ^ 1 ' 형 식 의 식 을 ' P i c k s E L e m e n t L i s t , a d d C l a s s " i " r e m o v e C l a s s " i " o n " !
> 1 1 " l e n g t h " > " 인 덱 스 형 식 에 사 용 할 수 없 으 므 로 요 소 에 암 시 적 으 로
> / ' a n y ' 형 식 이 있 습 니 다 .
> 'Pick«ElementList, "addClass" | "removeClass | 'on | " l e n g t h
> 1 1 속 성 이 없 습 니 다 . t s ( 7 0 5 3 )
> 이 렇 게 필 요 한 기 능 을 완 성 했 다 . 분 배 조 건 부 형 식 은 유 니 온 멤 버 를 바 꾸 는 힘 을 제 공 한 다 .
> 5 . 3 절 에 서 는 내 헬 퍼 형 식 을 활 용 하 는 다 른 예 제 를 소 개 한 다 .
> 5 3 k i n d 로 요 소 그 룹 화 하 기
> 문 제 4 . 5 절 의 G r o u p 형 식 은 동 작 에 는 문 제 가 없 지 만 , 그 룹 의 각 항 목 의 형 식 이 너 무 넓 다 .
> 해 결 E x t r a c t 헬 퍼 형 식 을 이 용 해 유 니 온 형 식 에 서 올 바 른 멤 버 를 선 택 한 다 .
> 논 의 3 . 1 절 과 4 . 5 절 의 장 난 감 가 게 예 제 로 돌 아 가 보 자 . 모 든 가 능 한 값 의 정 보 를 정 확 히 얻 을
> 수 있 도 록 구 별 된 유 니 온 형 식 을 이 용 해 잘 설 계 된 모 델 로 시 작 한 다 .
> type ToyBase = {
> name: string;
> description: string;
> minimumAge: number;
> type BoardGame = ToyBase & {
> kind: "boardgame";
> 2 0 8 실 무 로 통 하 는 타 입 스 크 립 트
> players: number;
> type Puzzle = ToyBase & {
> kind: "puzzle";
> pieces: number;
> type Doll = ToyBase & {
> kind: "doll";
> material: "plush" | "plastic";
> type Toy = Doll / Puzzle | BoardGame;
> 그 리 고 T o y 에 서 G r o u p e d T o y s 라 는 형 식 을 도 출 했 는 데 , G r o u p e d T o y s 는 k i n d 프 로 퍼 티 의 유 니
> 온 형 식 멤 버 를 매 핑 된 형 식 의 프 로 퍼 티 키 ( 각 프 로 퍼 티 의 형 식 은 T o y [ ] ) 로 취 한 다 .
> type GroupedToys = {
> [k in Toy"kind"]]?: Toy[];
> 제 네 릭 을 이 용 해 다 양 한 시 나 리 오 에 서 재 사 용 할 수 있 는 G r o u p C o l l e c t i o n , S e l e c t o r > 라
> 는 헬 퍼 형 식 을 정 의 했 다 .
> type Group<
> Collection extends Record<string, any>,
> Selector extends keyof Collection
> = {
> [K in Collection[Selector]]: Collection[];
> type GroupedToys = Partial<Group<Toy, "kind"»>;
> 헬 퍼 형 식 은 잘 동 작 하 지 만 한 가 지 문 제 가 있 다 . 생 성 된 형 식 을 확 인 해 보 면 G r o u p < C o l l e c t i o n ,
> S e L e c t o r > 은 T o y 유 니 온 형 식 의 구 별 자 를 잘 선 택 하 지 만 , 모 든 프 로 퍼 티 는 아 주 넓 은 T o y [ ]
> 를 가 리 킨 다 .
> 5 장 조 건 부 형 식 2 0 9
> type GroupedToys = {
> boardgame?: Toy[] | undefined;
> puzzle?: Toyl] | undefined;
> doll?: Toyl] / undefined;
> 이 정 보 는 충 분 하 지 않 다 . 예 를 들 어 b o a r d g a m e 의 실 제 형 식 은 B o a r d G a m e [ ] 임 에 도
> b o a r d g a m e 은 T o y [ ] 를 가 리 킨 다 . p u z z L e 과 d o L l 을 포 함 해 컬 렉 션 에 추 가 하 는 모 든 장 난 감 에
> 같 은 일 이 발 생 한 다 . 실 제 로 는 다 음 과 같 은 형 식 이 어 야 한 다 .
> type GroupedToys = {
> boardgame?: BoardGame[] / undefined;
> puzzle?: Puzzle[] | undefined;
> doll?: Doll[] / undefined;
> } ;
> C o l l e c t i o n 유 니 온 형 식 에 서 관 련 멤 버 를 추 출 해 서 이 를 달 성 할 수 있 다 . 다 행 히 E x t r a c t < T ,
> U > 라 는 헬 퍼 형 식 을 이 용 할 수 있 는 데 , T 는 컬 렉 션 이 며 U 는 T 의 일 부 다 .
> 다 음 은 E x t r a c t < T , U > 의 정 의 다 .
> type Extract<T, U> = T extends U ? T : never;
> 조 건 에 서 T 는 다 른 객 체 로 감 싸 지 않 은 네 이 키 드 형 식 ( m a k d t p e ( T 는 분 배 조 건 부 형 식 ) 이 므 로
> 타 입 스 크 립 트 는 T 의 각 멤 버 가 U 의 하 위 형 식 인 지 확 인 하 며 , 그 렇 다 면 유 니 온 형 식 에 이 멤 버
> 를 유 지 한 다 . 어 떻 게 이 기 능 을 이 용 해 T o y 에 서 올 바 른 장 난 감 그 룹 을 선 택 할 수 있 을 까 ?
> T o y 에 서 D O L L 을 선 택 하 는 상 황 을 생 각 해 보 자 . D o l l 은 여 러 프 로 퍼 티 를 포 함 하 는 데 , 그 중 에
> 서 k i n d 프 로 퍼 티 는 다 른 형 식 과 구 별 해 주 는 역 할 을 한 다 . T o y 에 서 D o L L 형 식 을 찾 으 려 면
> { k i n d : " d o L l " } 을 포 함 하 는 형 식 을 추 출 하 면 된 다 .
> type ExtractedDoll = Extract<Toy, { kind: "doll" }>;
> 분 배 조 건 부 형 식 에 서 유 니 온 의 조 건 부 형 식 은 조 건 부 형 식 의 유 니 온 이 므 로 다 음 예 제 처 럼 U
> 로 T 의 모 든 멤 버 를 검 사 한 다 .
> 2 1 0 실 무 로 통 하 는 타 입 스 크 립 트
> type ExtractedDoll =
> BoardGame extends { kind: "doll" } ? BoardGame : never |
> Puzzle extends { kind: "doll" } ? Puzzle : never I
> Doll extends { kind: "doll" } ? Doll : never;
> B o a r d G a m e 과 P u z z l e 모 두 { k i n d : d o L L " } 의 하 위 형 식 이 아 니 므 로 이 들 은 n e v e r 로 해 석
> 된 다 . 하 지 만 D o l L 은 { k i n d : d o L L " } 의 하 위 형 식 이 므 로 D o L L 로 해 석 된 다 .
> type ExtractedDoll = never | never | Doll;
> n e v e r 에 유 니 온 동 작 을 수 행 하 면 n e v e r 가 사 라 진 다 . 따 라 서 결 과 형 식 은 D o L L 이 다 .
> type ExtractedDoll = Doll;
> 원 하 던 기 능 을 얻 었 다 . G r o u p 헬 퍼 형 식 을 확 인 해 보 자 . 다 행 히 그 룹 컬 렉 션 에 서 특 정 형 식 을
> 추 출 하 는 데 필 요 한 기 능 이 이 미 있 다 .
> • C o l L e c t i o n 자 체 는 T o y 로 치 환 될 플 레 이 스 홀 더 다 .
> • S e l e c t o r 의 구 별 자 프 로 퍼 티 는 " k i n d " 로 치 환 된 다 .
> • 추 출 하 려 는 구 별 자 형 식 은 문 자 열 이 며 G r o u p : K 에 서 매 핑 될 프 로 퍼 티 키 도 문 자 열 이 다 .
> G r o u p C o l l e c t i o n , S e l e c t o r > 에 서 E x t r a c t s T o y , { k i n d : d o L L " } > 의 제 네 릭 버 전 은
> 다 음 과 같 다 .
> type Group<
> Collection extends Record<string, any>,
> Selector extends keyof Collection
> [K in Collection[Selector]]: Extract‹Collection, { [P in Selector]: K }>[];
> C o l l e c t i o n 을 T o y 로 , S e L e c t o r 를 " k i n d " 로 바 꾸 면 다 음 과 같 은 의 미 다 .
> 5 장 조 건 부 형 식 2 1 1
> [K in Collection[Selector]]
> T o y [ " k i n d " ] 의 각 멤 버 ( " b o a r d g a m e " ' , " p u z z l e " , " d o L L " ) 를 새 객 체 형 식 의 프 로 퍼 티
> 키 로 취 한 다 .
> Extract<Collection, .›
> C o l l e c t i o n ( T o y 의 유 니 온 형 식 ) 에 서 추 출 한 각 멤 버 는 · · 의 하 위 형 식 이 다 .
> { [P in Selector]: K }
> S e l e c t o r ( 예 제 에 서 는 " k i n d " ) 의 각 멤 버 를 반 복 하 면 서 알 맞 은 객 체 형 식 을 만 든 다 . 예 를
> 들 어 프 로 퍼 티 키 가 " b o a r d g a m e " 이 면 " b o a r d g a m e " 을 가 리 키 는 객 체 를 , " p u z z l e " 이 면
> " p u z z l e " 을 가 리 키 는 객 체 를 만 든 다 .
> 이 런 방 식 으 로 프 로 퍼 티 키 를 이 용 해 알 맞 은 T o y 의 멤 버 를 선 택 한 다 . 이 제 다 음 과 같 은 결 과 를
> 예 상 할 수 있 다 .
> type GroupedToys = Partial<Group<Toy, "kind">>;
> 1 / 다 음 으 로 해 석 됨
> type GroupedToys = {
> boardgame?: BoardGamel] | undefined;
> puzzle?: Puzzle[] | undefined;
> doll?: Doll[] | undefined;
> } ;
> 멋 지 다 ! 이 제 형 식 이 훨 씬 깔 끔 해 졌 으 며 보 드 게 임 을 선 택 했 을 때 퍼 즐 을 처 리 해 야 할 필 요 가
> 없 다 . 하 지 만 새 로 운 문 제 가 몇 가 지 발 생 했 다 .
> g r o u p 의 프 로 퍼 티 는 아 주 세 부 적 인 형 식 을 가 리 키 지 만 , 타 입 스 크 립 트 는 t o y 가 잠 재 적 으 로 모
> 든 장 난 감 이 될 수 있 다 고 생 각 하 는 점 이 문 제 다 . 세 가 지 방 법 중 하 나 로 이 문 제 를 해 결 할 수
> 있 다 .
> 범 위 첫 째 , 각 멤 버 를 개 별 적 으 로 확 인 한 다 . 타 입 스 크 립 트 는 t o y 를 아 주 넓 은 형 식 으 로 간 주 하 므 로
> 를 재 정 리 한 다 .
> 를 좁 혀 관 계 2 1 2 실 무 로 통 하 는 타 입 스 크 립 트
> function groupToys(toys: Toy[]): GroupedToys {
> const groups: GroupedToys = 1J;
> for ( l e t toy o f t o y s ) ‹
> switch (toy.kind) {
> case "boardgame" :
> groups[toy.kind] = groups[toy.kind] ?? [J;
> groups[toy.kind]?.push(toy);
> break;
> case " d o l l " :
> groups[toy.kind] = groups[toy.kind] ?? [];
> groups[toy.kind]?.push(toy);
> break;
> case "puzzle":
> groups [toy.kind] = groups[toy.kind] ?? [];
> groups[toy.kind]?.push(toy);
> break;
> }
> }
> return groups;
> }
> 원 하 는 대 로 동 작 은 하 지 만 중 복 되 거 나 반 복 되 는 코 드 가 많 아 졌 다 .
> 둘 째 , 타 입 스 크 립 트 가 인 덱 스 접 근 을 보 장 하 도 록 형 식 어 서 션 을 이 용 해 g r o u p s [ t o y . k i n d ] 의
> 형 식 을 넓 힌 다 .
> function groupToys(toys: Toy[]): GroupedToys {
> const groups: GroupedToys = 1};
> for ( l e t toy of toys) {
> (groups[toy.kind] as Toy[]) = groups[toy.kind] ?? [];
> (groups[toy.kind] as Toy[])?.push(toy);
> }
> r e t u r n groups;
> }
> 이 제 마 지 막 G r o u p e d T o y s 예 제 처 럼 동 작 하 며 , 형 식 어 서 션 을 이 용 해 형 식 을 바 꿔 서 형 식 오
> 류 를 제 거 했 음 을 알 린 다 .
> 셋 째 , 약 간 간 접 적 인 방 법 을 활 용 한 다 . t o y 를 그 룹 에 직 접 추 가 하 지 않 고 헬 퍼 함 수
> a s s i g n ( 제 네 릭 활 용 ) 을 이 용 한 다 .
> 5 장 조 건 부 형 식 2 1 3
> function groupToys(toys: Toy[]): GroupedToys {
> const groups: GroupedToys = t};
> for (let toy of toys) {
> assign(groups, toy.kind, toy);
> }
> return groups;
> }
> function assign<T extends Recordstring, K[]>, K>
> groups: T,
> key: keyof T,
> value: K
> ) {
> 1 / 사 용 할 수 없 으 면 초 기 화
> groups [key] = groups[key] ?? [];
> groups [key]? - push(value);
> }
> 타 입 스 크 립 트 의 제 네 릭 치 환 을 이 용 해 유 니 온 T o y 의 올 바 른 멤 버 로 좁 혔 다 .
> • g r o u p s 는 T O I 며 R e c o r d s t r i n g , K [ ] > 다 . K [ ] 는 잠 재 적 으 로 넓 은 형 식 이 다 .
> • k e y 는 T 와 관 계 를 갖 는 다 ( T 의 K e y o f 프 로 퍼 티 ) .
> • v a l u e 는 K 형 식 이 다 .
> 세 가 지 함 수 의 모 든 매 개 변 수 는 서 로 관 련 되 어 있 으 며 형 식 관 계 를 설 계 한 방 식 덕 분 에 안 전
> 하 게 g r o u p s [ k e y ] 로 접 근 하 고 배 열 에 v a l u e 를 푸 시 할 수 있 다 .
> a s s i g n 을 호 출 할 때 각 매 개 변 수 의 형 식 은 우 리 가 설 정 한 제 네 릭 형 식 제 약 을 수 행 한 다 . 더 자
> 세 한 사 항 은 1 2 . 6 절 에 서 확 인 할 수 있 다 .
> 2 1 4 실 무 로 통 하 는 타 입 스 크 립 트
> 5 . 4 특 정 객 체 프 로 퍼 티 삭 제 하 기
> 문 제 프 로 퍼 티 명 이 아 니 라 형 식 에 기 반 해 프 로 퍼 티 를 선 택 하 는 객 체 헬 퍼 형 식 을 만 들 려 고 한 다 .
> 해 결 프 로 퍼 티 키 를 매 핑 할 때 조 건 부 형 식 과 형 식 어 서 션 으 로 거 른 다 .
> 논 의 타 입 스 크 립 트 에 서 는 다 른 형 식 에 기 반 해 새 형 식 을 만 들 수 있 으 므 로 파 생 형 을 일 일 이 유
> 지 보 수 하 지 않 고 최 신 으 로 유 지 할 수 있 다 . 4 . 5 절 에 서 관 련 예 제 를 살 펴 봤 다 . 다 음 시 나 리 오 에 서
> 는 프 로 퍼 티 의 형 식 에 기 반 해 기 존 객 체 형 식 을 조 정 하 려 한 다 . 다 음 P e r s o n 형 식 을 살 펴 보 자 .
> type Person = {
> name: string;
> age: number;
> profession?: string;
> P e r s o n 형 식 은 두 개 의 문 자 열 ( p r o f e s s i o n , n a m e ) 과 숫 자 ( a g e ) 를 포 함 한 다 . 이 제 다 음 처 럼
> 두 개 의 문 자 열 형 식 프 로 퍼 티 를 포 함 하 는 형 식 을 만 든 다 .
> type PersonStrings = {
> name: string;
> profession?: string;
> 타 입 스 크 립 트 는 프 로 퍼 티 명 으 로 거 르 는 동 작 을 수 행 하 는 헬 퍼 형 식 을 제 공 한 다 . 예 를 들 어 , 매
> 핑 된 형 식 P i c k T 〉 은 객 체 의 키 하 위 집 합 을 가 져 다 이 들 키 만 을 포 함 하 는 새 객 체 를 만 든 다 .
> type Pick<T, K extends keyof T> = {
> [P in K]: T[P];
> }
> / / " n a m e " 만 포 함
> type PersonName = Pick<Person, "name">;
> 1 / " n a m e " 과 " p r o f e s s i o n " 을 포 함
> type PersonStrings = Pick‹Person, "name" | "profession">;
> 5 장 조 건 부 형 식 2 1 5
> O m i t < T > 을 이 용 해 특 정 프 로 퍼 티 를 제 거 할 수 있 다 . 사 용 방 법 은 P i c k K T 〉 과 비 슷 하 지 만
> O m i t < T > 은 포 함 하 고 싶 지 않 은 프 로 퍼 티 집 합 으 로 매 핑 한 다 는 점 이 다 르 다 .
> type Omit<T, K extends string | number | symbol> = {
> [P in Exclude<keyof T, K>]: T[P];
> }
> 1 / a g e 제 거 . 따 라 서 " n a m e " 과 " p r o f e s s i o n " 포 함
> type PersonWithoutAge = Omit<Person, "age">;
> 이 름 이 아 니 라 형 식 에 따 라 올 바 른 프 로 퍼 티 를 선 택 하 려 면 이 와 비 슷 한 헬 퍼 형 식 을 만 들 어 야
> 한 다 . 이 헬 퍼 형 식 은 원 하 는 형 식 을 가 리 키 는 프 로 퍼 티 명 집 합 ( 동 적 으 로 생 성 됨 ) 을 매 핑 한
> 다 . 5 . 2 절 에 서 유 니 온 형 식 에 조 건 부 형 식 을 사 용 할 때 n e v e r 를 이 용 해 요 소 를 유 니 온 에 서 거
> 를 수 있 음 을 살 펴 봤 다 .
> 첫 번 째 시 도 로 P e r s o n 의 모 든 프 로 퍼 티 키 를 매 핑 하 면 서 P e r s o n [ K ] 가 원 하 는 형 식 의 하 위
> 형 식 인 지 검 사 한 다 . 그 렇 다 면 해 당 형 식 을 , 그 렇 지 않 으 면 n e v e r 를 반 환 한 다 .
> 1 / 아 직 미 완 성
> type PersonStrings = {
> [K in keyof Person]: Person[K] extends string ? Person[K] : never;
> 결 과 는 좋 아 보 이 지 만 한 가 지 문 제 가 있 다 . 검 사 하 는 형 식 들 이 유 니 온 소 속 이 아 니 라 매 핑 된
> 형 식 에 서 온 다 는 점 이 다 . 따 라 서 프 로 퍼 티 키 를 필 터 링 하 는 대 신 n e v e r 형 식 을 가 리 키 는 프 로
> 퍼 티 를 얻 는 다 . 결 과 적 으 로 특 정 프 로 퍼 티 는 설 정 할 수 없 게 된 다 .
> 형 식 을 u n d e f i n e d 로 설 정 하 므 로 프 로 퍼 티 를 선 택 형 으 로 취 급 하 는 방 법 도 있 다 . 하 지 만 3 . 1 1
> 절 에 서 배 웠 듯 이 , 빠 진 프 로 퍼 티 와 정 의 되 지 않 은 값 은 서 로 다 르 다 .
> 특 정 형 식 을 가 리 키 는 프 로 퍼 티 키 를 제 거 하 는 것 이 우 리 의 목 표 다 . 조 건 을 객 체 의 오 른 편 이
> 아 니 라 프 로 퍼 티 가 생 성 되 는 왼 편 에 추 가 해 서 이 를 달 성 할 수 있 다 .
> O m i t 형 식 과 마 찬 가 지 로 특 정 프 로 퍼 티 집 합 으 로 매 핑 해 야 한 다 . K e y o f P e r s o n 을 매 핑 할 때
> 형 식 어 서 션 으 로 프 로 퍼 티 키 의 형 식 을 바 꿀 수 있 다 . 일 반 형 식 어 서 션 처 럼 안 전 장 치 가 존 재
> 한 다 . 즉 , 형 식 어 서 션 은 프 로 퍼 티 키 의 경 계 내 로 만 설 정 할 수 있 다 .
> 2 1 6 실 무 로 통 하 는 타 입 스 크 립 트
> P e r s o n [ K ] 집 합 의 K 부 분 이 s t r i n g 형 식 인 지 어 서 션 으 로 확 인 한 다 . 참 이 면 K 를 유 지 하 고 , 그
> 렇 지 않 으 면 집 합 의 요 소 를 n e v e r 로 거 른 다 . n e v e r 가 객 체 의 왼 편 에 있 으 므 로 해 당 프 로 퍼 티
> 는 제 거 된 다 .
> type PersonStrings = {
> [K in keyof Person as Person[K] extends string? K : never]: Person[K];
> 이 런 방 식 으 로 문 자 열 값 을 가 리 키 는 프 로 퍼 티 만 선 택 한 다 . 다 만 ( u n d e f i n e d 도 가 능 한 값 에
> 포 함 되 므 로 ) 선 택 형 문 자 열 은 일 반 문 자 열 보 다 넓 다 는 사 실 을 기 억 하 자 . 유 니 온 형 식 을 이 용
> 해 선 택 형 프 로 퍼 티 도 유 지 한 다 .
> type PersonStrings = {
> [K in keyof Person as Person[K] extends string | undefined
> ? K
> : never]: Person[K];
> };
> 이 제 제 네 릭 형 식 을 만 든 다 . P e r s o n 을 0 , s t r i n g 을 T 로 치 환 해 S e l e c t < O , T > 형 식 을 만 든 다 .
> type Select<O, T> = 1
> [K in keyof 0 as O[K] extends T | undefined ? K : never]: 0[K];
> 3
> 새 헬 퍼 형 식 은 용 도 가 다 양 하 다 . 택 할 수 있 다 .
> 이 헬 퍼 를 사 용 해 객 체 형 식 에 서 특 정 형 식 의 프 로 퍼 티 를 선
> type PersonStrings = Select<Person, string>;
> type PersonNumbers = Select<Person, number>;
> 또 한 문 자 열 프 로 토 타 입 에 서 어 떤 함 수 가 숫 자 를 반 환 하 는 지 알 아 낼 수 도 있 다 .
> type StringFnsReturningNumber = Select‹String, (...args: any[]) > number›;
> 5 장 조 건 부 형 식 2 1 7
> R e m o v e < O , T > 는 S e l e c t < 0 , T > 와 반 대 로 동 작 하 는 헬 퍼 형 식 으 로 , 특 정 형 식 의 프 로 퍼 티 키
> 를 제 거 한 다 . 둘 은 t r u e 분 기 에 서 n e v e r 를 반 환 한 다 는 점 이 다 르 다 .
> type Remove<O, T> = {
> [K in keyof 0 as O[K] extends T i undefined? never : K]: 0[K];
> } ;
> type PersonWithoutStrings = Remove<Person, string>;
> 이 는 객 체 형 식 의 직 렬 화 버 전 을 만 들 때 특 히 유 용 하 다 .
> type User = {
> name: string;
> age: number;
> profession?: string;
> posts): string[];
> greeting(): string;
> 3
> type SerializeableUser = Remove<User, Function>;
> 키 를 매 핑 하 면 서 조 건 부 형 식 을 수 행 할 수 있 다 는 사 실 덕 분 에 폭 넓 은 범 위 의 헬 퍼 형 식 에 접
> 근 할 수 있 다 . 더 자 세 한 내 용 은 8 장 에 서 설 명 한 다 .
> 5 . 5 조 건 식 에 서 형 식 추 론 하 기
> 문 제 객 체 를 직 렬 화 할 때 직 렬 화 할 수 없 는 프 로 퍼 티 ( 예 : 함 수 ) 를 객 체 에 서 모 두 제 거 하 는 클 래 스 를 만 들
> 려 한 다 . 객 체 에 s e r i a L i z e 함 수 가 있 으 면 직 렬 화 중 인 객 체 대 신 함 수 의 반 환 값 을 사 용 한 다 . 이 를
> 어 떻 게 형 식 으 로 표 현 할 까 ?
> 해 결 재 귀 조 건 부 형 식 을 이 용 해 기 존 객 체 형 식 을 바 꾼 다 . s e r i a l i z e 를 구 현 하 는 객 체 에 는
> i n f e r 키 워 드 를 이 용 해 제 네 릭 형 식 을 구 체 적 형 식 으 로 고 정 한 다 .
> 2 1 8 실 무 로 통 하 는 타 입 스 크 립 트
> 논 의 자 료 구 조 나 객 체 를 저 장 하 거 나 전 달 할 수 있 는 형 식 으 로 변 환 하 는 작 업 을 직 렬 화
> s c i a l l a t i o n 라 한 다 . 자 바 스 크 립 트 객 체 의 데 이 터 를 디 스 크 에 저 장 했 다 가 나 중 에 다 시 비 직 렬 화 해
> 자 바 스 크 립 트 로 가 져 오 는 상 황 을 생 각 해 보 자 .
> 자 바 스 크 립 트 객 체 는 기 본 형 식 ( 예 : 문 자 열 , 숫 자 ) 뿐 아 니 라 복 합 형 식 ( 예 : 객 체 , 함 수 ) 을 지
> 원 한 다 . 특 히 함 수 는 데 이 터 를 포 함 하 지 않 지 만 동 작 ( 직 렬 화 할 수 없 음 ) 을 포 함 하 는 흥 미 로 운
> 대 상 이 다 . 자 바 스 크 립 트 객 체 에 서 함 수 를 제 거 해 서 직 렬 화 를 달 성 하 는 방 법 이 있 다 . 이 장 에 서
> 는 이 기 법 을 사 용 한 다 .
> P e r s o n 이 라 는 단 순 한 객 체 를 사 용 한 다 . P e r s o n 객 체 는 사 람 의 이 름 및 나 이 데 이 터 와 문 자 열
> 을 반 환 하 는 h e L L o 라 는 메 서 드 를 포 함 한 다 .
> type Person = {
> name: string;
> age: number;
> hello: () → string;
> P e r s o n 형 식 의 객 체 를 직 렬 화 해 보 자 . S e r i a l i z e r 클 래 스 는 빈 생 성 자 와 s e r i a l i z e 라 는 제
> 네 릭 함 수 를 포 함 한 다 . 여 기 서 클 래 스 가 아 닌 s e r i a l i z e 에 제 네 릭 형 식 매 개 변 수 를 추 가 했 음
> 에 주 목 하 자 . 이 덕 분 에 다 른 객 체 형 식 에 s e r i a l i z e 를 재 활 용 할 수 있 다 . 직 렬 화 작 업 의 결 과
> 는 S e r i a l i z e x T > 라 는 제 네 릭 형 식 을 갖 는 다 .
> class Serializer {
> constructor) t
> serialize<T>(obj: T): Serialize<T> {
> 1 / 구 현 중 . . .
> }
> }
> 구 현 은 뒤 에 서 설 명 하 고 지 금 은 S e r i a l i z e c T > 형 식 에 초 점 을 맞 춘 다 . 우 선 함 수 프 로 퍼 티 를
> 제 거 하 는 방 법 을 살 펴 보 자 . 5 . 4 절 에 서 살 펴 본 R e m o v e < O , T > 를 이 용 하 면 특 정 형 식 의 프 로 퍼
> 티 를 제 거 할 수 있 다 .
> 5 장 조 건 부 형 식 2 1 9
> type Remove<O, T> = 1
> [K in keyof 0 as O[K] extends T | undefined ? never : K]: 0[K];
> type Serialize<T> = Remove<T, Function>;
> 첫 번 째 작 업 을 간 단 하 게 마 쳤 고 한 단 계 수 준 깊 이 의 객 체 에 완 벽 하 게 동 작 한 다 . 하 지 만 실 생
> 활 의 객 체 는 이 보 다 더 복 잡 하 다 . 예 를 들 어 P e r s o n 에 는 함 수 를 포 함 하 는 다 른 객 체 가 있 을 수
> 있 다 .
> type Person = {
> name: string;
> age: number;
> profession: {
> title: string;
> level: number;
> printProfession: () → void;
> hello: () → string;
> 각 프 로 퍼 티 가 다 른 객 체 의 프 로 퍼 티 인 지 확 인 하 고 그 렇 다 면 다 시 S e r i a l i z e c T > 를 적 용 한 다 .
> N e s t S e r i a l i z a t i o n 이 라 는 매 핑 된 형 식 은 조 건 부 형 식 에 서 각 프 로 퍼 티 가 o b j e c t 형 식 인 지
> 확 인 하 고 , t r u e 분 기 에 서 직 렬 화 된 버 전 의 형 식 을 반 환 하 고 f a l s e 분 기 에 서 는 형 식 을 그 대 로
> 반 환 한 다 .
> type NestSerialization<T> = {
> [K in keyof T]: T[K] extends object ? Serialize<T[K]> : T[K];
> 3;
> N e s t S e r i a l i z a t i o n 에 서 S e r i a l i z e c T > 에 R e m o v e < T , F u n c t i o n > 를 감 싸 서 S e r i a l i z e c T 〉 형 식 을
> 재 정 의 한 다 . 결 과 적 으 로 재 귀 형 식 이 만 들 어 진 다 . S e r i a l i z e < > 는 N e s t S e r i a l i z a t i o n c T 〉
> 를 사 용 하 고 , 다 시 N e s t S e r i a l i z a t i o n < T 〉 는 S e r i a L i z e < T > 를 사 용 하 는 형 태 다 .
> type Serialize<T> = NestSerialization<Remove<T, Function>>;
> 2 2 0 실 무 로 통 하 는 타 입 스 크 립 트
> 타 입 스 크 립 트 는 형 식 재 귀 를 특 정 깊 이 까 지 처 리 할 수 있 다 . 이 때 N e s t S e r i a l i z a t i o n 에 형
> 식 재 귀 탈 출 조 건 이 존 재 한 다 .
> 이 렇 게 직 렬 화 형 식 을 완 성 했 다 ! 이 제 함 수 구 현 은 형 식 선 언 을 자 바 스 크 립 트 로 변 환 하 는 과 정
> 이 다 . 프 로 퍼 티 가 객 체 인 모 든 프 로 퍼 티 가 있 으 면 s e r i a l i z e 를 다 시 호 출 한 다 . 그 외 에 함 수
> 가 아 닌 프 로 퍼 티 는 그 대 로 유 지 한 다 .
> c l a s s S e r i a l i z e r {
> constructor) 1}
> serialize<T>(obj: T): Serialize<T> {
> const ret: Record<string, any> = 0};
> for (let k in obj) {
> if (typeof obj[k] === "object") {
> ret[k] = this.serialize(obj[k]);
> } else if (typeof obj[k] != "function") {
> ret[k] = obj [k];
> }
> }
> return ret as Serialize<T>;
> }
> }
> s e r i a l i z e 안 에 서 새 객 체 를 생 성 해 야 하 므 로 처 음 에 는 아 주 넓 은 R e c o r d k s t r i n g , a n y > 로
> 시 작 한 다 . 그 리 고 생 성 된 객 체 를 반 환 형 식 에 맞 도 록 어 서 션 으 로 조 정 한 다 . 새 객 체 를 만 들 때
> 흔 히 사 용 하 는 기 법 이 지 만 , 우 리 가 하 는 모 든 작 업 이 1 0 0 % 올 바 르 다 는 확 신 이 필 요 하 다 . 따 라
> 서 함 수 를 광 범 위 하 게 테 스 트 해 야 한 다 .
> 첫 번 째 구 현 을 완 성 했 으 므 로 P e r s o n 이 라 는 새 객 체 형 식 을 만 들 어 새 로 만 든 직 렬 화 함 수 로
> 전 달 해 보 자 .
> const person: Person = {
> name: "Stefan",
> age: 40,
> profession: {
> title: "Software Developer",
> level: 5,
> printProfession) {
> console. log(${this.title}, Level ${this. level}');
5 장 조 건 부 형 식 2 2 1
} ,
hello) {
return 'Hello ${this.name}*;
} ,
3 j
const serializer = new Serializer);
const serializedPerson = serializer.serialize(person);
console. log(serializedPerson);
결 과 는 예 상 대 로 다 . s e r i a l i z e d P e r s o n 형 식 은 메 서 드 와 함 수 정 보 를 포 함 하 지 않 는 다 .
s e r i a l i z e d P e r s o n 을 로 그 로 출 력 해 봐 도 모 든 메 서 드 와 함 수 가 사 라 졌 음 을 알 수 있 다 . 형 식
은 구 현 결 과 와 일 치 한 다 .
}
[LOG]: {
"name" : "Stefan",
"age": 40,
"profession": {
"title": "Software Developer",
"level": 5
}
하 지 만 아 직 작 업 이 끝 나 지 않 았 다 . S e r i a l i z e r 는 특 별 한 기 능 을 포 함 한 다 . 객 체 는
s e r i a l i z e 메 소 드 를 구 현 할 수 있 으 며 이 때 S e r i a l i z e r 는 직 렬 화 하 는 객 체 대 신 이 메 서 드
의 결 과 를 취 한 다 . P e r s o n 형 식 이 s e r i a L i z e 메 서 드 를 포 함 하 도 록 기 능 을 확 장 해 보 자 .
type Person = {
name: string;
age: number;
profession: {
title: string;
level: number;
printProfession: () => void;
3;
hello: ( ) → string;
serialize: () → string;
3;
2 2 2 실 무 로 통 하 는 타 입 스 크 립 트
const person: Person = {
name: "Stefan",
age: 40,
profession: {
title: "Software Developer",
level: 5,
printProfession) &
console. log S{this.title}, Level ${this.level}*);
3
} ,
hellol) {
return 'Hello ${this.name}';
serialize) {
return '${this.name}: ${this.profession.title} L${this.profession.level}\*;
> 3
> S e r i a l i z e c T > 을 조 금 바 꿔 야 한 다 . N e s t S e r i a l i z a t i o n 을 실 행 하 기 전 에 조 건 부 형 식 에 서
> 객 체 가 s e r i a L i z e 메 서 드 를 구 현 하 는 지 ( T 가 s e r i a l i z e 메 서 드 를 포 함 하 는 하 위 형 식 인 지 )
> 검 사 한 다 . 그 렇 다 면 이 는 직 렬 화 결 과 이 므 로 반 환 형 식 을 얻 는 다 .
> 이 제 i n f e r 키 워 드 를 사 용 할 때 가 되 었 다 . i n f e r 는 조 건 에 서 형 식 을 받 아 t r u e 분 기 에 서 형
> 식 매 개 변 수 로 사 용 한 다 . 조 건 이 참 이 면 발 견 된 형 식 을 취 해 서 제 공 하 도 록 타 입 스 크 립 트 에 지
> 시 한 다 .
> type Serialize<T> = T extends { serialize): infer R }
> ? R
> : NestSerialization<Remove<T, Function>>;
> 처 음 에 R 은 a n y 라 고 생 각 하 자 . P e r s o n 을 { s e r i a l i z e ( ) : a n y } 과 비 교 했 을 때 P e r s o n 은
> s e r i a l i z e 함 수 를 포 함 ( 유 효 한 하 위 형 식 ) 하 므 로 t r u e 분 기 로 점 프 한 다 . 하 지 만 a n y 는 넓
> 으 며 a n y 위 치 의 특 정 형 식 을 원 한 다 . i n f e r 키 워 드 는 정 확 한 형 식 을 선 택 할 수 있 다 . 따 라 서
> S e r i a l i z e c T > 를 다 음 처 럼 해 석 할 수 있 다 .
> • T 가 s e r i a L i z e 메 서 드 를 포 함 하 면 반 환 형 식 을 가 져 다 반 환 한 다 .
> • 그 렇 지 않 으 면 F u n c t i o n 형 식 의 모 든 프 로 퍼 티 를 깊 숙 이 d e e p y 제 거 하 면 서 직 렬 화 를 시 작 한 다 .
> 5 정 조 건 부 형 식 2 2 3
> 이 형 식 의 동 작 을 자 바 스 크 립 트 구 현 에 도 반 영 하 고 싶 다 . 몇 가 지 형 식 검 사 ( s e r i a l i z e 가 존
> 재 하 며 함 수 인 지 확 인 ) 를 한 다 음 이 를 호 출 한 다 . 이 함 수 가 반 드 시 존 재 해 야 하 므 로 타 입 스 크
> 립 트 는 명 시 적 으 로 형 식 을 보 호 하 도 록 요 구 한 다 .
> class Serializer {
> constructor () {}
> serialize<T>(obj: T): Serialize<T> {
> if (
> / / 객 체
> typeof obj === "object" &
> / / n u l l 아 님
> obj &&
> 1 / s e r i a l i z e 사 용 가 능
> "serialize" in obj &&
> 1 / 그 리 고 함 수 임
> typeof obj serialize === "function"
> {
> return obj serialize);
> }
> const ret: Record<string, any> = t};
> for (let k in obj) {
> if (typeof obj[k] === "object") {
> ret[k] = this.serialize(obj[k]);
> } else if (typeof obj[k] ! = "function") {
> ret[k] = obj[k];
> }
> }
> return ret as Serialize<T>;
> }
> }
> 이 제 s e r i a l i z e d P e r s o n 은 s t r i n g 이 며 예 상 했 던 결 과 를 얻 는 다 .
> [LOG]: "Stefan: Software Developer L5"
> 이 강 력 한 도 구 는 객 체 를 생 성 하 는 데 큰 도 움 을 준 다 . 선 언 형 메 타 언 어 , 즉 타 입 스 크 립 트 의 형
> 식 시 스 템 을 이 용 해 형 식 을 만 들 었 고 명 령 형 언 어 자 바 스 크 립 트 로 구 현 된 같 은 결 과 를 확 인 할
> 수 있 다 는 점 이 이 기 법 의 매 력 이 다 .
> 2 2 4 실 무 로 통 하 는 타 입 스 크 립 트
