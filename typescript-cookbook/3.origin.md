CHAPTER 3
형 식 시 스 템
2 장 에 서 는 자 바 스 크 립 트 코 드 의 표 현 력 을 높 이 는 데 사 용 할 수 있 는 기 본 기 능 을 배 웠 다 . 하 지
만 숙 련 된 자 바 스 크 립 트 개 발 자 라 면 지 금 까 지 배 운 타 입 스 크 립 트 의 기 본 형 식 과 애 너 테 이 션 이
앞 으 로 펼 쳐 질 유 연 한 미 래 의 일 부 에 지 나 지 않 음 을 알 것 이 다 .
타 입 스 크 립 트 의 목 표 는 자 바 스 크 립 트 코 드 를 명 확 하 게 만 드 는 것 이 며 이 과 정 에 서 자 바 스 크 립
트 의 유 연 성 을 훼 손 하 지 않 으 려 노 력 한 다 . 특 히 자 바 스 크 립 트 의 유 연 성 덕 분 에 개 발 자 들 이 수
백 만 이 사 랑 하 는 환 상 적 인 A P I 를 개 발 할 수 있 기 때 문 이 다 . 타 입 스 크 립 트 는 제 한 을 추 가 한 다
기 보 다 는 조 금 더 정 형 화 된 자 바 스 크 립 트 버 전 이 라 생 각 하 면 좋 다 . 타 입 스 크 립 트 의 형 식 시 스
템 세 계 로 들 어 가 보 자 .
이 장 에 서 는 형 식 을 생 각 하 는 데 사 용 할 정 신 적 모 델 을 개 발 한 다 . 필 요 에 따 라 값 집 합 을 어 떻
게 넓 게 또 는 좁 게 정 의 하 는 지 배 우 며 흐 름 제 어 로 이 들 의 영 역 을 어 떻 게 바 꾸 는 지 살 펴 본 다 .
또 한 구 조 적 형 식 시 스 템 을 활 용 하 는 방 법 과 규 칙 을 깨 야 하 는 시 기 도 배 운 다 .
이 장 은 타 입 스 크 립 트 기 초 와 고 급 형 식 기 법 사 이 에 존 재 하 는 다 리 역 할 을 제 공 한 다 . 숙 련 된
타 입 스 크 립 트 개 발 자 든 초 급 개 발 자 든 관 계 없 이 , 이 정 신 적 모 델 은 앞 으 로 등 장 할 내 용 의 밑 거
름 을 제 공 한 다 .
3 장 형 식 시 스 템 9 9
3 . 1 문 제 유 니 온 형 식 과 인 터 섹 션 형 식 으 로 데 이 터 모 델 링 하 기
타 입 스 크 립 트 로 묘 사 하 려 는 일 련 의 데 이 터 모 델 이 있 다 .
해 결 유 니 온 u n i o n 형 식 과 인 터 섹 션 m e r s e c i o n 형 식 으 로 데 이 터 를 모 델 링 하 고 특 정 변 형 은 리 터 럴
형 식 으 로 정 의 한 다 .
논 의 장 난 감 가 게 의 데 이 터 모 델 을 만 든 다 고 가 정 하 자 . 이 장 난 감 가 게 의 각 항 목 은 이 름 , 수
량 , 최 소 권 장 연 령 등 기 본 프 로 퍼 티 를 포 함 한 다 . 특 정 장 난 감 에 는 다 른 프 로 퍼 티 가 추 가 되 므
로 여 러 정 의 를 만 들 어 야 한 다 .
type BoardGame = {
name: string;
price: number;
quantity: number;
minimumAge: number;
players: number;
type Puzzle = 1
name: string;
price: number;
quantity: number;
minimumAge: number;
pieces: number;
type Doll = {
name: string;
price: number;
quantity: number;
minimumAge: number;
material: string;
3;
이 제 함 수 를 만 들 어 야 하 는 데 , 이 함 수 는 모 든 장 난 감 을 처 리 해 야 하 므 로 모 든 장 난 감 에 공 통
으 로 존 재 하 는 기 본 프 로 퍼 티 를 포 함 하 는 상 위 형 식 을 이 용 한 다 .
1 0 0 실 무 로 통 하 는 타 입 스 크 립 트
type ToyBase = {
name: string;
price: number;
quantity: number;
minimumAge: number;
} ;
function printToy(toy: ToyBase) {
/ * . . . * /
const d o l l : Doll = {
name: "Mickey Mouse",
price: 9.99,
quantity: 10000,
minimumAge: 2,
material: "plush",
p r i n t T o y ( d o l L ) ; 1 / 동 작 함
이 코 드 로 모 든 인 형 , 보 드 게 임 , 퍼 즐 을 출 력 할 수 있 지 만 한 가 지 문 제 가 있 다 . p r i n t T o y 에 서
원 래 장 난 감 의 일 부 정 보 를 잃 어 버 린 다 는 점 이 다 . 특 정 장 난 감 이 갖 는 정 보 는 잃 어 버 린 채 오
직 공 통 프 로 퍼 티 만 출 력 한 다 .
유 니 온 형 식 으 로 모 든 장 난 감 을 대 표 할 수 있 다 .
/ / 유 니 온 T o y
type Toy = Doll | BoardGame | Puzzle;
function printToy(toy: Toy) {
/ *
. . . * /
}
호 환 되 는 값 의 집 합 을 형 식 이 라 고 생 각 하 면 좋 다 . 애 너 테 이 션 이 있 든 없 든 타 입 스 크 립 트 는 각
값 이 특 정 형 식 과 호 환 되 는 지 확 인 한 다 . 객 체 라 면 객 체 형 식 에 정 의 된 추 가 프 로 퍼 티 의 값 도
여 기 에 포 함 된 다 . 추 론 기 능 을 통 해 추 가 프 로 퍼 티 값 은 구 조 적 형 식 시 스 템 의 하 위 형 식 으 로
할 당 된 다 . 하 위 형 식 의 값 은 상 위 형 식 집 합 의 일 부 이 기 도 하 다 .
3 장 형 식 시 스 템 1 0 1
유 니 온 형 식 은 집 합 의 모 음 이 다 . 호 환 되 는 여 러 값 이 모 여 더 넓 은 값 이 되 며 때 로 는 형 식 간 에
겹 치 는 부 분 도 존 재 한 다 . 예 를 들 어 m a t e r i a l , p l a y e r s 를 포 함 하 는 객 체 는 D o L L , B o a r d G a m e
과 호 환 된 다 . 3 . 2 절 에 서 이 부 분 을 자 세 히 살 펴 본 다 .
[ 그 림 3 - 1 ] 은 유 니 온 형 식 의 개 념 을 벤 다 이 어 그 램 으 로 표 현 한 다 . 집 합 개 념 이 이 상 황 에 잘
들 어 맞 는 다 .
Doll Puzzle
BoardGame
그 림 3 - 1 유 니 온 형 식 의 시 각 화 . 각 형 식 은 호 환 되 는 값 의 집 합 을 나 타 내 며 유 니 온 집 합 은 유 니 온 형 식 을 가 리 킨 다 .
기 본 형 으 로 어 디 에 서 나 유 니 온 형 식 을 만 들 수 있 다 .
function takesNumberOrString(value: number | string) {
/ * . . . 치
}
t a k e s N u m b e r o r s t r i n g ( 2 ) ; 1 / 동 작
t a k e s N u m b e r o r s t r i n g ( " H e l l o " ) ; 1 / 동 작
이 런 방 식 으 로 값 집 합 을 원 하 는 만 큼 넓 힌 다 .
장 난 감 가 게 코 드 에 는 중 복 되 는 부 분 도 있 다 . 바 로 T o y B a s e 프 로 퍼 티 가 반 복 된 부 분 이 다 .
T o y B a s e 를 각 유 니 온 파 트 의 기 본 으 로 삼 으 면 더 좋 을 것 이 다 . 인 터 섹 션 형 식 을 사 용 해 이 를
해 결 한 다 .
type ToyBase = {
name: string;
1 0 2 실 무 로 통 하 는 타 입 스 크 립 트
price: number;
quantity: number;
minimumAge: number;
} ;
1 / T o y B a s e 와 { p l a y e r s : n u m b e r } 의 인 터 섹 션
type BoardGame = ToyBase & {
players: number;
} ;
1 / T o y B a s e 와 { p i e c e s : n u m b e r } 의 인 터 섹 션
type Puzzle = ToyBase & {
pieces: number;
｝ ；
/ / T o y B a s e 와 { m a t e r i a l : s t r i n g } 의 인 터 섹 션
type Doll = ToyBase & {
material: string;
} ;
유 니 온 형 식 이 합 집 합 이 라 면 인 터 섹 션 형 식 은 교 집 합 에 해 당 한 다 . 인 터 섹 션 은 타 입 스 크 립 트 에
형 식 A 와 형 식 B 모 두 와 호 환 되 는 값 임 을 지 시 한 다 . 인 터 섹 션 형 식 은 두 형 식 모 두 에 있 는 프
로 퍼 티 만 포 함 ( 하 위 형 식 포 함 ) 하 므 로 더 좁 은 값 의 집 합 이 다 . [ 그 림 3 - 2 ] 는 인 터 섹 션 형 식 을
시 각 적 으 로 보 여 준 다 .
인 터 섹 션 형 식 도 기 본 형 을 사 용 할 수 있 지 만 별 효 과 는 기 대 할 수 없 다 . 예 를 들 어 s t r i n g &
n u m b e r 를 만 족 하 는 값 은 존 재 하 지 않 으 므 로 n e v e r 가 된 다 .
ToyBase Doll
{
material: string,
}
그 림 3 - 2 두 형 식 의 교 집 합 시 각 화 . 가 능 한 값 의 집 합 이 축 소 된 다 .
3 장 형 식 시 스 템 1 0 3
노 트 형 식 별 칭 이 나 인 터 섹 션 형 식 대 신 인 터 페 이 스 로 모 델 을 정 의 하 는 방 법 도 있 다 . 2 장 에 서 는 이 둘 의 차 이
점 을 확 인 했 으 며 무 엇 을 주 의 해 야 하 는 지 도 배 웠 다 . 예 를 들 어 B o a r d G a m e = T o y B a s e & { / * . . . * / } 라 는 형
식 을 i n t e r f a c e B o a r d G a m e e x t e n d s T o y B a s e { / * . . . * / } 로 표 현 할 수 있 다 . 하 지 만 유 니 온 형 식 을 인 터
페 이 스 로 정 의 할 수 는 없 다 . 대 신 여 러 인 터 페 이 스 의 유 니 온 은 정 의 할 수 있 다 .
이 처 럼 타 입 스 크 립 트 를 이 용 해 효 과 적 인 데 이 터 모 델 을 만 들 수 있 을 뿐 아 니 라 타 입 스 크 립 트
는 추 가 기 능 도 제 공 한 다 . 타 입 스 크 립 트 에 서 는 리 터 럴 값 을 리 터 럴 형 식 으 로 표 현 할 수 있 다 .
예 를 들 어 숫 자 1 이 라 는 형 식 을 정 의 할 수 있 는 데 , 이 는 오 직 1 이 라 는 값 과 호 환 되 는 형 식 이 다 .
type One = 1;
c o n s t o n e : O n e = 1 ; / / 다 른 값 은 할 당 할 수 없 음
이 를 리 터 럴 형 식 ( l i c r a l p 이 라 부 르 는 데 , 얼 핏 그 리 유 용 한 형 식 은 아 닌 것 처 럼 보 일 수 있 다 . 하
지 만 여 러 리 터 럴 형 식 을 유 니 온 으 로 만 들 때 유 니 온 형 식 을 활 용 할 수 있 다 . 예 를 들 어 D o L L
형 식 이 있 다 고 가 정 할 때 명 시 적 으 로 m a t e r i a l 값 을 설 정 할 수 있 다 .
type Doll = ToyBase & {
material: "plush" | "plastic";
تنه
function checkDoll(doll: Doll) {
if (doll-material === "plush") {
1 / p l u s h 재 질 의 인 형 에 필 요 한 작 업 수 행
} else 1
1 / " p l u s h " 이 외 의 d o l l . m a t e r i a l 은 " p l a s t i c " 뿐 이 므 로 다 른 선 택
1 / 사 항 이 없 음
}
}
이 처 럼 유 니 온 형 식 을 이 용 해 " p L u s h " 나 " p l a s t i c " 이 외 의 값 은 할 당 할 수 없 도 록 강 제 하 므
로 안 정 적 으 로 동 작 하 는 코 드 를 만 드 는 데 도 움 이 된 다 .
유 니 온 형 식 , 인 터 섹 션 형 식 , 리 터 럴 형 식 을 활 용 하 면 더 쉽 게 모 델 을 정 의 하 고 활 용 할 수 있 다 .
1 0 4 실 무 로 통 하 는 타 입 스 크 립 트
3 . 2 구 별 된 유 니 온 형 식 을 활 용 해 명 시 적 으 로 모 델 정 의 하 기
문 제 유 니 온 형 식 모 델 에 중 복 되 는 여 러 속 성 이 있 으 므 로 흐 름 제 어 에 서 구 별 하 기 가 번 거 롭 다 .
해 결 각 유 니 온 의 구 성 요 소 에 종 류 를 가 리 키 는 k i n d 프 로 퍼 티 를 문 자 열 리 터 럴 형 식 으 로 추
가 한 후 이 문 자 열 리 터 럴 의 내 용 을 확 인 한 다 .
논 의 사 용 할 3 . 1 절 에 서 만 든 것 과 비 슷 한 데 이 터 모 델 을 사 용 한 다 . 다 양 한 모 양 을 정 의 한 다 .
이 번 에 는 그 래 픽 소 프 트 웨 어 에 서
type Circle = {
radius: number;
type Square = {
x: number;
3;
type Triangle = {
x: number;
y: number;
type Shape = Circle | Triangle | Square;
이 세 가 지 형 식 은 서 로 비 슷 하 지 만 a r e a 함 수 는 이 들 을 어 려 움 없 이 구 별 한 다 .
function area(shape: Shape) {
i f ("radius" in shape) {
/ / s h a p e Circle
return Math.PI * shape.radius * shape.radius;
} else i f ("y" in shape) {
/ / s h a p e Triangle
return (shape. * shape.y) / 2;
} e l s e {
/ / s h a p e Square
return s h a p e . * shape.x;
}
}
3 장 형 식 시 스 템 1 0 5
코 드 는 제 대 로 동 작 하 지 만 약 간 의 문 제 가 있 다 . C i r c l e 은 r a d i u s 프 로 퍼 티 가 있 는 유 일 한 형
식 이 지 만 T r i a n g l e 과 S q u a r e 는 x 프 로 퍼 티 를 공 유 한 다 . S q u a r e 는 오 직 x 프 로 퍼 티 만 정 의 하
므 로 T r i a n g L e 은 S q u a r e 의 하 위 형 식 이 된 다 .
제 어 흐 름 에 서 하 위 형 식 을 구 별 하 는 프 로 퍼 티 y 를 먼 저 확 인 한 다 면 문 제 가 발 생 하 지 않 는 다 .
하 지 만 x 프 로 퍼 티 의 존 재 여 부 만 검 사 한 다 음 넓 이 를 구 한 다 면 T r i a n g l e 과 S q u a r e 를 같 은
방 식 으 로 계 산 하 는 오 류 가 발 생 한 다 .
또 한 S h a p e 을 확 장 하 기 어 려 운 문 제 도 있 다 . R e c t a n g L e 에 필 요 한 프 로 퍼 티 는 T r i a n g L e 의 프
로 퍼 티 와 같 다 .
type Rectangle = {
x : number;
y : number;
type Shape = Circle | Triangle | Square | Rectangle;
이 런 상 황 에 서 는 유 니 온 의 구 성 요 소 를 특 정 하 기 가 어 렵 다 . 유 니 온 의 각 구 성 요 소 를 구 별 하 려
면 구 성 요 소 가 무 엇 인 지 알 려 줄 수 있 도 록 식 별 하 는 프 로 퍼 티 를 모 델 에 추 가 해 야 한 다 .
k i n d 프 로 퍼 티 를 추 가 해 이 문 제 를 해 결 한 다 . k i n d 프 로 퍼 티 는 모 델 의 구 성 요 소 를 식 별 하 는
문 자 열 리 터 럴 형 식 을 저 장 한 다 .
3 . 1 절 에 서 살 펴 봤 듯 이 타 입 스 크 립 트 에 서 는 s t r i n g , n u m b e r , b i g i n t , b o o l e a n 등 의 기 본 형
에 서 파 생 한 특 정 값 으 로 하 위 형 식 을 만 들 수 있 다 . 즉 , 어 느 값 이 나 형 식 이 될 수 있 으 며 이
값 형 식 은 오 직 한 값 과 만 호 환 된 다 .
다 음 처 럼 k i n d 프 로 퍼 티 를 모 델 에 추 가 하 고 구 성 요 소 를 식 별 하 는 리 터 럴 형 식 을 할 당 한 다 .
type Circle = 1
radius: number;
kind: "circle";
type Square = {
x: number;
kind: "square";
1 0 6 실 무 로 통 하 는 타 입 스 크 립 트
};
type Triangle = {
x: number;
y: number;
kind: "triangle";
type Shape = Circle | Triangle | Square;
이 코 드 에 서 k i n d 를 문 자 열 로 설 정 하 지 않 고 " c i r c L e " , " S q u a r e " , " t r i a n g l e " 등 명 확 한 리
터 럴 형 식 으 로 설 정 했 다 . 이 들 은 값 이 아 니 라 특 정 리 터 럴 문 자 열 과 만 호 환 되 는 형 식 이 다 .
k i n d 프 로 퍼 티 를 추 가 하 고 이 를 문 자 열 리 터 럴 형 식 으 로 설 정 하 므 로 유 니 온 형 식 의 구 성 요 소
를 명 확 하 게 식 별 한 다 . 이 들 리 터 럴 문 자 열 은 서 로 호 환 되 지 않 으 며 고 유 하 기 때 문 이 다 . 이 기
법 을 구 별 된 유 니 온 형 식 ( t i c i m i n a t e d u n i o n t p e 이 라 부 르 며 , 이 를 이 용 해 S h a p e 유 니 온 형 식 의 각 구
성 요 소 를 명 확 하 게 구 별 할 수 있 다 .
예 를 들 어 다 음 처 럼 s w i t c h 문 으 로 S h a p e 의 구 성 요 소 를 명 확 히 식 별 할 수 있 다 .
function area (shape: Shape) {
switch (shape.kind) {
case "circle": / / shape Circle
return Math.PI * shape.radius * shape.radius;
case "triangle": / / shape Triangle
return (shape. * shape.y) / 2;
case "square": / / s h a p e Square
return s h a p e . * shape.x;
d e f a u l t :
throw Error("not possible");
}
}
이 기 법 을 이 용 하 면 S h a p e 이 구 체 적 으 로 무 엇 인 지 명 확 하 게 알 수 있 으 며 이 후 에 발 생 할 변 화
에 도 쉽 게 대 응 할 수 있 다 ( 3 . 3 절 에 서 자 세 히 살 펴 봄 ) .
3 장 형 식 시 스 템 1 0 7
3 . 3 a s s e r t N e v e r 함 수 를 이 용 해 완 전 검 사 하 기
문 제 시 간 이 지 나 면 서 유 니 온 형 식 에 새 구 성 요 소 를 추 가 하 는 상 황 이 발 생 했 다 . 에 서 고 쳐 야 한 다 .
관 련 된 부 분 을 모 든 코 드
해 결 a s s e r t N e v e r 함 수 로 모 든 남 은 케 이 스 에 어 서 션 을 적 용 해 모 든 상 황 을 확 인 하 도 록 완
전 검 시 ( w h a u s t i v e n e s c h e c k 를 수 행 한 다 .
논 의 이 전 에 살 펴 본 예 제 를 확 인 하 자 .
type Circle = {
radius: number;
kind: "circle";
type Square = 1
x: number;
kind: "square";
type Triangle = {
x: number;
y: number;
kind: "triangle";
type Shape = Circle | Triangle | Square;
function area(shape: Shape) {
switch (shape.kind) {
case "circle": / / shape Circle
return Math.PI * shape.radius * shape.radius;
case "triangle": // shape Triangle
return (shape. * shape.y) / 2;
case "square": / / s h a p e Square
return s h a p e . * shape.x;
default:
throw Error("not possible");
}
}
1 0 8 실 무 로 통 하 는 타 입 스 크 립 트
구 별 된 유 니 온 을 이 용 해 유 니 온 의 각 구 성 요 소 를 구 별 할 수 있 다 . a r e a 함 수 는 S w i t c h - c a s e
구 로 각 상 황 을 구 별 한 다 . k i n d 프 로 퍼 티 의 문 자 열 리 터 럴 형 식 덕 분 에 형 식 간 의 겹 치 는 부 분
을 제 거 했 다 .
모 든 가 능 한 옵 션 을 확 인 한 다 음 에 는 d e f a u l t 케 이 스 에 서 오 류 를 던 지 는 데 , 이 는 절 대 일 어 날
수 없 는 상 황 임 을 가 리 킨 다 . 코 드 의 형 식 이 제 대 로 동 작 한 다 면 이 오 류 가 발 생 하 지 않 는 다 .
심 지 어 형 식 시 스 템 조 차 도 d e f a u l t 케 이 스 는 불 가 능 함 을 알 려 준 다 . d e f a u l t 케 이 스 에 S h a p e
를 추 가 한 다 음 그 위 로 마 우 스 를 대 보 면 타 입 스 크 립 트 는 S h a p e 의 형 식 이 n e v e r 라 고 알 려 준 다 .
function area(shape: Shape) {
switch (shape.kind) {
case "circle": / / shape Circle
return Math.PI * shape.radius * shape.radius;
case "triangle": / / s h a p e Triangle
return (shape. * shape.y) / 2;
case "square": / / s h a p e Square
return shape. * shape.x;
default:
console.error ("Shape not defined:", shape); / / shape never
throw Error("not possible");
}
}
n e v e r 는 흥 미 로 운 형 식 이 다 . n e v e r 는 타 입 스 크 립 트 의 바 닥 형 식 b o o m b 으 로 , 형 식 계 층 의 가
장 아 래 에 위 치 한 다 . a n y , u n k n o w n 은 모 든 가 능 한 값 을 가 리 키 지 만 n e v e r 와 호 환 되 는 값 은 존
재 하 지 않 는 다 . n e v e r 는 이 름 이 가 리 키 듯 이 빈 집 합 이 다 . 어 떤 값 이 n e v e r 라 면 이 는 오 류 가
발 생 했 다 는 의 미 다 .
S h a p e 에 R e c t a n g l e 을 추 가 하 면 d e f a u l t 의 s h a p e 오 류 가 사 라 진 다 .
type Rectangle = {
x: number;
y: number; kind: "rectangle";
type Shape = C i r c l e | Tr i a n g l e | Square | Rectangle;
3 장 형 식 시 스 템 1 0 9
function area (shape: Shape) {
switch (shape.kind) 1
case "circle": / / s h a p e Circle
return Math.PI * shape.radius * shape.radius;
case "triangle": / / s h a p e Triangle
return (shape. * shape.y) / 2;
case "square": / / s h a p e Square
return s h a p e . * shape.x;
d e f a u l t :
console.error ("Shape not defined:"
throw Error("not possible");
, shape); / / shape≥ Rectangle
}
제 어 흐 름 은 자 신 이 할 수 있 는 최 선 의 추 측 을 수 행 한 다 . 타 입 스 크 립 트 는 모 든 시 점 에 특 정 값
의 형 식 을 정 확 하 게 파 악 한 다 . d e f a u l t 분 기 에 서 S h a p e 는 R e c t a n g l e 형 식 일 수 밖 에 없 다 .
실 수 로 가 능 한 형 식 확 인 을 빠 뜨 렸 을 때 타 입 스 크 립 트 가 이 를 알 려 준 다 면 좋 지 않 을 까 ? 이 제
s h a p e o R e c t a n g l e 일 때 d e f a u l t 가 실 행 된 다 . 하 지 만 d e f a u l t 케 이 스 는 시 스 템 관 점 에 서
불 가 능 한 상 황 을 처 리 하 는 것 이 주 용 도 이 므 로 이 를 바 꾸 지 않 는 것 이 좋 다 .
현 재 상 황 도 좋 지 않 지 만 , 여 러 장 소 에 서 완 전 검 사 패 턴 을 사 용 하 기 시 작 하 면 상 황 이 더 악 화
한 다 . 특 정 케 이 스 검 사 를 쉽 게 놓 칠 수 있 으 며 이 는 소 프 트 웨 어 충 돌 로 이 어 질 수 있 기 때 문 이 다 .
모 든 선 택 사 항 을 완 벽 하 게 검 사 했 는 지 확 인 하 는 헬 퍼 함 수 를 만 들 어 이 문 제 를 해 결 할 수 있
다 . 이 함 수 는 n e v e r 를 인 수 로 받 는 다 .
function assertNever(value: never) {
console.error("Unknown value", value);
throw Error("Not possible");
}
보 통 n e v e r 는 일 어 나 지 말 아 야 할 상 황 이 발 생 했 음 을 암 시 한 다 . 예 제 에 서 는 n e v e r 를 함 수 의
형 식 애 너 테 이 션 으 로 사 용 했 다 . ' 대 체 어 떤 값 을 함 수 인 수 로 전 달 해 야 하 는 걸 까 ? ' 라 는 궁 금 증
이 생 길 것 이 다 . 이 함 수 에 는 어 떤 값 도 인 수 로 전 달 할 수 없 다 . 이 함 수 를 호 출 하 지 않 는 것 이
정 상 이 다 .
1 1 0 실 무 로 통 하 는 타 입 스 크 립 트
하 지 만 기 존 의 d e f a u l t 케 이 스 를 a s s s e r t N e v e r 로 바 꾸 어 형 식 시 스 템 이 모 든 호 환 가 능 한
값 ( 값 이 없 는 상 황 도 포 함 ) 을 확 인 하 도 록 강 제 할 수 있 다 .
function area (shape: Shape) {
switch (shape.kind) i
case "circle": // shape Circle
return Math.PI * shape.radius * shape.radius;
case "triangle": // shape Triangle
return ( s h a p e . * shape.y) / 2;
case "square": / / shape Square
return s h a p e . * shape.x;
default: / / shape= Rectangle
assertNever (shape);
^ - - ' R e c t a n g l e ' 형 식 의 인 수 는 ' n e v e r ' 형 식 의 매 개 변 수 에
/ /
할 당 될 수 없 습 니 다 . t s ( 2 3 4 5 )
}
}
완 성 했 다 ! 사 용 할 수 있 는 모 든 선 택 사 항 을 완 벽 하 게 검 사 하 지 않 으 면 물 결 선 이 나 타 난 다 . 타
입 스 크 립 트 가 모 든 상 황 을 검 사 하 도 록 강 제 하 므 로 R e c t a n g l e 이 라 는 새 로 운 클 래 스 를 추 가 할
때 함 께 바 꿔 야 할 모 든 코 드 를 쉽 게 확 인 할 수 있 다 .
function area (shape: Shape) {
switch (shape.kind) {
case "circle": / / shape Circle
return Math.PI * shape.radius * shape.radius;
case "triangle": / / s h a p e Triangle
return (shape. * shape.y) / 2;
case "square": // shape Square
return shape. * shape.x;
case "rectangle":
return shape. * shape.y;
d e f a u l t : / / shape= never
a s s e r t N e v e r ( s h a p e ) ; 1 / s h a p e 를 a s s e r t N e v e r 로 전 달 할 수 있 음 !
}
}
n e v e r 는 호 환 되 는 값 이 없 으 며 형 식 시 스 템 에 서 불 가 능 한 상 황 을 가 리 키 는 데 사 용 하 지 만 , 이
예 제 에 서 살 펴 봤 듯 이 가 능 한 상 황 을 확 인 하 도 록 강 제 하 는 형 식 애 너 테 이 션 으 로 활 용 할 수 있
3 장 형 식 시 스 템 1 1 1
다 . 형 식 은 호 환 되 는 값 의 집 합 이 며 제 어 흐 름 으 로 호 환 되 는 값 을 넓 히 거 나 좁 힐 수 있 다 는 사
실 을 활 용 해 a s s e r t N e v e r 같 은 함 수 를 만 들 었 다 . 이 함 수 는 코 드 의 품 질 을 높 이 는 데 도 움 을
준 다 .
3 . 4 c o n s t 컨 텍 스 트 로 형 식 고 정 하 기
문 제 구 별 된 유 니 온 형 식 모 델 에 객 체 리 터 럴 을 할 당 할 수 없 다 .
해 결 형 식 어 서 션 과 c o n s t 컨 텍 스 트 n e x 로 리 터 럴 형 식 을 고 정 한 다 .
논 의 타 입 스 크 립 트 에 서 는 각 값 을 하 나 의 형 식 으 로 활 용 할 수 있 다 . 이 를 리 터 럴 형 식 이 라 부
르 며 , 리 터 럴 형 식 을 이 용 해 큰 집 합 을 몇 가 지 값 만 받 아 들 이 는 하 위 집 합 으 로 만 들 수 있 다 .
타 입 스 크 립 트 에 서 리 터 럴 형 식 은 특 정 값 을 가 리 킬 수 있 을 뿐 아 니 라 형 식 시 스 템 의 기 능 에
중 요 한 기 여 를 한 다 . L e t 이 나 c o n s t 로 기 본 형 식 의 값 을 할 당 할 때 이 점 이 명 확 하 게 드 러 난 다 .
L e t , c o n s t 로 선 언 한 변 수 에 값 을 두 번 할 당 하 면 타 입 스 크 립 트 는 이 를 두 가 지 다 른 형 식 으 로
추 론 한 다 . L e t 을 사 용 했 다 면 타 입 스 크 립 트 는 기 본 형 을 넓 히 는 방 향 으 로 추 론 한 다 .
l e t n a m e = ' S t e f a n " ; 1 / n a m e 은 문 자 열
c o n s t 를 사 용 했 다 면 타 입 스 크 립 트 는 정 확 히 해 당 리 터 럴 형 식 을 추 론 한 다 .
const name = "Stefan"; / / name® "Stefan"
객 체 형 식 에 서 는 상 황 이 조 금 달 라 진 다 . L e t 을 이 용 하 면 여 전 히 넓 히 는 방 향 으 로 형 식 을 추 론
한 다 .
// person { name: string }
let person = { name: "Stefan" };
하 지 만 이 는 c o n s t 도 마 찬 가 지 다 .
1 1 2 실 무 로 통 하 는 타 입 스 크 립 트
/ / person@ { name: s t r i n g }
const person = { name: "Stefan" };
이 는 자 바 스 크 립 트 의 동 작 방 식 과 관 련 이 있 다 . 자 바 스 크 립 트 는 객 체 를 상 수 c o m i a m 로 바 인 딩 했
으 며 이 는 p e r s o n 을 다 시 할 당 할 수 없 는 의 미 다 . 하 지 만 여 전 히 객 체 의 프 로 퍼 티 는 바 꿀 수
있 다 .
/ / p e r s o n { name: string }
const person = { name: "Stefan" };
p e r s o n . n a m e = " N o t S t e f a n " ; 1 / 동 작 한 다 !
자 바 스 크 립 트 가 어 떻 게 동 작 하 는 지 를 생 각 해 보 면 이 는 이 치 에 맞 는 다 . 정 교 하 게 처 리 하 고 싶 은 상 황 에 서 는 문 제 를 야 기 할 수 있 다 .
앞 에 서 유 니 온 형 식 과 인 터 섹 션 형 식 으 로 데 이 터 를 모 델 링 했 다 . 용 해 비 슷 한 형 식 들 을 구 분 했 다 .
데 이 터 에 리 터 럴 을 사 용 하 면 타 입 스 크 립 트 는 넓 은 집 합 을 추 론 하 는 데 , 호 환 되 지 않 는 값 을 허 용 하 게 된 다 . 이 때 매 우 긴 오 류 메 시 지 가 표 시 된 다 .
하 지 만 데 이 터 모 델 을
이 때 구 별 된 유 니 온 형 식 을 이
그 러 면 정 의 한 형 식 과
type Circle = {
radius: number;
kind: "circle";
type Square = {
x: number;
kind: "square";
};
type Triangle = {
x : number;
y: number;
kind: "triangle";
! !
type Shape = Circle | Triangle | Square;
3 장 형 식 시 스 템 1 1 3
function area(shape: Shape) {
/ * . . .
*
}
const c i r c l e = 1
radius: 2,
kind: "circle",
area(circle);
1 /
1 1
1 1
^ - - ' { r a d i u s : n u m b e r ; k i n d : s t r i n g ; } ' 형 식 의 인 수 는
' S h a p e ' 형 식 의 매 개 변 수 에 할 당 할 수 없 습 니 다 .
' { r a d i u s : n u m b e r ; k i n d : s t r i n g ; } ' 형 식 은 ' C i r c l e ' 형 식 에 할 당 할 수 없 습 니 다 .
' k i n d ' 속 성 의 형 식 이 호 환 되 지 않 습 니 다 .
1 1 ' s t r i n g ' 형 식 은 ' " c i r c L e " ' 형 식 에 할 당 할 수 없 습 니 다 . t s ( 2 3 4 5 )
여 러 방 법 으 로 이 문 제 를 해 결 할 수 있 다 . 첫 번 째 로 형 식 을 식 별 하 도 록 명 시 적 으 로 애 너 테 이
션 을 사 용 할 수 있 다 . 2 . 1 절 에 서 살 펴 봤 듯 이 각 애 너 테 이 션 은 형 식 검 사 기 능 을 제 공 한 다 . 즉 ,
오 른 쪽 에 대 입 하 는 값 이 해 당 형 식 과 호 환 되 는 지 검 사 할 수 있 다 .
1 / 정 확 한 형 식
const circle: Circle = {
radius: 2,
kind: "circle",
};
a r e a ( c i r c l e ) ; 1 / 동 작 한 다 !
1 / 넓 힌 집 합
const circle: Shape = {
radius: 2,
kind: "circle",
a r e a ( c i r c l e ) ; 1 / 역 시 동 작 한 다 !
형 식 애 너 테 이 션 대 신 할 당 문 끝 에 형 식 어 서 션 을 추 가 하 는 방 법 도 있 다 .
1 1 4 실 무 로 통 하 는 타 입 스 크 립 트
1 / 형 식 어 서 션
const circle = {
radius: 2,
kind: "circle",
} as Circle;
a r e a ( c i r c l e ) ; 1 / 동 작 한 다 !
하 지 만 때 로 는 애 너 테 이 션 으 로 제 한 이 생 긴 다 . 특 히 더 많 은 정 보 를 포 함 하 는 리 터 럴 을 서 로
다 른 장 소 에 서 다 른 의 미 로 사 용 할 때 이 런 문 제 가 발 생 한 다 .
C i r c l e 의 형 식 을 명 시 하 거 나 어 서 션 을 추 가 하 는 순 간 부 터 이 객 체 에 다 른 값 을 추 가 해 도 여 전
히 이 를 C i r c l e 로 간 주 한 다 .
어 서 션 을 더 정 교 하 게 활 용 할 수 있 다 . 를 특 정 형 식 으 로 특 정 한 다 .
전 체 객 체 를 특 정 형 식 으 로 특 정 하 지 않 고 각 프 로 퍼 티
const circle = {
radius: 2,
kind: "circle" as "circle",
3;
a r e a ( c i r c l e ) ; 1 / 동 작 한 다 !
a s c o n s t 형 식 어 서 션 , 즉 c o n s t 컨 텍 스 를 이 용 해 정 확 한 값 을 특 정 하 는 방 법 도 있 다 . 그 러 면
타 입 스 크 립 트 는 이 를 리 터 럴 형 식 으 로 고 정 한 다 .
const circle = {
radius: 2,
kind: "circle" as const,
};
a r e a ( c i r c L e ) ; 1 / 동 작 한 다 !
c o n s t 컨 텍 스 트 를 전 체 객 체 에 적 용 하 면 객 체 는 읽 기 전 용 이 되 므 로 바 꿀 수 없 게 된 다 .
3 장 형 식 시 스 템 1 1 5
const circle = {
radius: 2,
kind: "circle",
} as const;
a r e a 2 ( c i r c l e ) ; 1 / 동 작 한 다 !
circle.kind = "rectangle";
1 1 ^ - - 읽 기 전 용 속 성 이 므 로 ' k i n d ' 에 할 당 할 수
1 1 없 습 니 다 . t s ( 2 5 4 0 )
어 떤 값 들 을 특 정 리 터 럴 형 식 으 로 고 정 할 때 c o n s t 컨 텍 스 트 형 식 어 서 션 을 유 용 하 게 사 용 할
수 있 다 . c o n s t 수 있 지 만 , 컨 텍 스 트 를 이 용 하 면 코 드 에 서 수 많 은 객 체 리 터 럴 이 존 재 하 고 이 들 을 소 비 할
값 을 바 꾸 지 못 하 게 할 수 있 다 .
3 . 5 형 식 찬 반 형 으 로 형 식 좁 히 기
문 제 어 떤 조 건 에 따 라 값 을 기 존 에 할 당 한 것 보 다 좁 은 형 식 으 로 특 정 하 고 싶 지 만 , 타 입 스 크 립 트 가 이 를
지 원 하 지 않 는 다 .
해 결 형 식 찬 반 형 y p e P r e d i c a e 을 헬 퍼 함 수 의 시 그 니 처 에 추 가 해 서 형 식 시 스 템 의 B o o l e a n 조 건
의 효 과 를 이 용 한 다 .
논 의 타 입 스 크 립 트 에 서 는 리 터 럴 형 식 과 유 니 온 형 식 으 로 원 하 는 값 의 집 합 을 구 체 적 으 로 정
의 한 다 . 예 를 들 어 , 다 음 처 럼 주 사 위 의 값 을 쉽 게 정 의 한 다 .
type Dice = 1 / 2 1 3 / 4 1 5 | 6 ;
이 표 기 법 으 로 원 하 는 형 식 을 쉽 게 정 의 할 수 있 으 며 형 식 시 스 템 은 유 효 한 값 이 정 확 히 무 엇
인 지 알 수 있 다 . 다 만 이 런 형 식 을 만 드 는 과 정 이 조 금 번 거 롭 다 는 것 이 단 점 이 다 .
임 의 의 숫 자 를 입 력 할 수 있 는 게 임 을 개 발 한 다 고 가 정 하 자 . 이 게 임 은 주 사 위 점 의 개 수 가 유
효 할 때 만 정 해 진 동 작 을 수 행 한 다 .
1 1 6 실 무 로 통 하 는 타 입 스 크 립 트
입 력 값 이 정 해 진 집 합 의 일 부 인 지 확 인 하 도 록 조 건 문 을 추 가 한 다 .
function rollDice(input: number) {
i f ([1, 2, 3, 4, 5, 6]. includes(input)) 1
1 / 사 람 들 은 i n p u t 이 주 사 위 라 는 사 실 을 알 지 만 ,
1 / 타 입 스 크 립 트 입 장 에 서 i n p u t 은 여 전 히 ' n u m b e r 다 .
}
}
이 렇 게 검 사 해 서 유 효 한 값 임 을 확 인 할 수 있 지 만 타 입 스 크 립 트 는 여 전 히 i n p u t 을 n u m b e r 로
취 급 한 다 . 현 재 검 사 로 는 형 식 시 스 템 이 형 식 을 바 꾸 도 록 하 는 방 법 이 없 기 때 문 이 다 .
하 지 만 형 식 시 스 템 이 좀 더 효 과 적 으 로 동 작 하 도 록 도 울 수 있 다 . 우 선 검 사 코 드 를 헬 퍼 함 수
로 이 동 한 다 .
function isDice(value: number): boolean {
return [1, 2, 3, 4, 5, 61. includes(value);
}
이 검 사 함 수 는 b o o l e a n ( t r u e L f a l s e ) 을 반 환 한 다 . B o o l e a n 값 을 반 환 하 는 함 수 가 형 식 찬
반 형 을 반 환 하 도 록 함 수 반 환 형 식 시 그 니 처 를 바 꿀 수 있 다 .
함 수 가 t r u e 를 반 환 하 면 함 수 로 전 달 된 값 이 무 엇 인 지 알 수 있 다 . 물 론 이 예 제 에 서 는 D i c e
형 식 이 다 .
function isDice(value: number): value is Dice {
return [1, 2, 3, 4, 5, 6]. includes(value);
}
교 하 이 런 방 식 으 로 타 입 스 크 립 트 는 값 의 실 제 형 식 이 무 엇 인 지 파 악 해 서 값 에 수 행 할 동 작 을 더 정
게 제 어 할 수 있 다 .
function rollDice(input: number) {
if (isDice(input)) {
1 / 동 작 함 ! 이 제 i n p u t 은 D i c e 임
} e l s e {
1 / i n p u t 은 여 전 히 「 n u m b e r 임
3 장 형 식 시 스 템 1 1 7
}
}
타 입 스 크 립 트 는 제 한 적 r c i a n c 이 고 , 형 식 찬 반 형 에 a n y 어 서 션 은 허 용 하 지 않 으 며 , 반 드 시 기
존 형 식 보 다 좁 은 형 식 이 어 야 한 다 . 예 를 들 어 s t r i n g 입 력 을 받 아 출 력 을 n u m b e r 의 하 위 집
합 으 로 특 정 하 면 오 류 가 발 생 한 다 .
type Dice = 1 / 2 1 3 / 4 1 5 | 6 ;
function isDice(value: string): value is Dice {
1 / 오 류 : 형 식 조 건 자 의 형 식 을 해 당 매 개 변 수 의 형 식 에 할 당 할 수 있 어 야 합 니 다 .
1 / ' n u m b e r ' 형 식 은 ' s t r i n g ' 형 식 에 할 당 할 수 없 습 니 다 .
1 / ' n u m b e r ' 형 식 은 ' s t r i n g ' 형 식 에 할 당 할 수 없 습 니 다 . t s ( 2 6 7 7 )
return ["1", "2", "3", "4", "5", "6"].includes(value);
}
이 런 안 전 장 치 덕 분 에 형 식 을 튼 튼 하 게 만 들 수 있 지 만 단 점 도 있 다 . 이 기 법 에 서 는 조 건 자 체
가 유 효 한 지 를 확 인 하 지 않 는 다 . i s D i c e 에 서 수 행 하 던 원 래 검 사 에 서 는 전 달 된 값 이 유 효 한
숫 자 배 열 에 포 함 되 는 지 확 인 한 다 .
배 열 의 값 은 우 리 가 정 한 다 . 잘 못 된 숫 자 를 정 했 을 때 도 타 입 스 크 립 트 는 이 를 검 출 하 지 못 하 고
특 정 값 이 유 효 한 D i c e 라 생 각 한 다 .
1 / 형 식 수 준 에 서 는 올 바 르 지 만 ,
1 / 값 수 준 에 서 는 올 바 른 값 의 집 합 이 아 님
function isDice(value: number): value is Dice {
return [1, 2, 3, 4, 5, 71. includes(value);
}
이 런 실 수 는 자 주 발 생 한 다 . [ 예 제 3 - 1 ] 에 정 수 를 전 달 하 면 괜 찮 지 만 , 소 수 점 을 포 함 하 는 숫 자
를 전 달 하 면 문 제 가 발 생 한 다 . 예 를 들 어 3 . 1 4 1 5 를 유 효 한 D i c e 숫 자 로 간 주 한 다 .
1 1 8 실 무 로 통 하 는 타 입 스 크 립 트
예 제 3 - 1 소 수 점 을 포 함 하 는 숫 자 를 전 달 하 면 i s D i c e 에 문 제 가 발 생 한 다 .
1 / 형 식 수 준 에 서 는 문 제 가 없 지 만 논 리 적 으 로 올 바 르 지 않 다 .
function isDice(value: number): value is Dice {
return value >= 1 && value <= 6;
}
실 질 적 으 로 타 입 스 크 립 트 에 서 는 모 든 조 건 을 한 가 지 로 특 정 할 수 있 다 . 즉 , t r u e 를 반 환 하 면
타 입 스 크 립 트 는 이 값 을 항 상 D i c e 로 간 주 한 다
function isDice(value: number): value is Dice {
return true;
}
타 입 스 크 립 트 는 형 식 어 서 션 을 제 공 한 다 . 하 지 만 이 러 한 어 서 션 을 유 효 하 고 튼 튼 하 게 활 용 하
는 것 은 우 리 의 책 임 이 다 . 형 식 찬 반 형 을 이 용 해 형 식 어 서 션 을 자 주 사 용 하 는 상 황 이 라 면 찬
반 형 코 드 를 적 절 하 게 테 스 트 해 야 한 다 .
3 . 6 v o i d 이 해 하 기
문 제 다 른 언 어 에 서 제 공 하 는 v o i d 개 념 은 이 미 알 지 만 , 타 입 스 크 립 트 는 v o i d 를 조 금 다 른 방 식 으 로 취
급 한 다 .
해 결 v o i d 란 콜 백 을 대 체 할 수 있 는 형 식 으 로 간 주 한 다 .
논 의 자 바 나 C # 등 의 프 로 그 래 밍 언 어 에 서 v o i d 를 어 떻 게 활 용 하 는 지 알 것 이 다 . 이 들 언 어
에 서 는 보 통 반 환 값 이 없 는 상 황 을 V o i d 로 표 현 한 다 . 타 입 스 크 립 트 에 도 V o i d 가 있 는 데 , 얼 핏
보 면 기 존 언 어 와 비 슷 한 방 식 으 로 동 작 하 는 것 같 다 . 즉 함 수 나 메 서 드 가 값 을 반 환 하 지 않 을
때 v o i d 를 반 환 형 식 으 로 사 용 한 다 .
3 장 형 식 시 스 템 1 1 9
자 바 스 크 립 트 의 v o i d
자 바 스 크 립 트 에 서 는 연 산 자 로 V o i d 가 존 재 하 며 이 는 아 주 특 별 한 동 작 을 수 행 한 다 . V o i d 는 옆
에 등 장 하 는 표 현 식 이 u n d e f i n e d 를 반 환 하 도 록 평 가 한 다 .
let i = void 2; / / i === undefined
v o i d 를 어 디 에 활 용 할 수 있 을 까 ? 첫 째 , E C M A S c r i p t 3 에 서 는 u n d e f i n e d 가 실 젯 값 을 갖 도 록
오 버 라 이 드 할 수 있 다 . v o i d 는 항 상 u n d e f i n e d ( 실 젯 값 을 갖 지 않 는 ) 를 반 환 한 다 .
둘 째 , 정 의 와 동 시 에 실 행 되 는 함 수 를 호 출 할 때 v o i d 를 활 용 한 다 .
/ / 즉 시 실 행 함
void function) {
console. log ('Hey');
20);
전 역 네 임 스 페 이 스 를 오 염 시 키 지 않 는 다 .
void function aRecursion(i) {
if(i > 0) {
console. log(i--);
aRecursion(i);
}
}(3);
console. log(typeof aRecursion); / / undefined
v o i d 는 항 상 u n d e f i n e d 를 반 환 하 며 옆 의 표 현 식 을 평 가 하 므 로 다 음 예 제 처 럼 값 을 반 환 하 지
않 고 콜 백 을 호 출 하 는 함 수 를 반 환 하 도 록 할 수 있 다 .
1 / u n d e f i n e d 이 외 의 값 을 반 환 하 면 앱 충 돌 발 생
function middleware(nextCallback) {
if(conditionApplies)) {
return void nextCallback();
}
}
1 2 0 실 무 로 통 하 는 타 입 스 크 립 트
개 인 적 으 로 v o i d 를 앱 의 보 안 게 이 트 로 사 용 하 는 것 이 가 장 유 용 한 활 용 방 법 이 라 생 각 한 다 . 어
떤 함 수 가 항 상 u n d e f i n e d 를 반 환 한 다 면 실 제 로 그 러 한 지 다 음 처 럼 확 인 한 다 .
button.onclick = () => void doSomething);
하 지 만 다 시 생 각 해 보 면 v o i d 의 동 작 이 나 형 식 시 스 템 의 위 치 가 조 금 난 해 한 편 이 다 . 타 입 스
크 립 트 상 에 서 v o i d 는 u n d e f i n e d 의 하 위 형 식 이 다 . 자 바 스 크 립 트 의 함 수 는 항 상 무 언 가 를 반
환 한 다 . 명 시 적 으 로 값 을 반 환 하 든 지 암 묵 적 으 로 u n d e f i n e d 를 반 환 하 는 식 이 다 .
function iHaveNoReturnValue(i) ‹
console. log(i);
}
let check = iHaveNoReturnValue(2);
/ / c h e c k undefined
I H a v e N o R e t u r n v a l u e 는 v o i d 형 식 을 반 환 하 는 함 수 다 .
function iHaveNoReturnValue(i) {
console. log(i);
}
type Fn = typeof iHaveNoReturnValue;
/ / type Fn = ( i : any) => void
매 개 변 수 나 그 밖 의 다 른 모 든 선 언 에 도 v o i d 를 형 식 으 로 사 용 할 수 있 다 . 그 러 면 오 직
u n d e f i n e d 만 을 유 효 한 값 으 로 받 는 다 .
function iTakeNoParameters(x: void): void { }
i T a k e N o P a r a m e t e r s ( ) ; 1 / 동 작 함
i T a k e N o P a r a m e t e r s ( u n d e f i n e d ) ; 1 / 동 작 함
i T a k e N o P a r a m e t e r s ( v o i d 2 ) ; / / 동 작 함
3 장 형 식 시 스 템 1 2 1
v o i d 와 u n d e f i n e d 는 아 주 많 이 비 슷 하 다 . 하 지 만 이 들 사 이 에 는 중 요 한 차 이 점 이 있 다 . 반 환
형 식 으 로 사 용 한 v o i d 는 다 른 형 식 으 로 치 환 할 수 있 으 므 로 추 가 콜 백 패 턴 을 활 용 할 수 있 다 .
예 를 들 어 f e t c h 함 수 를 만 들 어 보 자 . 이 함 수 는 숫 자 집 합 을 받 아 결 과 를 콜 백 함 수 의 매 개 변
수 로 전 달 한 다 .
function fetchResults(
callback: (statusCode: number, results: number[]) = void
) {
/ 어 딘 가 에 서 결 과 를 얻 음 . . .
callback(200, results);
}
콜 백 함 수 의 시 그 니 처 를 보 면 두 매 개 변 수 S t a t u s C o d e 와 r e s u l t s 를 받 으 며 v o i d 형 식 을 반
환 함 을 알 수 있 다 . 이 제 콜 백 함 수 와 호 환 되 는 인 수 를 f e t c h R e s u l t s 의 c a l l b a c k 함 수 로 설
정 해 호 출 할 수 있 다 .
function normalHandler (statusCode: number, results: number []): void 1
1 / 두 매 개 변 수 로 필 요 한 작 업 수 행
}
fetchResults(normalHandler);
반 환 형 식 을 v o i d 로 설 정 하 면 반 환 형 식 이 조 금 더 구 체 적 인 다 양 한 함 수 를 이 용 할 수 있 다 .
function handler (statusCode: number): boolean {
1 / 상 태 코 드 평 가 . . .
return true;
}
f e t c h R e s u l t s ( h a n d l e r ) ; 1 / 문 제 없 이 컴 파 일 됨 !
코 드 는 컴 파 일 되 지 만 다 음 처 럼 함 수 시 그 니 처 가 일 치 하 지 않 는 다 . 첫 째 , 시 그 니 처 에 더 짧 은
인 수 목 록 을 제 공 할 수 있 다 . 자 바 스 크 립 트 는 초 과 매 개 변 수 가 있 어 도 함 수 를 호 출 하 는 데 문
제 가 없 으 며 , 이 들 을 그 저 무 시 한 다 . 필 요 한 매 개 변 수 보 다 더 많 은 매 개 변 수 를 유 지 할 필 요 가
없 기 때 문 이 다 .
1 2 2 실 무 로 통 하 는 타 입 스 크 립 트
둘 째 , 반 환 형 식 은 b o o L e a n 이 지 만 타 입 스 크 립 트 는 여 전 히 이 함 수 를 전 달 한 다 . 이 상 황 에
v o i d 형 식 을 이 용 하 면 조 금 더 편 리 하 다 . f e t c h R e s u l t s 는 콜 백 을 호 출 할 때 반 환 값 을 기 대 하
지 않 는 다 . 따 라 서 형 식 시 스 템 의 입 장 에 서 콜 백 의 반 환 값 은 ( 실 제 로 는 값 이 존 재 할 수 있 음 에
도 ) 여 전 히 u n d e f i n e d 다 .
형 식 시 스 템 이 반 환 값 을 사 용 하 지 못 하 게 하 는 한 코 드 는 안 전 하 다 .
function fetchResults(
callback: (statusCode: number, results: number []) => void
> {
1 / 어 딘 가 에 서 결 과 를 얻 음 . . .
const didItWork = callback(200, results);
1 /
1 / d i d I t W o r k 은 불 리 언 ' h a n d l e r 지 만
1 / 형 식 시 스 템 입 장 에 서 는 u n d e f i n e d 다 .
}
덕 분 에 반 환 형 식 이 다 양 한 콜 백 을 전 달 할 수 있 다 . 콜 백 이 무 언 가 를 반 환 하 더 라 도 이 는 사 용
되 지 않 으 며 v o i d 로 전 달 된 다 .
콜 백 함 수 에 서 무 엇 을 기 대 해 야 하 는 지 아 는 호 출 함 수 에 힘 이 주 어 진 다 . 콜 백 함 수 로 부 터 반
환 값 이 필 요 없 는 상 황 이 라 면 무 엇 이 든 콜 백 으 로 사 용 할 수 있 다 .
타 입 스 크 립 트 는 이 를 대 체 성 w b w i t u a b i 이 라 부 르 며 , 의 미 상 문 제 가 없 다 면 무 언 가 를 다 른 것 으
로 대 체 할 수 있 는 능 력 을 가 리 킨 다 . 처 음 에 는 이 상 한 말 처 럼 들 릴 수 있 다 . 하 지 만 다 른 사 람
들 이 만 든 라 이 브 러 리 를 사 용 하 다 보 면 이 기 능 이 아 주 유 용 하 다 는 사 실 을 알 게 된 다 .
3 . 7 c a t c h 구 문 으 로 오 류 형 식 처 리 하 기
문 제 t r y - c a t c h 블 록 으 로 오 류 형 식 을 명 시 적 으 로 지 정 할 수 없 다 .
해 결 a n y 나 u n k n o w n 으 로 애 너 테 이 션 을 추 가 한 다 음 형 식 찬 반 형 ( 3 . 5 절 ' 특 정 오 류 형 식 으 로
좁 히 기 ' 참 고 ) 을 사 용 한 다 .
3 장 형 식 시 스 템 1 2 3
논 의 자 바 , C + + , C # 등 을 사 용 했 던 독 자 라 면 예 외 를 던 지 고 일 련 의 c a t c h 구 문 으 로 예 외 를
잡 는 방 식 으 로 오 류 를 처 리 하 는 데 익 숙 할 것 이 다 . 물 론 오 류 를 처 리 하 는 더 좋 은 방 법 ' 도 있 을
수 있 지 만 , 이 방 법 은 지 금 까 지 오 랫 동 안 널 리 통 용 되 어 왔 으 며 자 바 스 크 립 트 도 이 를 채 용 했 다 .
자 바 스 크 립 트 와 타 입 스 크 립 트 모 두 오 류 던 지 기 r o w 와 ' 잡 기 ( a c h 를 지 원 하 지 만 , C a t c h 구 문 을
지 정 하 는 방 법 에 는 큰 차 이 가 있 다 . 예 를 들 어 특 정 오 류 를 잡 으 려 하 면 타 입 스 크 립 트 는 오 류
를 일 으 킨 다 .
[ 예 제 3 - 2 ] 는 유 명 한 데 이 터 가 져 오 기 라 이 브 러 리 인 A x i o s ( h t t p s : / / a x i o s - h t t p . c o m ) 를 사 용
해 서 어 떻 게 이 런 문 제 가 발 생 하 는 지 보 여 준 다 .
예 제 3 - 2 특 정 오 류 형 식 을 잡 으 려 하 면 동 작 하 지 않 는 다 .
try {
1 / A x i o s 같 은 유 명 한 라 이 브 러 리 로 필 요 한 작 업 수 행
} catch(e: AxiosError) {
1 1 ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ 지 정 한 경 우 c a t c h 절 변 수 형 식 주 석 은
1 1 ' a n y ' 또 는 ' u n k n o w n ' 이 어 야 합 니 다 . t s ( 1 1 9 6 )
}
이 처 럼 동 작 하 는 몇 가 지 이 유 가 있 다 .
모 든 형 식 을 던 질 수 있 음
자 바 스 크 립 트 에 서 는 모 든 표 현 식 을 던 질 수 있 다 . 물 론 보 통 은 예 외 ' ( 자 바 스 크 립 트 에 서 는 ' 오
류 ' 라 부 름 ) 를 던 지 지 만 다 른 값 도 던 질 수 있 다 .
t h r o w " w h a t a w e i r d e r r o r " ; 1 / 동 작 함
t h r o w 4 0 4 ; 1 / 동 작 함
throw new Error ("What a weird e r r o r " ) ;
모 든 유 효 한 값 을 던 질 수 있 으 므 로 c a t c h 에 서 받 을 수 있 는 값 은 이 미 E r r o r 의 하 위 형 식 보 다
넓 게 설 정 된 다 .
1 프 로 그 래 밍 언 어 인 러 스 트 는 t r y - c a t c h 대 신 도 입 한 오 류 처 리 방 식 으 로 찬 사 를 받 았 다 .
1 2 4 실 무 로 통 하 는 타 입 스 크 립 트
자 바 스 크 립 트 에 서 는 오 직 한 개 의 c a t c h 구 문 만 추 가 할 수 있 음
자 바 스 크 립 트 에 서 는 t r y 구 문 하 나 에 오 직 한 개 의 c a t c h 구 문 을 추 가 할 수 있 다 . 과 거 에 여 러
c a t c h 구 문 과 조 건 표 현 식 을 넣 자 는 제 안 ( h t t p s : / / o r e i l . L y / M M 8 0 ) 이 제 출 되 었 지 만 , 2 0 0 0 년
대 초 반 에 는 자 바 스 크 립 트 에 관 한 관 심 부 족 으 로 실 현 되 지 못 했 다 .
대 신 M D N ( h t t p s : / / o r e i l . l y / i p z o R ) 의 제 안 처 럼 한 개 의 c a t c h 구 문 안 에 서 i n s t a n c e o f 와
t y p e o f 검 사 로 필 요 한 작 업 을 수 행 하 는 편 이 좋 다 .
이 예 제 는 타 입 스 크 립 트 의 c a t c h 구 문 에 서 형 식 을 올 바 로 좁 히 는 방 법 도 보 여 준 다 .
try {
m y r o u t i n e ( ) ; 1 / 다 양 한 오 류 가 여 기 서 발 생 함
} catch (e) {
if (e instanceof TypeError) {
/ / TypeError
} else if (e instanceof RangeError) {
/ / R a n g e E r r o r 처 리
} else if (e instanceof EvalError) {
1 / E v a l E r r o r 임 을 알 수 있 음
} else i f (typeof e === "string") {
1 / 문 자 열 오 류
} else if (axios.isAxiosError(e)) {
1 / a x i o s 가 자 동 으 로 오 류 검 사 를 해 주 지 는 않 는 다 !
} else {
1 / 그 밖 의 조 건
logMyErrors (e);
}
}
모 든 가 능 한 값 을 던 질 수 있 으 며 t r y 구 문 당 한 개 의 c a t c h 구 문 만 추 가 할 수 있 으 므 로 e 의
형 식 범 위 는 정 말 로 넓 다 .
어 떤 예 외 든 발 생 할 수 있 음
어 떤 오 류 든 발 생 할 수 있 다 면 던 질 수 있 는 ' 모 든 값 의 유 니 온 형 식 을 만 들 면 어 떨 까 ? 이 론 적
으 로 는 가 능 하 지 만 , 사 실 현 재 로 서 는 예 외 의 형 식 을 알 수 없 다 .
사 용 자 정 의 예 외 와 오 류 이 외 에 시 스 템 이 던 지 는 오 류 도 있 다 . 형 식 이 불 일 치 하 거 나 한 함 수
3 장 형 식 시 스 템 1 2 5
가 u n d e f i n e d 일 때 시 스 템 오 류 가 발 생 한 다 . 단 순 한 함 수 호 출 시 에 도 호 출 스 택 이 범 람 하 면
서 악 명 높 은 스 택 오 버 플 로 문 제 가 발 생 할 수 있 다 .
가 능 한 값 은 많 고 c a t c h 구 문 은 하 나 뿐 이 며 발 생 할 수 있 는 오 류 도 많 으 므 로 e 의 형 식 은 a n y
와 u n k n o w n 두 가 지 후 보 로 좁 혀 진 다 .
P r o m i s e 를 거 절 할 때 는 모 든 이 유 가 적 용 된 다 . 타 입 스 크 립 트 에 서 는 P r o m i s e 가 실 현 ( u l 되
었 을 때 만 형 식 을 지 정 할 수 있 다 . 보 통 개 발 자 가 직 접 거 절 을 발 생 시 키 거 나 시 스 템 오 류 로 거
절 이 발 생 한 다 .
const somePromise = 0 =>
new Promise((fulfil, reject) → {
if (someConditionIsValid()) {
fulfil(42);
} else {
reject ("Oh no!");
}
} ) ;
somePromise)
-then((val) => console.log(val)) / / v a l e number
• c a t c h ( ( e ) = > c o n s o l e . l o g ( e ) ) ; 1 / 어 떤 형 식 이 든 가 능 함
같 은 P r o m i s e 를 a s y n c / a w a i t 흐 름 에 서 호 출 하 면 조 금 더 명 확 해 진 다 .
try {
const z = await somePromise); / / zE number
( } c a t c h ( e ) {
1 / 마 찬 가 지 로 e 는 어 떤 형 식 이 든 가 능 함 !
}
자 신 만 의 오 류 를 정 의 해 서 잡 고 싶 다 면 오 류 클 래 스 를 구 현 한 다 음 i n s t a n c e o f 검 사 를 수 행
하 거 나 특 정 프 로 퍼 티 를 검 사 하 는 헬 퍼 함 수 를 만 들 어 형 식 찬 반 형 으 로 올 바 른 형 식 을 확 인 할
수 있 다 . 이 번 에 도 A x i o s 로 좋 은 예 를 만 들 었 다 .
function isAxiosError(payload: any): payload is AxiosError {
return payload ! = n u l l
&& typeof payload === 'object'
1 2 6 실 무 로 통 하 는 타 입 스 크 립 트
& payload.isAxiosError;
}
다 른 프 로 그 래 밍 언 어 를 먼 저 사 용 해 봤 다 면 자 바 스 크 립 트 와 타 입 스 크 립 트 의 오 류 처 리 가 ' 가 짜
친 구 ' 처 럼 느 껴 질 수 있 다 . 하 지 만 무 엇 이 다 른 지 정 확 히 이 해 하 고 타 입 스 크 립 트 개 발 팀 과 형 식
검 사 기 를 믿 어 보 자 . 올 바 른 흐 름 제 어 를 통 해 오 류 를 효 과 적 으 로 처 리 할 수 있 게 될 것 이 다 .
3 . 8 선 택 형 n e v e r 로 배 타 적 논 리 합 모 델 만 들 기
문 제 유 니 온 에 서 서 로 겹 치 지 않 도 록 모 델 을 만 들 어 야 하 는 데 , 이 들 을 구 별 할 k i n d 프 로 퍼 티 를 A P I 에
사 용 할 수 없 는 상 황 이 다 .
해 결 선 택 형 n e v e r 기 법 으 로 특 정 프 로 퍼 티 를 제 외 한 다 .
논 의 애 플 리 케 이 션 에 서 선 택 동 작 의 결 과 를 처 리 하 는 함 수 를 구 현 해 야 한 다 . 이 선 택 기 능 은
가 능 한 옵 션 목 록 뿐 아 니 라 선 택 한 옵 션 목 록 도 제 공 한 다 . 이 함 수 는 한 개 나 여 러 개 의 값 을
선 택 했 을 때 의 상 황 을 모 두 처 리 해 야 한 다 .
기 존 A P I 에 이 를 적 용 해 야 하 므 로 여 러 분 의 함 수 는 단 일 값 과 다 중 값 이 라 는 두 가 지 상 황 을 처
리 하 고 어 떤 상 황 인 지 도 결 정 할 수 있 어 야 한 다 .
노 트 물 론 A P I 를 모 델 링 하 는 더 좋 은 방 법 이 있 다 . 하 지 만 기 존 의 A P I 를 이 용 해 야 하 는 상 황 도 있 다 . 타 입 스
크 립 트 는 이 런 상 황 에 서 도 데 이 터 에 올 바 른 형 식 을 추 가 하 는 다 양 한 기 법 과 수 단 을 제 공 한 다 .
모 델 은 A P I 를 반 영 한 다 . 즉 한 개 나 여 러 v a l u e s 를 전 달 할 수 있 다 .
type SelectBase = {
options: string[];
type SingleSelect = SelectBase & {
value: string;
};
3 장 형 식 시 스 템 1 2 7
type MultipleSelect = SelectBase & {
values: string[];
};
type SelectProperties = SingleSelect | MultipleSelect;
function selectCallback(params: SelectProperties) {
if ("value" in params) &
1 / 한 개 의 값 처 리
} else if ("values" in params) {
/ / 여 러 값 처 리
}
}
selectCallback({
options: ["dracula", "monokai", "vscode"],
value: "dracula",
} ) ;
selectCallback({
options: ["dracula", "monokai", "vscode"],
values: ["dracula", "vscode"],
} ) ;
의 도 한 대 로 코 드 가 동 작 한 다 . 하 지 만 타 입 스 크 립 트 의 구 조 적 형 식 시 스 템 기 능 을 떠 올 려 보
자 . S i n g l e s e L e c t 를 형 식 으 로 정 의 하 면 모 든 하 위 형 식 의 값 을 사 용 할 수 있 으 므 로 v a l u e 와
v a l u e s 프 로 퍼 티 를 갖 는 두 객 체 모 두 S i n g l e s e l e c t 와 호 환 된 다 . M u l t i p l e s e l e c t 도 마 찬
가 지 다 . s e l e c t C a l L b a c k 함 수 가 두 가 지 모 두 를 포 함 하 는 객 체 를 사 용 하 지 못 하 도 록 막 을 방
법 이 없 다 .
selectCallback({
options: ["dracula" ', "monokai", "vscode"],
values: ["dracula", "vscode"],
value: "dracula",
} ) ; 1 / 동 작 한 다 ! 하 지 만 무 엇 을 선 택 해 야 하 나 ?
코 드 에 서 전 달 한 값 은 유 효 하 지 만 의 미 상 맞 지 않 는 다 . 때 문 이 다 .
단 일 값 인 지 다 중 값 인 지 결 정 할 수 없 기
1 2 8 실 무 로 통 하 는 타 입 스 크 립 트
이 런 상 황 에 서 는 두 가 지 값 을 분 리 하 여 모 델 을 명 확 하 게 만 들 어 야 한 다 . 선 택 형 n e v e r 기 법 2
을 이 용 해 보 자 . 이 는 유 니 온 의 각 영 역 에 서 겹 치 지 않 는 프 로 퍼 티 를 가 져 다 가 선 택 형 프 로 퍼
티 형 식 n e v e r 로 반 대 편 영 역 에 추 가 하 는 기 법 이 다 .
type SelectBase = {
options: string[];
3
type SingleSelect = SelectBase & {
value: string;
values?: never;
};
type MultipleSelect = SelectBase & {
value?: never;
values: string[];
3
이 렇 게 유 니 온 의 한 영 역 에 이 프 로 퍼 티 가 선 택 형 임 을 알 리 고 해 당 프 로 퍼 티 가 설 정 되 었 을 때
호 환 되 는 값 이 없 다 . 따 라 서 이 두 프 로 퍼 티 를 모 두 포 함 하 는 객 체 는 S e L e c t P r o p e r t i e s 가 아
니 다 .
selectCallback({
options: ["dracula", "monokai", "vscode"],
values: ["dracula", "vscode"],
value: "dracula",
1 / ^ ' { o p t i o n s : s t r i n g [ ] ; v a l u e s : s t r i n g [ ] ; v a l u e : s t r i n g ; } ' 형 식 의 인 수 는
' S e L e c t P r o p e r t i e s ' 형 식 의 매 개 변 수 에 할 당 될 수 없 습 니 다 .
' v a l u e ' 속 성 의 형 식 이 호 환 되 지 않 습 니 다 .
1 1 ' s t r i n g ' 형 식 은 ' u n d e f i n e d ' 형 식 에 할 당 할 수 없 습 니 다 . t s ( 2 3 4 5 )
이 렇 게 k i n d 프 로 퍼 티 를 사 용 하 지 않 고 유 니 온 형 식 을 분 리 했 다 . 구 별 하 는 프 로 퍼 티 가 조 금
있 는 상 황 에 서 유 효 하 게 이 기 법 을 사 용 할 수 있 다 . 구 별 하 는 프 로 퍼 티 가 너 무 많 은 모 델 이 라
면 3 . 2 절 에 서 설 명 한 k i n d 프 로 퍼 티 와 구 별 된 유 니 온 형 식 을 사 용 하 자 .
2 댄 밴 더 캄 ( D a n V a n d e r k a m ) 은 E f f e c t i v e T y p e S c r i p t 블 로 그 ( h t t p s : / / e f f e c t i v e t y p e s c r i p t . c o m ) 에 서 ' 선 택 형 n e v e r ' 라 는 용 어 를 처
3 장 형 식 시 스 템 1 2 9
3 . 9 형 식 어 서 션 효 과 적 으 로 사 용 하 기
문 제 코 드 가 올 바 른 결 과 를 도 출 하 지 만 형 식 이 너 무 넓 다 . 분 명 개 선 할 부 분 이 있 다 !
해 결 a s 키 워 드 를 사 용 해 형 식 어 서 션 으 로 형 식 을 좁 히 며 안 전 하 지 않 은 동 작 임 을 가 리 킨 다 .
논 의 주 사 위 를 굴 려 1 에 서 6 사 이 의 숫 자 가 나 오 는 상 황 을 가 정 하 자 . 자 바 스 크 립 트 에 서 는
M a t h 라 이 브 러 리 를 이 용 하 면 한 행 으 로 이 를 구 현 할 수 있 다 . 여 기 서 주 사 위 의 결 과 를 가 리
키 는 여 섯 가 지 숫 자 형 식 의 유 니 온 으 로 좁 혀 진 형 식 을 사 용 하 고 싶 다 . 하 지 만 연 산 결 과 는
n u m b e r 인 데 이 는 너 무 범 위 가 넓 다 .
type Dice = 1 1 2 1 3 1 4 1 5 / 6 ;
function r o l l D i c e ( ) : Dice {
let num = Math. floor (Math. random) * 6) + 1;
r e t u r n num;
1 / ^ ' n u m b e r ' 형 식 은 ' D i c e ' 형 식 에 할 당 할 수 없 습 니 다 . t s ( 2 3 2 2 )
}
n u m b e r 는 D i c e 에 서 허 용 하 는 것 보 다 더 많 은 수 를 포 함 하 므 로 함 수 시 그 니 처 에 애 너 테 이 션 을
추 가 한 다 고 해 서 형 식 이 좁 혀 지 진 않 는 다 . 이 방 법 은 형 식 넓 히 기 ( 즉 , 상 위 형 식 ) 에 만 적 용 되
기 때 문 이 다 .
1 / 모 든 주 사 위 값 은 n u m b e r 다 .
function asNumberdice: Dice): number {
return dice;
}
대 신 3 . 5 절 의 형 식 찬 반 형 에 서 처 럼 타 입 스 크 립 트 가 형 식 을 더 잘 이 해 하 도 록 어 서 션 으 로 예 상
보 다 형 식 을 좁 힐 수 있 다 .
type Dice = 1 / 2 1 3 / 4 / 5 | 6 ;
function rollDice(): Dice {
let num = Math. floor (Math.random () * 6) + 1;
1 3 0 실 무 로 통 하 는 타 입 스 크 립 트
return num as Dice;
}
형 식 찬 반 형 과 마 찬 가 지 로 형 식 어 서 션 은 추 론 된 형 식 의 상 위 형 식 으 로 만 동 작 한 다 . 값 은 더
넓 은 상 위 형 식 이 나 좁 은 하 위 형 식 으 로 설 정 할 수 있 다 . 하 지 만 타 입 스 크 립 트 는 집 합 을 바 꾸
도 록 허 용 하 진 않 는 다 .
function asString(num: number): string {
r e t u r n num a s s t r i n g ;
^ - ' n u m b e r ' 형 식 을 ' s t r i n g ' 형 식 으 로 변 환 한 작 업 은
1 /
1 1
실 수 일 수 있 습 니 다 . 두 형 식 이 서 로 충 분 히 겹 치 지
않 기 때 문 입 니 다 . 의 도 적 으 로 변 환 한 경 우 에 는 먼 저
u n k n o w n ' 으 로 식 을 변 환 합 니 다 . t s ( 2 3 5 2 )
}
a s D i c e 문 법 은 편 리 하 다 . 이 를 이 용 해 개 발 자 가 의 도 한 형 식 으 로 대 상 형 식 을 바 꾼 다 . 이 때
뭔 가 가 잘 못 된 다 면 코 드 에 서 a s 키 워 드 를 찾 아 버 그 를 쉽 게 찾 을 수 있 다 .
노 트 사 람 들 은 보 통 어 서 션 을 형 식 변 환 y p e c a s t 이 라 부 르 곤 한 다 . 이 는 실 제 명 시 적 형 식 을 사 용 하 는 C 와 자 바
등 에 서 온 개 념 이 다 . 하 지 만 형 식 어 서 션 과 형 식 변 환 은 개 념 이 매 우 다 르 다 . 형 식 변 환 은 호 환 되 는 값 의 집 합 을
바 꿀 뿐 아 니 라 메 모 리 배 열 ( 심 지 어 값 이 저 장 된 위 치 ) 까 지 바 꾼 다 . 부 동 소 수 점 숫 자 를 정 수 로 바 꾸 면 소 수 점 이
하 값 이 잘 린 다 . 반 면 타 입 스 크 립 트 의 형 식 어 서 션 은 호 환 되 는 값 의 집 합 만 바 꾼 다 . 기 존 값 은 그 대 로 남 는 다 . 띠
라 서 형 식 이 더 넓 거 나 좁 은 형 식 으 로 바 뀌 며 형 식 시 스 템 에 더 다 양 한 힌 트 를 제 공 하 므 로 이 를 형 식 어 서 션 이 라
고 부 른 다 . 따 라 서 누 군 가 형 식 변 환 을 얘 기 한 다 면 이 는 형 식 변 환 이 아 닌 어 서 션 에 관 한 얘 기 다 .
객 체 의 프 로 퍼 티 를 모 을 때 도 어 서 션 이 등 장 한 다 . 예 를 들 어 P e r s o n 이 라 는 형 식 의 모 양 에 프
로 퍼 티 를 먼 저 설 정 한 다 .
type Person = {
name: string;
age: number;
function createDemoPerson(name: string) {
const person = {} as Person;
person.name = name;
person.age = Math. floor (Math.random) * 95);
3 장 형 식 시 스 템 1 3 1
return person;
}
형 식 어 서 션 은 타 입 스 크 립 트 에 이 빈 객 체 가 결 국 P e r s o n 임 을 알 려 준 다 . 그 후 에 타 입 스 크 립
트 는 프 로 퍼 티 설 정 을 허 용 한 다 . 프 로 퍼 티 를 설 정 하 는 일 을 잊 어 버 릴 수 있 으 며 이 런 일 이 일
어 나 도 타 입 스 크 립 트 는 아 무 경 고 도 하 지 못 하 므 로 이 는 안 전 하 지 않 은 i n s a t e 동 작 이 다 . 심 지 어
P e r s o n 이 바 뀌 고 더 많 은 프 로 퍼 티 가 생 겨 도 이 와 관 련 한 아 무 소 식 도 듣 지 못 한 다 .
type Person = {
name: string;
age: number;
profession: string;
function createDemoPerson(name: string) {
const person = {} as Person;
person. name = name;
person.age = Math. floor (Math. random) * 95);
1 / p r o f e s s i o n 은 어 디 에 ?
return person;
}
이 런 상 황 에 서 는 안 전 하 게 객 체 를 만 드 는 방 법 을 선 택 하 는 편 이 좋 다 . 추 가 할 수 있 으 므 로 모 든 필 수 프 로 퍼 티 를 설 정 하 도 록 강 제 한 다 .
모 든 것 에 애 너 테 이 션 을
type Person = {
name: string;
age: number;
function createDemoPerson(name: string) {
const person: Person = {
name,
age: Math.floor(Math.random() * 95),
{
return person;
}
1 3 2 실 무 로 통 하 는 타 입 스 크 립 트
형 식 어 서 션 보 다 형 식 애 너 테 이 션 이 더 안 전 하 지 만 r o L L D i c e 처 럼 어 쩔 수 없 는 상 황 도 있 다 .
다 른 타 입 스 크 립 트 시 나 리 오 에 서 는 다 른 선 택 을 할 수 있 겠 지 만 , 애 너 테 이 션 을 할 수 있 는 상
황 에 도 형 식 어 서 션 을 선 호 할 수 있 다 .
예 를 들 어 f e t c h A P I 를 사 용 해 백 엔 드 에 서 J S O N 데 이 터 를 가 져 오 는 상 황 에 서 f e t c h 를 호 출
한 다 음 애 너 테 이 션 된 형 식 에 결 과 를 할 당 한 다 .
type Person = 1
name: string;
age: number;
};
const ppl: Person[] = await fetch("/api/people"). then((res) =› res.json());
r e s . j s o n ( ) 의 결 과 는 a n y 이 며 , a n y 는 형 식 애 너 테 이 션 을 이 용 해 다 른 모 든 형 식 으 로 바 꿀 수
있 다 . 결 과 가 P e r s o n [ ] 이 라 는 보 장 은 할 수 없 다 . 결 과 를 P e r s o n [ ] 으 로 어 서 션 해 형 식 을 구
체 화 하 도 록 이 코 드 를 다 시 구 현 한 다 .
const ppl = await fetch("/api/people"). then((res) => res. json()) as Person[];
형 식 시 스 템 입 장 에 서 는 같 은 의 미 지 만 문 제 가 생 겼 을 때 이 코 드 를 이 용 하 면 더 쉽 게 문 제 의
위 치 를 파 악 할 수 있 다 . " / a p i / p e o p l e " 의 모 델 이 바 뀌 면 어 떻 게 될 까 ? 애 너 테 이 션 만 이 용 했
다 면 이 런 상 황 에 서 발 생 하 는 문 제 를 빨 리 파 악 하 기 어 렵 다 . 여 기 서 어 서 션 은 안 전 하 지 않 은 동
작 이 있 음 을 가 리 킨 다 .
애 플 리 케 이 션 안 에 서 동 작 하 는 모 델 집 합 을 만 든 다 고 가 정 하 자 . 정 확 한 숫 자 계 산 , A P I 같 은
외 부 기 능 에 의 지 하 는 상 황 이 라 면 형 식 어 서 션 으 로 특 정 경 계 를 넘 고 있 음 을 가 리 킬 수 있 다 .
형 식 찬 반 형 ( 3 . 5 절 참 고 ) 과 마 찬 가 지 로 , 형 식 어 서 션 을 사 용 할 때 도 올 바 른 형 식 을 사 용 할 책
임 은 여 러 분 에 게 있 다 .
3 장 형 식 시 스 템 1 3 3
3 . 1 0 인 덱 스 시 그 니 처 사 용 하 기
문 제 값 의 형 식 을 아 는 객 체 를 사 용 하 고 싶 은 데 모 든 프 로 퍼 티 의 이 름 을 아 직 알 지 못 한 다 .
해 결 인 덱 스 시 그 니 처 를 이 용 해 값 의 형 식 을 정 의 하 는 열 린 키 집 합 을 정 의 한 다 .
논 의 웹 A P I 에 는 자 바 스 크 립 트 객 체 형 태 로 컬 렉 션 을 얻 을 수 있 는 A P I 가 있 다 . 이 때 프 로 퍼
티 명 은 고 유 식 별 자 이 며 값 들 의 모 양 은 같 다 . 특 히 키 를 처 리 할 때 는 0 b j e c t . k e y s 로 모 든 관
련 I D 를 얻 을 수 있 는 데 , 빠 르 게 필 터 링 하 여 찾 으 려 는 값 의 인 덱 스 를 알 수 있 으 므 로 유 용 하 다 .
여 러 분 이 관 리 하 는 모 든 웹 사 이 트 의 성 능 을 평 가 한 다 고 가 정 하 자 . 다 음 처 럼 성 능 지 표 m e t i c 를
모 은 다 음 도 메 인 명 으 로 그 룹 화 한 다 .
const timings = {
"fettblog.eu": {
ttfb: 300,
fcp: 1000,
si: 1200,
Lcp: 1500,
tti: 1100,
tbt: 10,
} ,
"typescript-book. com": {
ttfb: 400,
fcp: 1100,
Si: 1100,
Icp: 2200,
tti: 1100,
tbt: 0,
3,
주 어 진 지 표 에 서 타 이 밍 값 이 가 장 작 은 도 메 인 을 찾 으 려 면 모 든 키 를 루 프 로 반 복 하 면 서 각 지
표 항 목 을 비 교 하 는 함 수 를 만 들 어 야 한 다 .
function findLowestTiming(collection, metric) {
l e t result = {
domain: " ' ,
1 3 4 실 무 로 통 하 는 타 입 스 크 립 트
value: Number.MAX_VALUE,
{ !
for (const domain in collection) {
const timing = collection[domain];
i f (timing[metric] ‹ result.value) {
result.domain = domain;
result.value = timing[metric];
return result.domain;
}
좋 은 프 로 그 래 머 라 면 적 절 하 게 함 수 에 형 식 을 추 가 해 서 불 필 요 한 지 표 자 료 를 전 달 하 지 않 도
록 할 것 이 다 . 지 푯 값 의 오 른 쪽 에 간 단 하 게 형 식 을 추 가 한 다 .
type Metrics = {
1 / 최 초 바 이 트 까 지 걸 린 시 간
ttfb: number;
1 / 최 초 의 만 족 스 러 운 페 인 트
fcp: number;
1 / 속 도 인 덱 스
s i : number;
1 / 가 장 큰 페 인 트
lcp: number;
1 / 상 호 동 작 시 간
t t i : number;
1 / 총 블 록 시 간
t b t : number;
키 집 합 으 로 구 성 된 자 료 의 모 양 을 정 의 하 기 는 쉽 지 않 으 므 로 타 입 스 크 립 트 는 인 덱 스 시 그 니
처 라 는 도 구 를 제 공 한 다 . 타 입 스 크 립 트 에 어 떤 프 로 퍼 티 명 이 있 는 지 모 르 지 만 , s t r i n g 형 식 이
존 재 한 다 고 알 리 며 이 는 M e t r i c s 를 가 리 킴 을 지 시 한 다 .
type MetricCollection = {
[domain: string]: Timings;
3 장 형 식 시 스 템 1 3 5
이 제 f i n d L o w e s t T i m i n g 의 형 식 을 지 정 한 다 . 컬 렉 션 의 형 식 을 M e t r i c C o l L e c t i o n 으 로 지 정
했 으 며 M e t r i c s 의 키 를 두 번 째 매 개 변 수 로 전 달 한 다 .
function findLowestTiming(
collection: MetricCollection,
key: keyof Metrics
): string {
l e t r e s u l t = {
domain: " '
value: Number.MAX_VALUE,
for (const domain in collection) {
const timing = collection[domain];
if (timing[key] ‹ result.value) {
result.domain = domain;
result.value = timing[key];
}
}
return result.domain;
}
코 드 는 잘 동 작 하 지 만 약 간 문 제 가 있 다 . 타 입 스 크 립 트 는 모 든 문 자 열 의 프 로 퍼 티 를 읽 도 록 허
용 하 지 만 프 로 퍼 티 를 실 제 이 용 할 수 있 는 지 는 검 사 해 주 지 않 으 므 로 주 의 하 자 .
const emptySet: MetricCollection = {};
l e t t i m i n g = e m p t y s e t [ " t y p e s c r i p t - c o o k b o o k . c o m " ] . f c p * 2 ; 1 / 형 식 오 류 발 생 하 지 않 음 !
인 덱 스 시 그 니 처 를 M e t r i c s 나 u n d e f i n e d 로 정 의 하 는 편 이 더 현 실 적 인 표 현 방 법 이 다 . 이 는
모 든 가 능 한 문 자 열 을 인 덱 스 하 지 만 이 때 값 이 없 을 수 도 있 음 을 가 리 키 기 때 문 이 다 . 이 렇 게
하 면 몇 가 지 안 전 장 치 를 추 가 해 야 하 지 만 궁 극 적 으 로 는 올 바 른 선 택 이 다 .
type MetricCollection = {
[domain: string]: Metrics | undefined;
} ;
function findLowestTiming(
collection: MetricCollection,
key: keyof Metrics
) : string {
1 3 6 실 무 로 통 하 는 타 입 스 크 립 트
l e t r e s u l t = {
domain: " '
value: Number.MAX_VALUE,
} ;
for (const domain in collection) {
const timing = collection[domain]; / / Metrics | undefined
1 / u n d e f i n e d 값 에 대 응 한 추 가 검 사
if (timing && timing[key] ‹ result.value) {
result.domain = domain;
result.value = timing[key];
}
}
return result.domain;
}
const emptySet: MetricCollection = 1};
/ / 선 택 형 체 인 과 널 종 류 의 값 접 근
let timing = (emptySet["typescript-cookbook.com"]?. fcp ?? 0) * 2;
M e t r i c s 나 u n d e f i n e d 값 은 사 라 진 프 로 퍼 티 와 는 다 르 지 만 상 황 이 완 전 히 다 르 지 는 않 다 .
3 . 1 1 절 의 u n d e f i n e d 값 과 사 라 진 프 로 퍼 티 사 이 의 미 묘 한 차 이 를 확 인 할 수 있 다 . d o m a i n 을
s t r i n g 으 로 설 정 하 지 말 고 매 핑 된 형 식 m a p p e d t y p e 이 라 불 리 는 일 종 의 s t r i n g 하 위 집 합 으 로 설
정 하 므 로 타 입 스 크 립 트 에 키 가 선 택 형 임 을 지 시 할 수 있 다 .
type MetricCollection = {
[domain in string]?: Metrics;
s t r i n g , n u m b e r , s y m b o l , 매 핑 된 형 식 을 포 함 한 이 들 의 모 든 하 위 형 식 을 인 덱 스 시 그 니 처 정
의 에 사 용 할 수 있 다 . 다 음 은 유 효 한 주 사 위 면 을 인 덱 스 로 정 의 한 예 다 .
type Throws = {
[x in 1 / 2 / 3 / 4 / 5 / 6]: number;
형 식 에 프 로 퍼 티 도 추 가 할 수 있 다 . E l e m e n t C o l L e c t i o n 을 예 로 살 펴 보 자 . E l e m e n t C o l l e c t i o n
은 숫 자 로 항 목 의 인 덱 스 를 가 리 킬 수 있 을 뿐 아 니 라 g e t 과 f i l t e r 함 수 , L e n g t h 프 로 퍼 티
등 을 추 가 로 제 공 한 다 .
3 장 형 식 시 스 템 1 3 7
type ElementCollection = {
[y: number]: HTMLElement | undefined;
get(index: number): HTMLElement | undefined;
length: number;
filter(callback: (element: HTMLElement) => boolean): ElementCollection;
j
인 덱 스 시 그 니 처 와 다 른 프 로 퍼 티 를 합 쳤 다 면 인 덱 스 시 그 니 처 를 넓 힌 집 합 이 특 정 프 로 퍼 티
의 형 식 을 포 함 해 야 한 다 . 앞 선 예 제 에 서 n u m b e r 시 그 니 처 와 다 른 프 로 퍼 티 s t r i n g 키 사 이 에
겹 치 는 부 분 이 없 다 . 하 지 만 문 자 열 을 s t r i n g 으 로 매 핑 하 는 인 덱 스 시 그 니 처 를 정 의 한 다 음
n u m b e r 형 식 의 c o u n t 프 로 퍼 티 를 정 의 하 면 타 입 스 크 립 트 오 류 가 일 어 난 다 .
type StringDictionary = {
[index: string]: string;
count: number;
1 / ' c o u n t ' 형 식 의 ' n u m b e r ' 속 성 을 ' s t r i n g ' 인 덱 스 유 형 ' s t r i n g ' 에
1 / 할 당 할 수 없 습 니 다 . t s ( 2 4 1 1 )
j
모 든 문 자 열 키 가 문 자 열 을 가 리 킨 다 고 정 의 했 고 , c o u n t 역 시 문 자 열 을 가 리 켜 야 하 므 로 이 는
당 연 한 오 류 다 . 따 라 서 타 입 스 크 립 트 는 이 런 모 호 한 상 황 을 허 용 하 지 않 는 다 . 이 오 류 를 없 아
려 면 모 든 프 로 퍼 티 의 형 식 을 허 용 하 도 록 인 덱 스 시 그 니 처 의 형 식 을 넓 혀 야 한 다 .
type StringOrNumberDictionary = {
[index: s t r i n g ] : s t r i n g | number;
c o u n t : n u m b e r ; 1 / 동 작 함
3;
이 렇 게 c o u n t 는 인 덱 스 시 그 니 처 와 프 로 퍼 티 형 식 모 두 의 하 위 집 합 이 다 .
인 덱 스 시 그 니 처 와 매 핑 된 형 식 은 웹 A P I 작 업 을 편 리 하 게 수 행 하 고 자 료 구 조 의 요 소 에 유 연
하 게 접 근 하 도 록 도 와 주 는 강 력 한 도 구 다 . 자 바 스 크 립 트 에 서 제 공 하 던 훌 륭 한 도 구 를 타 입 스
크 립 트 에 서 도 그 대 로 활 용 함 과 동 시 에 타 입 스 크 립 트 덕 에 형 식 안 정 성 도 확 보 할 수 있 게 되 었 다 .
1 3 8 실 무 로 통 하 는 타 입 스 크 립 트
3 . 1 1 빠 진 프 로 퍼 티 와 u n d e f i n e d 값 구 별 하 기
문 제 빠 진 프 로 퍼 티 와 u n d e f i n e d 값 은 서 로 다 른 문 제 다 ! 이 둘 을 구 별 해 야 하 는 상 황 에 놓 였 다 .
해 결 선 택 형 프 로 퍼 티 를 더 엄 격 하 게 처 리 하 도 록 t s c o n f i g 에 서 e x a c t o p t i o n a l P r o p e r t y T y p e s
를 활 성 화 한 다 .
논 의 현 재 개 발 중 인 소 프 트 웨 어 에 서 는 사 용 자 가 언 어 와 선 호 하 는 색 상 을 정 의 하 는 사 용 자
설 정 을 제 공 한 다 . 이 는 추 가 테 마 이 며 기 본 색 상 은 d e f a u l t ' 스 타 일 로 제 공 한 다 . 따 라 서 t h e m e
설 정 은 선 택 형 ( 정 의 해 도 되 고 정 의 하 지 않 아 도 됨 ) 이 다 . 타 입 스 크 립 트 로 선 택 형 프 로 퍼 티 를 다
음 처 럼 정 의 한 다 .
type Settings = {
language: "en" | "de" | "fr";
theme?: "dracula" | "monokai" | "github";
};
s t r i c t N u l l C h e c k s 를 활 성 화 한 다 음 t h e m e 을 다 른 코 드 에 서 접 근 하 면 가 능 한 값 의 수 가 증 가
한 다 . 즉 세 가 지 기 본 테 마 값 뿐 아 니 라 u n d e f i n e d 가 추 가 된 다 .
function applySettings(settings: Settings) {
/ / theme "dracula" | "monokai" | "github" | undefined
const theme = settings. theme;
}
이 는 프 로 퍼 티 를 설 정 했 는 지 확 인 할 때 아 주 도 움 이 되 는 동 작 이 다 . 프 로 퍼 티 를 설 정 하 지 않 았
다 면 런 타 임 오 류 가 발 생 할 수 있 기 때 문 이 다 . 타 입 스 크 립 트 가 선 택 형 프 로 퍼 티 에 u n d e f i n e d
를 추 가 한 것 까 진 좋 지 만 , 자 바 스 크 립 트 의 동 작 과 정 확 히 일 치 하 지 않 는 점 이 문 제 다 . 선 택 형
프 로 퍼 티 란 객 체 에 서 이 키 가 존 재 하 지 않 을 수 있 음 을 의 미 한 다 . 이 는 사 소 한 부 분 같 지 만 중
요 하 다 . 예 를 들 어 키 가 존 재 하 지 않 으 면 프 로 퍼 티 검 사 시 f a l s e 를 반 환 한 다 .
function getTheme (settings: Settings) {
if ('theme' in settings) { / / only true if the property is set!
return settings. theme;
3 장 형 식 시 스 템 1 3 9
}
return 'default';
}
const settings: Settings = {
language: "de",
! ! ! !
const settingsUndefinedTheme: Settings = {
language: "de",
theme: undefined,
console. log(getTheme(settings)) / / "default"
console. loggetTheme(settingsUndefinedTheme)) / / undefined
두 설 정 객 체 가 비 슷 해 보 이 지 만 서 로 다 른 결 과 를 반 환 한 다 . 심 지 어 u n d e f i n e d 테 마 는 유 효
한 값 으 로 취 급 하 지 않 는 다 . i n 검 사 는 프 로 퍼 티 존 재 여 부 만 을 알 려 주 므 로 타 입 스 크 립 트 가 거
짓 말 하 는 것 은 아 니 다 . g e t T h e m e 의 반 환 값 에 u n d e f i n e d 도 포 함 된 다 .
type Fn = typeof getTheme;
/ / type Fn = (settings: Settings)
// = "dracula" | "monokai" | "github" | "default" | undefined
값 이 올 바 른 지 확 인 하 는 더 좋 은 방 법 이 있 다 . 널 병 합 l l s h c o a l e s c i n g 연 산 자 를 이 용 해 다 음 처 럼
코 드 를 구 현 한 다 .
function getTheme(settings: Settings) {
return settings. theme ?? "default";
}
type Fn = typeof getTheme;
/ / type Fn = (settings: Settings)
/ / → "dracula" | "monokai" | "github" | "default"
i n 검 사 자 체 는 문 제 가 없 으 며 많 은 개 발 자 가 여 전 히 즐 겨 사 용 한 다 . 하 지 만 타 입 스 크 립 트 가
선 택 형 프 로 퍼 티 를 처 리 하 는 방 식 때 문 에 모 호 한 상 황 이 일 어 날 수 있 다 . 선 택 형 프 로 퍼 티 에 서
u n d e f i n e d 를 읽 는 동 작 자 체 에 는 문 제 가 없 지 만 , 선 택 형 프 로 퍼 티 를 u n d e f i n e d 로 설 정 하 는
1 4 0 실 무 로 통 하 는 타 입 스 크 립 트
것 은 올 바 른 행 동 이 아 니 다 . 이 제 e x a c t o p t i o n a L P r o p e r t y T y p e s 설 정 을 바 꾸 면 타 입 스 크 립
트 의 동 작 도 달 라 진 다 .
/ / exactOptionalPropertyTypesE true
const settingsUndefinedTheme: Settings = {
language: "de"
theme: undefined,
} ;
1 / ' { l a n g u a g e : " d e " ; t h e m e : u n d e f i n e d ; } ' 유 형 은
1 / ' e x a c t o p t i o n a l P r o p e r t y T y p e s : t r u e ' 가 있 는 ' S e t t i n g s ' 유 형 에 할 당 할
1 / 수 없 습 니 다 . 대 상 속 성 의 유 형 에 ' u n d e f i n e d ' 를 추 가 하 는 것 을 고 려 하 세 요 .
1 / ' t h e m e ' 속 성 의 형 식 이 호 환 되 지 않 습 니 다 .
1 / ' u n d e f i n e d ' 형 식 은 ' " d r a c u l a " : " m o n o k a i " i " g i t h u b " ' 형 식 에 할 당 할
1 / 수 없 습 니 다 . t s ( 2 3 7 5 )
e x a c t o p t i o n a l P r o p e r t y T y p e s 옵 션 을 이 용 하 면 타 입 스 크 립 트 의 동 작 을 좀 더 자 바 스 크 립 트
와 비 슷 하 게 유 지 할 수 있 다 . s t r i c t 모 드 는 이 플 래 그 를 포 함 하 지 않 으 므 로 이 런 문 제 가 발 생
했 다 면 직 접 이 플 래 그 를 설 정 해 야 한 다 .
3 . 1 2 열 거 형 사 용 하 기
문 제 타 입 스 크 립 트 열 거 형 e n m 은 훌 륭 하 게 추 상 화 를 제 공 한 다 . 하 지 만 열 거 형 은 다 른 형 식 시 스 템 과 다 르
게 동 작 하 는 것 같 다 .
해 결 열 거 형 보 다 는 c o n s t 식 같 은 대 안 을 활 용 한 다 .
열 거 형 을 사 용 한 다 . 열 거 형 의 문 제 가 무 엇 인 지 이 해 하 고 유 니 온 형
논 의 타 입 스 크 립 트 에 서 는 열 겨 형 을 이 용 해 이 름 이 있 는 상 수 집 합 을 정 의 할 수 있 으 므 로 문
서 화 에 도 움 을 주 거 나 구 분 되 는 상 황 집 합 을 만 들 수 있 다 .
열 거 형 은 e n u m 키 워 드 로 정 의 한 다 .
3 장 형 식 시 스 템 1 4 1
enum Direction {
Up,
Down,
Left,
Right,
클 래 스 처 럼 열 거 형 은 값 과 형 식 네 임 스 페 이 스 모 두 에 기 여 한 다 . 따 라 서 D i r e c t i o n 을 형 식 애
너 테 이 션 에 사 용 하 거 나 자 바 스 크 립 트 의 값 으 로 도 사 용 할 수 있 다 .
1 / 형 식 으 로 사 용
function movedirection: Direction) {
1 / . . .
}
1 / 값 으 로 사 용
move(Direction.Up);
열 거 형 은 자 바 스 크 립 트 의 문 법 적 확 장 이 다 . 즉 , 열 거 형 은 형 식 시 스 템 수 준 에 서 동 작 할 뿐 아
니 라 자 바 스 크 립 트 코 드 도 추 가 한 다 .
var Direction;
( f u n c t i o n ( D i r e c t i o n ) {
Direction[Direction["Up"] = 0] = "Up";
Direction[Direction["Down"] = 1] = "Down";
Direction[Direction["Left"] = 2] = "Left";
Direction[Direction["Right"] = 3] = "Right";
}) (Direction | | (Direction = (}));
e n u m 을 c o n s t e n u m 으 로 정 의 하 면 타 입 스 크 립 트 는 이 들 을 실 젯 값 으 로 대 치 하 며 , 코 드 가 생 성
되 지 않 도 록 한 다 .
const enum Direction {
Up,
Down,
Left,
Right,
3;
1 4 2 실 무 로 통 하 는 타 입 스 크 립 트
1 / c o n s t e n u m 을 사 용 하 면 타 입 스 크 립 트 는 m o v e ( D i r e c t i o n . U p ) 를
1 / 다 음 처 럼 변 환 한 다 .
move(0 /* Direction.Up */);
타 입 스 크 립 트 는 문 자 열 열 거 형 과 숫 자 열 거 형 을 모 두 지 원 하 는 데 , 이 들 은 서 로 아 주 다 르 게 동
작 한 다 .
기 본 적 으 로 타 입 스 크 립 트 의 열 거 형 은 숫 자 이 며 , 열 거 형 의 항 목 은 0 부 터 시 작 하 는 숫 자 를 자 동
으 로 할 당 받 는 다 . 열 거 형 항 목 의 시 작 지 점 과 실 젯 값 은 기 본 값 으 로 설 정 하 거 나 사 용 자 가 직 접
정 의 할 수 있 다 .
1 / 기 본 값
enum Direction {
Up, 11 0
Down, 1/ 1
Left, 1 2
Right, 1/ 3
3;
enum Direction {
Up = 1, 1 / 1
Down, 1 / 2
Left, 1 1 3
Right = 5, 115
숫 자 열 거 형 은 숫 자 유 니 온 형 식 과 같 은 집 합 을 정 의 한 다 .
type Direction = 0 | 1 | 2 1 3 ;
하 지 만 이 두 가 지 방 식 에 는 서 로 다 른 점 이 있 다 . 유 니 온 형 식 은 오 직 정 의 된 숫 자 만 허 용 하 지
만 숫 자 열 거 형 은 모 든 값 을 할 당 하 도 록 허 용 한 다 .
function movedirection: Direction) { / * . . . * / }
m o v e ( 3 0 ) ; / / 문 제 없 음 !
3 장 형 식 시 스 템 1 4 3
이 런 특 징 을 이 용 하 면 숫 자 열 거 형 으 로 플 래 그 를 구 현 할 수 있 다 .
1 / 사 람 의 특 징 . 여 러 가 지 가 있 을 수 있 음
enum Traits 1
None, 1 / 0 0 0 0
Friendly = 1, / / 0 0 0 1 또 는 1 < < 0
Mean = 1 < 1 , 1 / 0 0 1 0
Funny = 1 < 2 , 1 / 0 1 0 0
Boring = 1 < 3 , 1 / 1 0 0 0
}
/ / (0010 | 0100)= = = 0 1 1 0
l e t aPersonsTraits = Traits.Mean | Traits. Funny;
if ((aPersonsTraits & Traits.Mean) === Traits. Mean) {
1 / 사 람 은 무 엇 보 다 도 비 열 하 다 .
}
이 런 상 황 에 서 열 거 형 은 문 법 적 설 탕 m t a c t e s u g a r 3 을 제 공 한 다 . 컴 파 일 러 가 허 용 된 값 을 쉽 게 확
인 할 수 있 도 록 타 입 스 크 립 트 는 숫 자 열 거 형 의 호 환 값 을 n u m b e r 전 체 로 확 장 한 다 .
숫 자 대 신 문 자 열 로 열 거 형 을 정 의 할 수 있 다 . 문 자 열 열 거 형 을 정 의 할 때 각 항 목 을 문 자 열 로
직 접 정 의 해 야 하 며 숫 자 열 거 형 에 서 처 럼 자 동 으 로 값 을 할 당 할 수 없 다 .
enum Status {
Admin = "Admin",
User = "User", Moderator = "Moderator",
문 자 열 거 형 은 숫 자 열 거 형 보 다 제 한 적 이 다 . 없 으 며 실 제 정 의 한 문 자 열 값 만 사 용 할 수 있 다 .
문 자 열 거 형 에 서 는 모 든 문 자 열 집 합 을 허 용 할 수
function closeThread(threadId: number, status: Status): {
/ / . . .
}
3 옮 긴 이 개 발 자 들 이 편 리 하 게 이 용 할 수 있 도 록 제 공 하 는 문 법 을 ' s y n t a c t i c s u g a r ' 라 부 른 다 . 현 재 한 국 에 서 는 통 용 되 는 표 현 이 없 어 ' 문
법 적 설 탕 ' 으 로 직 역 했 다 .
1 4 4 실 무 로 통 하 는 타 입 스 크 립 트
closeThread (10, "Admin");
/ / ^ _ - " " A d m i n " ' 형 식 의 인 수 는 ' S t a t u s ' 형 식 의
매 개 변 수 에 할 당 될 수 없 습 니 다 . t s ( 2 3 4 5 )
c l o s e T h r e a d ( 1 0 , S t a t u s . A d m i n ) ; / / 동 작 함
타 입 스 크 립 트 의 다 른 형 식 과 달 리 문 자 열 거 형 은 명 목 상 형 식 ( m o m i m a l p c 이 다 . 따 라 서 값 집 합 이
같 은 두 열 거 형 은 서 로 호 환 되 지 않 는 다 .
enum Status 1
Admin = "Admin",
User = "User",
Moderator = "Moderator",
function closeThread (threadId: number, status: Status): {
/ ...
}
enum Roles {
Admin = "Admin",
User = "User",
Moderator = "Moderator",
3;
"
closeThread (10, Roles.Admin);
^ - - ' R o l e s . A d m i n ' 형 식 의 인 수 는 ' S t a t u s '
형 식 의 매 개 변 수 에 할 당 될 수 없 습 니 다 . t s ( 2 3 4 5 )
사 용 자 는 분 명 올 바 른 값 을 갖 고 있 지 만 여 러 분 이 정 의 한 열 거 형 을 모 르 는 상 황 에 서 혼 란 과 좌
절 을 일 으 킬 수 있 다 .
열 거 형 을 현 명 하 게 사 용 하 고 한 계 를 이 해 하 자 . 열 거 형 은 기 능 플 래 그 를 정 의 하 거 나 값 대 신 이
름 을 가 진 상 수 집 합 을 사 용 ( 즉 , 자 료 구 조 를 사 용 ) 하 도 록 유 도 하 는 상 황 에 서 유 용 하 다 .
노 트 타 입 스 크 립 트 5 . 0 부 터 숫 자 열 거 형 해 석 이 더 욱 엄 격 해 졌 다 . 이 제 숫 자 열 거 형 도 문 자 열 거 형 처 럼 명 목
상 형 식 으 로 동 작 하 며 전 체 숫 자 를 값 으 로 허 용 하 지 않 는 다 . 5 . 0 버 전 이 전 의 숫 자 열 거 형 의 기 능 을 사 용 하 는 코
드 가 아 직 남 아 있 을 수 있 으 므 로 주 의 하 자 !
3 장 형 식 시 스 템 1 4 5
c o n s t 를 붙 이 지 않 은 열 거 형 은 중 복 코 드 의 크 기 를 늘 릴 수 있 으 므 로 가 능 하 면 c o n s t 열 거 형
을 사 용 하 는 편 이 좋 다 . c o n s t 를 사 용 하 지 않 은 2 , 0 0 0 개 의 플 래 그 를 포 함 하 는 열 거 형 을 본 적
이 있 는 데 , 이 는 도 구 에 큰 부 담 을 주 고 컴 파 일 시 간 을 늘 렸 으 며 결 국 에 는 런 타 임 에 도 부 담 을
주 었 다 .
아 예 열 거 형 을 사 용 하 지 않 는 방 법 도 있 다 . 며 유 니 온 형 식 은 다 른 형 식 시 스 템 과 잘 조 화 를 이 룬 다 .
간 단 한 유 니 온 형 식 으 로 열 거 형 을 대 체 할 수 있 으
type Status = "Admin" | "User" | "Moderator";
function closeThread(threadId: number, status: Status) {
}
c l o s e T h r e a d ( 1 0 , " A d m i n " ) ; / / 문 제 없 음 !
열 거 형 을 사 용 하 면 적 절 한 도 구 를 제 공 받 을 뿐 아 니 라 원 하 지 않 는 코 드 를 생 성 할 위 험 없 이
형 식 안 전 성 도 얻 을 수 있 다 . 또 한 무 엇 을 전 달 해 야 하 고 값 을 어 디 에 서 얻 어 야 할 지 명 확 해 진 다 .
객 체 와 이 름 을 갖 는 식 별 자 를 포 함 한 열 거 형 으 로 코 드 를 구 현 할 때 는 c o n s t 객 체 와 V a l u e s 헬
퍼 형 식 을 사 용 하 면 원 하 는 기 능 을 쉽 게 구 현 할 수 있 으 며 훨 씬 자 바 스 크 립 트 와 비 슷 한 결 과 를
만 들 수 있 다 . 이 기 법 을 문 자 열 유 니 온 에 도 적 용 할 수 있 다 .
const Direction = {
Up: 0,
Down: 1,
Left: 2,
Right: 3,
} as const;
1 / D i r e c t i o n 의 상 숫 값 얻 기
type Direction = (typeof Direction)[keyof typeof Direction];
/ / ( t y p e o f D i r e c t i o n ) [ k e y o f t y p e o f D i r e c t i o n ] 는 0 : 1 | 2 | 3 값 방 출
function movedirection: Direction) {
/ . . .
}
m o v e ( 3 0 ) ; / / 오 류 !
1 4 6 실 무 로 통 하 는 타 입 스 크 립 트
m o v e ( 0 ) ; / / 동 작 함 !
m o v e ( D i r e c t i o n . L e f t ) ; 1 / 역 시 동 작 함 !
특 히 다 음 행 이 흥 미 롭 다 .
1 / = 0 | 1 | 2 1 3
type Direction = (typeof Direction) [keyof typeof Direction];
조 금 특 이 한 동 작 이 일 어 난 다 .
• 이 름 과 같 은 값 으 로 형 식 을 선 언 했 다 . 타 입 스 크 립 트 에 서 는 값 과 형 식 네 임 스 페 이 스 가 구 분 되 므 로 이 런 동
작 을 수 행 할 수 있 다 .
• t y p e o f 연 산 자 를 이 용 해 D i r e c t i o n 의 형 식 을 얻 는 다 . D i r e c t i o n 은 c o n s t 컨 텍 스 트 에 존 재 하 므 로 리
터 럴 형 식 을 얻 는 다 .
• D i r e c t i o n 의 형 식 의 자 체 키 로 D i r e c t i o n 에 인 덱 스 를 추 가 했 는 데 , 이 때 객 체 의 오 른 쪽 값 은 0 , 1 , 2 , 3
이 된 다 . 이 는 숫 자 유 니 온 형 식 이 다 .
유 니 온 형 식 을 이 용 하 면 깜 짝 놀 랄 일 은 일 어 나 지 않 는 다 .
• 출 력 결 과 코 드 가 무 엇 인 지 알 수 있 다 .
• 누 군 가 문 자 열 열 거 형 을 숫 자 열 거 형 으 로 바 꾼 다 고 해 서 동 작 까 지 바 뀌 지 않 는 다 .
• 필 요 한 곳 에 형 식 안 정 성 을 갖 췄 다 .
• 열 거 형 으 로 제 공 했 던 것 과 같 은 규 칙 을 동 료 와 사 용 자 에 게 제 공 한 다 .
사 실 상 단 순 한 문 자 열 유 니 온 형 식 은 형 식 안 전 성 , 모 든 것 을 제 공 한 다 .
자 동 완 성 , 예 측 할 수 있 는 동 작 등 필 요 한
3 장 형 식 시 스 템 1 4 7
3 . 1 3 구 조 적 형 식 시 스 템 에 명 목 상 형 식 정 의 하 기
문 제 애 플 리 케 이 션 에 같 은 기 본 형 식 을 가 리 키 는 별 칭 이 지 만 의 미 는 완 전 히 다 른 여 러 형 식 이 있 다 . 구 조
적 형 식 시 스 템 에 서 는 이 들 을 동 일 하 게 취 급 하 지 만 그 러 면 안 되 는 상 황 이 다 !
해 결 래 퍼 클 래 스 를 사 용 하 거 나 리 터 럴 객 체 형 식 으 로 기 본 형 의 인 터 섹 션 을 만 들 고 이 를 이
용 해 두 정 수 를 구 별 한 다 .
논 의 타 입 스 크 립 트 의 형 식 로 호 환 된 다 는 의 미 다 .
시 스 템 은 구 조 적 이 다 . 두 형 식 의 모 양 이 같 으 면 두 형 식 의 값 은 서
type Person = {
name: string;
age: number;
type Student = {
name: string;
age: number;
function acceptsPerson(person: Person) {
/ / . . .
}
const student: Student = {
name: "Hannah",
age: 27,
a c c e p t s P e r s o n ( s t u d e n t ) ; 1 / 모 두 동 작 함
자 바 스 크 립 트 는 주 로 객 체 리 터 럴 에 의 존 하 며 타 입 스 크 립 트 는 형 식 이 나 이 들 리 터 럴 의 모 양 을
추 론 하 려 노 력 한 다 . 이 런 상 황 에 서 구 조 적 형 식 시 스 템 은 많 은 도 움 을 준 다 . 특 히 어 디 에 서 나
등 장 할 수 있 는 다 양 한 값 들 이 인 터 페 이 스 , 형 식 정 의 와 호 환 되 어 야 하 기 때 문 이 다 .
하 지 만 형 식 과 관 련 해 서 조 금 더 명 확 해 야 할 때 가 있 다 . 객 체 형 식 을 살 펴 보 면 서 k i n d 프 로 퍼
티 를 사 용 한 구 별 된 유 니 온 ( 3 . 2 절 ) 과 선 택 형 n e v e r 로 배 타 적 논 리 합 모 델 만 들 기 ( 3 . 8 절 ) 등
1 4 8 실 무 로 통 하 는 타 입 스 크 립 트
의 기 법 을 배 웠 다 . 3 . 1 2 절 에 서 설 명 했 듯 이 문 자 열 열 거 형 도 명 목 상 형 식 이 다 .
객 체 형 식 과 열 거 형 에 서 는 이 정 도 로 충 분 했 다 . 하 지 만 같 은 기 본 형 식 의 집 합 을 값 으 로 갖
는 두 가 지 다 른 형 식 이 있 다 면 문 제 가 생 긴 다 . 예 를 들 어 8 자 리 의 계 좌 번 호 와 잔 고 가 모 두
n u m b e r 형 식 일 때 이 들 을 혼 합 한 다 면 어 떻 게 될 까 ? 잔 고 가 8 자 리 숫 자 라 면 기 분 좋 겠 지 만 , 이
는 올 바 른 값 은 아 닐 것 이 다 .
또 는 사 용 자 의 입 력 문 자 열 을 검 증 해 야 하 는 데 , 오 직 검 증 된 사 용 자 입 력 만 을 프 로 그 램 에 서 사
용 하 고 안 전 하 지 않 을 수 있 는 원 래 문 자 열 은 사 용 하 지 말 아 야 하 는 상 황 을 그 려 보 자 .
타 입 스 크 립 트 는 형 식 시 스 템 안 에 서 명 목 상 형 식 지 원 을 흉 내 내 며 더 높 은 보 안 성 을 제 공 한
다 . 이 기 법 으 로 인 해 가 능 한 값 의 집 합 을 고 유 프 로 퍼 티 와 분 리 하 므 로 같 은 값 이 같 은 집 합 으
로 떨 어 지 는 일 을 방 지 한 다 .
감 싸 는 클 래 스 를 이 용 해 이 를 해 결 하 는 방 법 이 있 다 . 값 을 직 접 사 용 하 지 않 고 클 래 스 로 각 값
을 감 싼 다 . p r i v a t e k i n d 프 로 퍼 티 로 이 들 이 겹 치 지 않 게 한 다 .
class Balance 1
private kind = "balance";
value: number;
constructor (value: number) {
this.value = value;
}
}
class AccountNumber {
private kind = "account";
value: number;
constructor (value: number) {
this.value = value;
}
}
p r i v a t e 프 로 퍼 티 를 사 용 했 으 므 로 타 입 스 크 립 트 가 두 클 래 스 를 구 분 한 다 는 점 이 핵 심 이 다 .
현 재 두 k i n d 프 로 퍼 티 모 두 문 자 열 형 식 이 다 . 이 들 은 다 른 값 을 포 함 하 지 만 내 부 적 으 로 는 언
제 든 값 이 바 뀔 수 있 다 . 하 지 만 클 래 스 는 다 르 게 동 작 한 다 . p r i v a t e L p r o t e c t e d 멤 버 가 있
3 장 형 식 시 스 템 1 4 9
으 면 타 입 스 크 립 트 는 같 은 선 언 으 로 부 터 이 두 멤 버 가 왔 을 때 만 두 형 식 이 호 환 된 다 고 간 주 한
다 . 그 렇 지 않 으 면 이 둘 은 호 환 되 지 않 는 다 .
이 특 징 을 이 용 해 좀 더 범 용 적 으 로 패 턴 을 정 리 할 수 있 다 . k i n d 멤 버 를 정 의 하 고 값 을 설
정 하 는 대 신 , V o i d 형 식 인 _ n o m i n a l 멤 버 를 각 클 래 스 선 언 에 정 의 한 다 . 이 로 써 n o m i n a l
이 라 는 사 용 할 수 없 는 멤 버 를 추 가 해 클 래 스 를 분 리 할 수 있 다 . V o i d 형 식 의 _ n o m i n a l 은
u n d e t i n e d 로 밖 에 설 정 할 수 없 으 며 u n d e f i n e d 는 거 짓 부 류 의 값 이 므 로 , 결 국 이 멤 버 는 사 용
할 수 없 게 된 다 .
class Balance {
private _nominal: void = undefined;
value: number;
constructor(value: number) {
t h i s . v a l u e = value;
}
}
class AccountNumber 1
private _nominal: void = undefined;
value: number;
constructor(value: number) {
t h i s . v a l u e = value;
}
}
const account = new AccountNumber (12345678);
const balance = new Balance (10000);
function acceptBalance(balance: Balance) {
1 . . . .
}
a c c e p t B a l a n c e ( b a l a n c e ) ; / / 동 작 함
acceptBalance(account);
1 / ^ ' A c c o u n t N u m b e r ' 형 식 의 인 수 는 ' B a l a n c e ' 형 식 의 매 개 변 수 에 할 당 될
/ / 수 없 습 니 다 .
1 / 형 식 에 별 도 의 프 라 이 빗 속 성 ' _ n o m i n a l ' 선 언 이 있 습 니 다 . t s ( 2 3 4 5 )
1 5 0 실 무 로 통 하 는 타 입 스 크 립 트
이 렇 게 같 은 값 집 합 을 갖 는 두 개 의 다 른 형 식 을 정 의 했 다 . 원 래 형 식 을 감 쌌 으 므 로 원 래 값 을
얻 으 려 면 감 싼 부 분 을 푸 는 과 정 이 필 요 하 다 는 점 이 이 기 법 의 단 점 이 다 .
k i n d 프 로 퍼 티 를 포 함 하 는 객 체 형 식 으 로 기 본 형 식 의 인 터 섹 션 을 만 들 어 명 목 상 형 식 을 흉 내
내 는 방 법 도 있 다 . 이 렇 게 하 면 원 래 형 식 의 모 든 동 작 을 그 대 로 유 지 하 지 만 , 이 들 형 식 을 다 르
게 사 용 하 고 싶 다 는 사 실 을 형 식 어 서 션 으 로 타 입 스 크 립 트 에 알 려 야 한 다 .
3 . 9 절 에 서 배 웠 듯 이 , 원 래 형 식 의 상 위 형 식 이 나 하 위 형 식 으 로 는 안 전 하 게 형 식 어 서 션 을 사
용 할 수 있 다 .
type Credits = number & { _kind: "credits" };
type AccountNumber = number & {_kind: "accountNumber" };
const account = 12345678 a s AccountNumber;
let balance = 10000 as Credits;
c o n s t amount = 3000 a s Credits;
function increase(balance: Credits, amount: Credits): Credits {
r e t u r n (balance + amount) a s Credits;
}
balance = increase(balance, amount);
balance = increase(balance, account);
1 / ^ ' A c c o u n t N u m b e r ' 형 식 의 인 수 는 ' C r e d i t s ' 형 식 의 매 개 변 수 에 할 당 될 수 없 습 니 다 .
1 1 ' A c c o u n t N u m b e r ' 형 식 은 ' { _ k i n d : " c r e d i t s " ; } ' 형 식 에 할 당 할 수 없 습 니 다 .
1 / ' _ k i n d ' 속 성 의 형 식 이 호 환 되 지 않 습 니 다 .
1 1 ' " a c c o u n t N u m b e r " ' 형 식 은 c r e d i t s " ' 형 식 에 할 당 할 수 없 습 니 다 . t s ( 2 3 4 5 )
b a l a n c e 와 a m o u n t 는 원 래 의 도 대 로 동 작 하 지 만 다 시 숫 자 를 생 성 한 다 는 점 에 주 목 하 자 . 따
라 서 다 른 어 서 션 을 추 가 해 야 한 다 .
onst result = balance + amount; // result= numbe
o n s t c r e d i t s = ( b a l a n c e + a m o u n t ) a s C r e d i t s : / / c r e d i t s @ C r e d i t
두 기 법 모 두 장 단 점 이 있 으 며 어 떤 기 법 을 사 용 할 지 는 여 러 분 의 시 나 리 오 에 따 라 달 라 진 다 .
두 기 법 모 두 형 식 시 스 템 의 동 작 을 이 해 하 는 커 뮤 니 티 가 제 안 한 방 법 이 다 .
3 장 형 식 시 스 템 1 5 1
깃 허 브 의 타 입 스 크 립 트 이 슈 트 랙 커 ( h t t p s : / / o r e i l . L y / X x m u V ) 에 는 명 목 상 형 식 과 관 련 한 형
식 시 스 템 의 논 의 가 있 으 며 여 러 가 능 성 을 조 사 하 고 있 다 . 심 볼 의 u n i q u e 키 워 드 를 이 용 해 이
를 구 별 하 자 는 아 이 디 어 도 그 중 하 나 다 .
1 / 가 상 의 코 드 . 실 제 동 작 하 진 않 는 다 !
type Balance = unique number;
type AccountNumber = unique number;
집 필 시 점 에 는 이 아 이 디 어 를 포 함 한 다 양 한 아 이 디 어 가 논 의 중 이 었 다 .
3 . 1 4 문 자 열 하 위 집 합 의 느 슨 한 자 동 완 성 활 성 화 하 기
문 제 A P I 는 모 든 문 자 열 을 전 달 할 수 있 어 야 하 는 데 , 그 중 에 서 도 몇 가 지 문 자 열 값 을 자 동 완 성 으 로 보
여 주 려 한 다 .
해 결 문 자 열 리 터 럴 유 니 온 형 식 에 s t r i n g & { } 를 추 가 한 다 .
논 의 콘 텐 츠 관 리 시 스 템 에 접 근 하 는 A P I 를 정 의 한 다 고 가 정 하 자 . p o s t , p a g e , a s s e t 등 의
콘 텐 츠 형 식 을 이 미 정 의 했 으 며 개 발 자 는 직 접 자 신 만 의 형 식 도 정 의 할 수 있 다 .
r e t r i e v e 함 수 는 콘 텐 츠 형 식 하 나 를 매 개 변 수 로 받 아 관 련 항 목 을 반 환 한 다 .
t y p e E n t r y = {
1 / 개 발 중
};
function retrieve(contentType: string): Entry] {
1 / 개 발 중
}
이 코 드 는 의 도 대 로 잘 동 작 하 지 만 , 더 나 아 가 사 용 자 에 게 콘 텐 츠 형 식 의 기 본 옵 션 의 힌 트 를
제 공 하 고 싶 다 . 는 헬 퍼 형 식 을 만 들 문 자 열 로 유 니 온 을 만 들 고 미 리 정 의 한 콘 텐 츠 형 식 을 포 함 하 는 목 록 을 보 여 주
수 있 다 .
1 5 2 실 무 로 통 하 는 타 입 스 크 립 트
실 무 로 통 하 는 타 입 스 크 립 트
type ContentType = "post" | "page" | "asset" | string;
function retrieve(content: ContentType): Entry] {
1 / 개 발 중
}
이 는 현 재 문 제 를 어 느 정 도 해 결 할 수 있 지 만 , p o s t , p a g e , a s s e t 등 은 s t r i n g 의 하 위 형 식
이 므 로 이 들 을 s t r i n g 과 함 께 유 니 온 으 로 담 는 순 간 세 부 정 보 는 넓 은 집 합 으 로 삼 켜 진 다 .
따 라 서 [ 그 림 3 - 3 ] 에 서 처 럼 편 집 기 로 구 문 완 성 힌 트 를 얻 을 수 없 다 .
autocomplete.ts - chapter03
. . .
凸
8
Ts autocomplete.ts •
Ts autocomplete.ts
1 type Entry = {
2 1 / . . .
3
4
5
6
7
8
9
1 0
1 1
1 2
type ContentType = "post" | "page" | "asset" | string;
function retrieve(content: ContentType): Entryll {
return [1
} retrieve(content: string): Entryll
retrieve(*t
• Live Share Ln 12, Col 11 Spaces: 4 UTF-8 LF (d TypeScript & Q
그 림 3 - 3 타 입 스 크 립 트 가 C o n t e n t T y p e 을 전 체 s t r i n g 집 합 으 로 넓 혔 으 므 로 자 동 완 성 정 보 를 얻 을 수 없 다 .
빈 객 체 형 식 { } 과 s t r i n g 의 인 터 섹 션 을 사 용 해 자 동 완 성 정 보 를 유 지 하 고 리 터 럴 형 식 을 보
존 할 수 있 다 .
type ContentType = "post" | "page" | "asset" | string & t};
3 장 형 식 시 스 템 1 5 3
이 코 드 로 무 엇 이 바 뀌 었 는 지 알 아 채 기 어 려 울 수 있 다 . 인 터 섹 션 은 C o n t e n t T y p e 과 호 환 되 는
값 의 수 를 바 꾸 지 않 지 만 , 타 입 스 크 립 트 가 하 위 형 식 을 줄 이 지 못 하 게 하 고 리 터 럴 형 식 을 보
존 하 도 록 설 정 한 다 .
인 터 섹 션 의 효 과 는 [ 그 림 3 - 4 ] 에 서 확 인 할 수 있 다 . 이 제 C o n t e n t T y p e 은 s t r i n g 으 로 줄 어 들
지 않 으 며 해 당 구 분 에 서 사 용 할 수 있 는 모 든 리 터 럴 값 을 텍 스 트 편 집 기 에 서 자 동 완 성 으 로
추 가 할 수 있 다 .
. . . autocomplete.ts - chapter03
昭
凸
…
・ ・
t s autocomplete.ts
Ts autocomplete.ts > …
1 type Entry = {
1 1 . .
3
4
5
6
7
8
9
1 0
1 1
1 2
type ContentType = "post" | "page" | "asset" | string & 1};
function retrieve(content: ContentType): Entryl] {
1 1 . . .
return (1
}
retrieve(content: ContentType): E n t r y
retrieve ( ' ' !
© asset
@ page
E post
日 . . .
a s s e t
恐
8 L i v e Share 그 림 3 - 4 s t r i n g 과 빈 객 체 의 인 터 섹 션 으 로 구 문 완 성 힌 트 를 유 지 함
Ln 12, Col 11 Spaces: 4 UTF-8 LF (d T y p e S c r i p t ?
여 전 히 모 든 문 자 열 은 C o n t e n t T y p e 의 유 효 한 값 이 며 , 단 지 A P I 를 사 용 하 는 개 발 자 에 게 힌 트
를 제 공 해 서 개 발 자 경 험 을 바 꾸 었 을 뿐 이 다 .
리 액 트 용 D e f i n i t e l y T y p e d 형 식 정 의 ( h t t p s : / / o r e i l . l y / e p b L v ) 나 C S S T y p e ( h t t p s : / /
o r e i l . l y / l w t ( 5 ) 같 은 유 명 한 라 이 브 러 리 에 서 도 이 기 법 을 사 용 했 다 .
1 5 4 실 무 로 통 하 는 타 입 스 크 립 트
. CHAPTER 4
제 네 릭
지 금 까 지 자 바 스 크 립 트 의 유 연 성 을 활 용 하 면 서 형 식 시 스 템 으 로 이 를 형 식 화 하 는 방 법 을 살 펴
봤 다 . 동 적 으 로 형 식 이 정 해 지 는 언 어 에 정 적 형 식 을 추 가 해 서 의 도 를 명 확 히 밝 히 고 , 도 구 의
도 움 을 얻 으 며 , 미 리 버 그 를 발 견 할 수 있 다 .
하 지 만 자 바 스 크 립 트 의 일 부 는 정 적 형 식 을 전 혀 고 려 하 지 않 는 다 . 예 를 들 어 i s K e y A v a i l a b l e I n o b j e c t
함 수 는 특 정 키 를 어 떤 객 체 에 서 사 용 할 수 있 는 지 만 검 사 하 며 구 체 적 형 식 이 무 엇 인 지 는 신 경
쓰 지 않 는 다 . 타 입 스 크 립 트 의 구 조 적 형 식 시 스 템 을 이 용 해 아 주 넓 은 형 식 을 사 용 하 거 나 아 주
엄 격 한 형 식 을 사 용 해 이 런 함 수 를 형 식 화 할 수 있 다 . 여 기 서 전 자 는 정 보 를 , 후 자 는 유 연 성 을
희 생 하 게 된 다 .
하 지 만 우 리 는 무 엇 도 희 생 하 지 않 은 채 유 연 성 과 정 보 라 는 두 마 리 토 끼 를 모 두 잡 고 싶 다 . 타
입 스 크 립 트 의 제 네 릭 을 이 용 하 면 두 가 지 를 모 두 얻 을 수 있 다 . 제 네 릭 을 이 용 해 복 잡 한 관 계
를 묘 사 하 고 아 직 정 의 되 지 않 은 자 료 구 조 를 형 식 화 할 수 있 다 .
제 네 릭 그 리 고 함 께 제 공 되 는 매 핑 된 형 식 , 형 식 맵 , 형 식 변 경 자 , 헬 퍼 형 식 등 덕 분 에 메 타 형
식 의 세 계 에 진 입 할 수 있 다 . 이 메 타 형 식 세 계 에 서 는 기 존 형 식 에 근 거 를 둔 새 형 식 을 만 들
고 , 새 형 식 으 로 기 존 코 드 에 서 발 생 할 수 있 는 버 그 를 찾 고 , 형 식 간 의 관 계 를 그 대 로 유 지 할
수 있 다 .
이 제 고 급 타 입 스 크 립 트 개 념 으 로 진 입 한 다 . 하 지 만 우 리 가 정 의 하 지 않 는 한 호 랑 이 는 존 재 할
수 없 으 므 로 호 랑 이 굴 에 들 어 가 는 것 처 럼 두 려 워 할 필 요 는 없 다 .

