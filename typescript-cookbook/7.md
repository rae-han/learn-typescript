# 7장 가변 튜플 형식

튜플 형식은 각 요소의 형식이 정해지고 길이가 고정된 배열이다. 가변 튜플 형식(variadic tuple type)은 정해진 길이와 각 요소의 형식은 알려졌지만 정확한 모양은 아직 정의되지 않은 형식이다. 이를 함수 시그니처에 사용하면 함수에서 얻는 정보를 극대화할 수 있다.

## 7.1 concat 함수 형식화 하기

**문제** 두 배열을 가져다 연결하는 `concat` 함수를 정확히 형식화하고 싶다.

**해결** 가변 튜플 형식을 이용한다.

```ts
function concat(arr1, arr2) {
  return [...arr1, ...arr2];
}
```

**논의**
이 함수를 형식화하려면 배열에 있는 각 요소의 형식을 알아야 한다. 튜플을 이용하면 각 요소의 형식을 알 수 있지만, 모든 가능한 시나리오를 고려하면 수많은 오버로드가 필요하다:

```ts
// 두 번째 배열이 빈 상황을 고려한 7개의 오버로드
function concat(arr1: [], arr2: []): [];
function concat<A>(arr1: [A], arr2: []): [A];
function concat<A, B>(arr1: [A, B], arr2: []): [A, B];
// ... 계속 늘어남
```

가변 튜플 형식을 이용하면 간단하다.

### 튜플 형식의 기본

```ts
type PersonProps = [string, number];
const [name, age]: PersonProps = ['Stefan', 37];
```

### 가변 튜플 형식

```ts
type Foo<T extends unknown[]> = [string, ...T, number];
type T1 = Foo<[boolean]>; // [string, boolean, number]
type T2 = Foo<[number, number]>; // [string, number, number, number]
type T3 = Foo<[]>; // [string, number]
```

가변 튜플 형식은 튜플의 어디에서나 몇 번이고 반복해서 등장할 수 있다:

```ts
type Bar<T extends unknown[], U extends unknown[]> = [...T, string, ...U];
type T4 = Bar<[boolean], [number]>; // [boolean, string, number]
type T5 = Bar<[number, number], [boolean]>; // [number, number, string, boolean]
type T6 = Bar<[], []>; // [string]
```

### concat 형식화

```ts
function concat<T extends unknown[], U extends unknown[]>(arr1: T, arr2: U): [...T, ...U] {
  return [...arr1, ...arr2];
}

// const test: (string | number)[]
const test = concat([1, 2, 3], [6, 7, 'a']);
```

튜플 형식을 정확히 얻으려면 제네릭 배열 형식을 튜플 형식으로 펼쳐야 한다:

```ts
function concat<T extends unknown[], U extends unknown[]>(arr1: [...T], arr2: [...U]): [...T, ...U] {
  return [...arr1, ...arr2];
}

// const test: [number, number, number, number, number, string]
const test = concat([1, 2, 3], [6, 7, 'a']);
```

> **팁**: 요소를 미리 알 수 없는 배열을 전달해도 배열 형식을 얻는다. 이 동작을 한 형식으로 기술할 수 있으므로 함수 오버로드로 모든 가능성을 정의하는 방법보다 훨씬 유연하며 가독성이 좋다.

```ts
declare const a: string[];
declare const b: number[];

// const test: (string | number)[]
const test = concat(a, b);
```

> **2025 업데이트**: TypeScript 5.0+에서 `const` 타입 매개변수를 사용하면 튜플 추론이 더 정확해진다:
> ```ts
> function concat<const T extends readonly unknown[], const U extends readonly unknown[]>(
>   arr1: T, arr2: U
> ): [...T, ...U] {
>   return [...arr1, ...arr2] as [...T, ...U];
> }
> ```


## 7.2 promisify 함수 형식화 하기

**문제** 콜백 스타일의 함수를 프로미스로 바꾸고 완벽히 형식화하려 한다.

**해결** 가변 튜플 형식으로 함수 인수를 제네릭으로 만든다.

**논의**
자바스크립트에 프로미스가 존재하기 전에는 콜백을 이용해 비동기 프로그래밍을 구현하는 것이 상식이었다:

```ts
function loadFile(filename: string, encoding: string, callback: (result: File) => void) {
  // 구현 중
}

loadFile('/data.json', 'utf-8', (result) => {
  // 파일을 이용한 작업 수행
});
```

많은 비동기 호출을 처리하면 콜백 지옥이 발생한다. 프로미스를 이용하면 연쇄 호출로 깔끔해진다:

```ts
const file = await loadFilePromise('./data.txt', 'utf-8');
const url = await file.text();
const data = await request(url);
```

콜백 패턴을 자동으로 Promise로 바꾸는 `promisify` 함수를 만들자.

### 함수 헤더를 튜플로 정의

모든 함수 헤더는 튜플 형식으로 정의할 수 있다:

```ts
declare function hello(name: string, msg: string): void;
// 다음과 같음
declare function hello(...args: [string, string]): void;

// 아주 유연하게 정의 가능
declare function h(a: string, b: string, c: string): void;
// 다음과 같음
declare function h(...r: [string, string, string]): void;
```

### 콜백 함수를 튜플로 표현

```ts
type Fn<Args extends unknown[], Res> = (...args: [...Args, (result: Res) => void]) => void;

type LoadFileFn = Fn<[string, string], File>;
type RequestFn = Fn<[URL], JSON>;
```

### promisify 구현

```ts
function promisify<Args extends unknown[], Res>(
  fn: (...args: [...Args, (result: Res) => void]) => void,
): (...args: Args) => Promise<Res> {
  return function (...args: Args) {
    return new Promise((resolve) => {
      function callback(res: Res) {
        resolve(res);
      }

      fn.call(null, ...[...args, callback]);
    });
  };
}
```

> **팁**: 이 함수는 다음 작업을 수행한다:
> 1. 콜백을 제외한 모든 매개변수를 받는 함수를 반환한다
> 2. 새로 만든 `Promise`를 반환한다
> 3. 콜백을 만들어 `Promise`의 `resolve` 함수를 호출한다
> 4. 원래 함수에 기존 인수와 새 콜백을 붙여 호출한다

> **노트**: Node.js에는 이미 `util.promisify`가 내장되어 있다. 이 예제는 가변 튜플 타입의 활용법을 보여주기 위한 것이다.


## 7.3 curry 함수 형식화 하기

**문제** 커링(currying) 함수를 형식화하려 한다. 커링이란 여러 인수를 받는 함수를 한 개의 인수를 받는 일련의 함수로 변환하는 기법이다.

**해결** 조건부 형식에 가변 튜플 형식을 조합하여 첫 매개변수를 잘라낸다.

**논의**
커링은 함수 인수 중 일부만 '적용'한다는 개념을 활용한다:

```ts
function add(a: number, b: number) {
  return a + b;
}

const curriedAdd = curry(add); // (a: number) => (b: number) => number
const add5 = curriedAdd(5); // (b: number) => number
const result1 = add5(2); // 7
const result2 = add5(3); // 8
```

### 자바스크립트 구현

```ts
function curry(fn) {
  let curried = (...args) => {
    // 충분히 인수를 모으지 않았다면
    if (fn.length != args.length) {
      // 인수를 부분 적용하고 콜렉터 함수를 반환
      return curried.bind(null, ...args);
    }
    // 그렇지 않으면 모든 함수 호출
    return fn(...args);
  };
  return curried;
}
```

### Curried 타입 정의

```ts
type Curried<F> = F extends (...args: infer A) => infer R
  ? A extends [infer F, ...infer L]
    ? L extends []
      ? (a: F) => R
      : (a: F) => Curried<(...args: L) => R>
    : () => R
  : never;
```

단계별 동작:

1. 형식이 실제 함수인지 검사하고 인수를 `A`, 반환 형식을 `R`로 추론
2. 첫 번째 인수를 `F`로 잘라내고 나머지를 `L`에 저장
3. 남은 인수가 없으면 인수를 받지 않는 함수 반환
4. 인수가 남았으면 남은 매개변수로 `Curried` 형식을 재귀 호출

### 최종 구현

```ts
function curry<F extends Function>(fn: F): Curried<F> {
  let curried: Function = (...args: any) => {
    if (fn.length != args.length) {
      return curried.bind(null, ...args);
    }
    return fn(...args);
  };
  return curried as Curried<F>;
}
```

> **팁**: 커링은 함수형 프로그래밍에서 핵심 개념이다. 이벤트 핸들러나 콜백에서 일부 인수를 미리 고정할 때 유용하다.


## 7.4 유연한 curry 함수 형식화 하기

**문제** 7.3절의 `curry` 함수는 임의의 인수를 허용하지만, 형식은 한 번에 한 인수만 허용한다.

**해결** 모든 가능한 튜플 조합을 덮는 함수 오버로드를 만든다.

**논의**
`curry` 함수 자체는 정해지지 않은 수의 인수를 받는다:

```ts
function addThree(a: number, b: number, c: number) {
  return a + b + c;
}

const adder = curried(addThree);
const add7 = adder(5, 2); // 여러 인수를 한 번에 적용
const result = add7(2);
```

가능한 모든 형식:

```ts
type Adder = (a: number) => (b: number) => (c: number) => number;
type Adder = (a: number) => (b: number, c: number) => number;
type Adder = (a: number, b: number) => (c: number) => number;
type Adder = (a: number, b: number, c: number) => number;
```

### Overloads 타입

모든 부분 적용을 만드는 `Overloads` 형식:

```ts
type Overloads<A extends any[]> = A extends [infer A, ...infer L] ? [A] | [A, ...Overloads<L>] | [] : [];

// type Overloaded = [] | [string, number, string] | [string] | [string, number]
type Overloaded = Overloads<[string, number, string]>;
```

### Remove 타입

두 튜플을 탐색하면서 요소를 잘라내는 헬퍼:

```ts
type Remove<T extends any[], U extends any[]> = U extends [any, ...infer UL]
  ? T extends [any, ...infer TL]
    ? Remove<TL, UL>
    : never
  : T;
```

### 최종 Curried 타입

```ts
function curry<A extends any[], R extends any>(fn: (...args: A) => R): Curried<A, R> {
  // 이전 코드 참고
}

type Curried<A extends any[], R extends any> = A extends [infer F, ...infer L]
  ? <K extends Overloads<L>>(arg: F, ...args: K) => Curried<Remove<L, K>, R>
  : R;
```

> **팁**: 이제 `curry`에 전달할 수 있는 모든 함수에 유연하게 사용할 수 있다. 한 번에 여러 인수를 적용해도 타입 추론이 정확하게 동작한다.


## 7.5 가장 단순한 curry 함수 형식화 하기

**문제** 복잡한 curry 형식화는 유용하지만 단점도 많다. 더 단순한 해결책은?

**해결** 한 개의 순차적 단계만을 포함하는 `curry` 함수를 만든다.

**논의**
7.3절과 7.4절의 복잡한 형식은 몇 가지 단점이 있다:

- 인수에 `any`를 사용하고 형식 어서션을 사용해 형식 검사를 사실상 비활성화한다
- 인수 이름을 유지할 수 없다
- 자동 완성 기능이 제한된다

### 간단한 구현

```ts
function curry(f, ...t) {
  return (...u) => f(...t, ...u);
}
```

### 형식 추가

```ts
type Fn<T extends any[], U extends any[]> = (...args: [...T, ...U]) => any;

function curry<T extends any[], U extends any[], R>(f: (...args: [...T, ...U]) => R, ...t: T) {
  return (...u: U) => f(...t, ...u);
}
```

| 접근 방식 | 장점 | 단점 |
|----------|------|------|
| 복잡한 커링 (7.3, 7.4) | 유연한 부분 적용 | 타입 안전성 낮음, 자동완성 제한 |
| 단순한 커링 (7.5) | 100% 타입 안전, 자동완성 | 한 단계만 부분 적용 |

> **팁**: 이 접근의 장점은 **100% 형식 안전성**, **자동 완성 제공**, **원래 형식의 레이블 유지**다. 실무에서는 이 버전이 더 유용할 수 있다. 활용 사례에 따라 절충안을 선택하면 된다.


## 7.6 튜플로 열거형 만들기

**문제** 열거형의 문제들을 피하면서 유효한 값을 쉽게 선택하고 싶다.

**해결** 튜플을 열거형으로 만든다.

**논의**
형식 시스템에 가까운 패턴:

```ts
const Direction = {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
} as const;

type Direction = (typeof Direction)[keyof typeof Direction];

function move(direction: Direction) {
  // 구현
}

move(30); // 동작하지 않음!
move(0); // 동작함!
move(Direction.Left); // 이 역시 동작함!
```

하지만 많은 문자열 열거형 항목을 처리하면 중복이 많다. 헬퍼 함수로 해결할 수 있다.

### TupleToUnion 타입

```ts
type TupleToUnion<T extends readonly string[]> = T extends readonly [
  ...infer Rest extends string[],
  infer Key extends string,
]
  ? Key | TupleToUnion<Rest>
  : never;
```

재귀 과정:

```ts
type Direction = ['up', 'down', 'left', 'right'];
type DirectionUnion = TupleToUnion<Direction>;

// 1단계: "right" | TupleToUnion<["up", "down", "left"]>
// 2단계: "right" | "left" | TupleToUnion<["up", "down"]>
// 3단계: "right" | "left" | "down" | TupleToUnion<["up"]>
// 4단계: "right" | "left" | "down" | "up" | TupleToUnion<[]>
// 최종: "right" | "left" | "down" | "up"
```

### 최종 구현

```ts
type Enum<T extends readonly string[], N extends boolean = false> = Readonly<{
  [K in TupleToUnion<T> as Capitalize<K['key']>]: N extends true ? K['val'] : K['key'];
}>;

type Values<T> = T[keyof T];

function createEnum<T extends readonly string[], B extends boolean>(arr: T, numeric?: B) {
  let obj: any = {};
  for (let [i, el] of arr.entries()) {
    obj[capitalize(el)] = numeric ? i : el;
  }
  return obj as Enum<T, B>;
}

const commandItems = ['echo', 'grep', 'sed', 'awk', 'cut', 'uniq', 'head', 'shift'] as const;
const Command = createEnum(commandItems, false);
type Command = Values<typeof Command>;
```

> **팁**: 튜플의 `length` 프로퍼티에 접근할 수 있다. `type DirectionLength = Direction['length']`는 `4`가 된다. 이를 활용해 숫자 열거형도 만들 수 있다.

> **2025 업데이트**: TypeScript 5.0+에서는 `const` 타입 매개변수를 사용하면 `as const` 없이도 리터럴 타입을 유지할 수 있다:
> ```ts
> function createEnum<const T extends readonly string[]>(arr: T) { ... }
> const Command = createEnum(['echo', 'grep', 'sed']); // as const 불필요
> ```


## 7.7 함수 시그니처의 모든 요소 분할하기

**문제** 함수의 인수 형식과 반환 형식을 외부에서도 사용하려 한다.

**해결** 내장 헬퍼 형식 `Parameters<F>`와 `ReturnType<F>`을 사용한다.

**논의**
제네릭 함수 내부에서는 형식 정보를 얻을 수 있다:

```ts
function defer<Par extends unknown[], Ret>(fn: (...par: Par) => Ret, ...args: Par): () => Ret {
  return () => fn(...args);
}

const log = defer(console.log, 'Hello, world!');
log();
```

하지만 함수 밖에서도 같은 정보를 사용하고 싶을 때가 있다:

```ts
type Fn = (...args: any[]) => any;

function defer<F extends Fn>(fn: F, ...args: Parameters<F>): () => ReturnType<F> {
  return () => fn(...args);
}
```

### 내장 헬퍼 타입의 정의

```ts
type Parameters<F extends (...args: any) => any> = F extends (...args: infer P) => any ? P : never;

type ReturnType<F extends (...args: any) => any> = F extends (...args: any) => infer R ? R : any;
```

### 함수 외부에서 인수 준비

```ts
type Result = {
  page: URL;
  title: string;
  description: string;
};

function search(query: string, tags: string[]): Promise<Result[]> {
  throw 'to be done';
}

const searchParams: Parameters<typeof search> = ['Variadic tuple types', ['TypeScript', 'JavaScript']];

search(...searchParams);
const deferredSearch = defer(search, ...searchParams);
```

> **팁**: 이 패턴은 "한 번 정의한 함수 시그니처를 다른 곳에서 다시 적지 않고 재사용"할 수 있게 해준다. 함수형 유틸리티를 조합할 때 매우 유용하다.

---

## 가변 튜플 유틸리티 타입 비교

| 유틸리티 | 기능 | 예시 |
|---------|------|------|
| `Parameters<F>` | 함수 매개변수 튜플 추출 | `Parameters<typeof fn>` |
| `ReturnType<F>` | 함수 반환 타입 추출 | `ReturnType<typeof fn>` |
| `Awaited<T>` | Promise 내부 타입 추출 | `Awaited<Promise<string>>` → `string` |
| `[...T, ...U]` | 튜플 연결 | `[...A, ...B]` |
| `[infer F, ...infer R]` | 튜플 분해 | 첫 요소와 나머지 분리 |

## 튜플 vs 배열 비교

| 특성 | 튜플 | 배열 |
|-----|------|------|
| 길이 | 고정 | 가변 |
| 요소 타입 | 각 위치별로 지정 | 전체 동일 |
| 타입 예시 | `[string, number]` | `string[]` |
| 사용 사례 | 함수 매개변수, 고정 구조 | 동적 컬렉션 |
