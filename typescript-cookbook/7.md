# 7장 가변 튜플 형식

튜플 형식은 각 요소의 형식이 정해지고 길이가 고정된 배열이다. 가변 튜플 형식(variadic tuple type)은 정해진 길이와 각 요소의 형식은 알려졌지만 정확한 모양은 아직 정의되지 않은 형식이다. 이를 함수 시그니처에 사용하면 함수에서 얻는 정보를 극대화할 수 있다.

## 7.1 concat 함수 형식화 하기

**문제** 두 배열을 가져다 연결하는 `concat` 함수를 정확히 형식화하고 싶다.

**해결** 가변 튜플 형식을 이용한다.

**논의** `concat`은 두 배열을 연결하는 헬퍼 함수다.

```ts
function concat(arr1, arr2) {
  return [...arr1, ...arr2];
}
```

이 함수를 형식화하려면 배열에 있는 각 요소의 형식을 알아야 한다. 튜플을 이용하면 각 요소의 형식을 알 수 있지만, 모든 가능한 시나리오를 고려하면 수많은 오버로드가 필요하다:

```ts
// 두 번째 배열이 빈 상황을 고려한 7개의 오버로드
function concat(arr1: [], arr2: []): [];
function concat<A>(arr1: [A], arr2: []): [A];
function concat<A, B>(arr1: [A, B], arr2: []): [A, B];
// ... 계속 늘어남

// 한 개의 요소를 포함하는 두 번째 배열을 고려한 추가 7개의 오버로드
function concat<A2>(arr1: [], arr2: [A2]): [A2];
function concat<A1, A2>(arr1: [A1], arr2: [A2]): [A1, A2];
// ... 기타 등등
```

이렇게 오버로드 조합으로 모든 상황에 대처하기는 쉽지 않다. 가변 튜플 형식을 이용하면 간단하다.

### 튜플 형식의 기본

```ts
type PersonProps = [string, number];
const [name, age]: PersonProps = ['Stefan', 37];
```

### 가변 튜플 형식

```ts
type Foo<T extends unknown[]> = [string, ...T, number];
type T1 = Foo<[boolean]>; // [string, boolean, number]
type T2 = Foo<[number, number]>; // [string, number, number, number]
type T3 = Foo<[]>; // [string, number]
```

가변 튜플 형식은 튜플의 어디에서나 몇 번이고 반복해서 등장할 수 있다:

```ts
type Bar<T extends unknown[], U extends unknown[]> = [...T, string, ...U];
type T4 = Bar<[boolean], [number]>; // [boolean, string, number]
type T5 = Bar<[number, number], [boolean]>; // [number, number, string, boolean]
type T6 = Bar<[], []>; // [string]
```

### concat 형식화

```ts
function concat<T extends unknown[], U extends unknown[]>(arr1: T, arr2: U): [...T, ...U] {
  return [...arr1, ...arr2];
}

// const test: (string | number)[]
const test = concat([1, 2, 3], [6, 7, 'a']);
```

튜플 형식을 정확히 얻으려면 제네릭 배열 형식을 튜플 형식으로 펼쳐야 한다:

```ts
function concat<T extends unknown[], U extends unknown[]>(arr1: [...T], arr2: [...U]): [...T, ...U] {
  return [...arr1, ...arr2];
}

// const test: [number, number, number, number, number, string]
const test = concat([1, 2, 3], [6, 7, 'a']);
```

요소를 미리 알 수 없는 배열을 전달해도 배열 형식을 얻는다:

```ts
declare const a: string[];
declare const b: number[];

// const test: (string | number)[]
const test = concat(a, b);
```

이 동작을 한 형식으로 기술할 수 있으므로 함수 오버로드로 모든 가능성을 정의하는 방법보다 훨씬 유연하며 가독성이 좋다.

## 7.2 promisify 함수 형식화 하기

**문제** 콜백 스타일의 함수를 프로미스로 바꾸고 완벽히 형식화하려 한다.

**해결** 가변 튜플 형식으로 함수 인수를 제네릭으로 만든다.

**논의** 자바스크립트에 프로미스가 존재하기 전에는 콜백을 이용해 비동기 프로그래밍을 구현하는 것이 상식이었다:

```ts
function loadFile(filename: string, encoding: string, callback: (result: File) => void) {
  // 구현 중
}

loadFile('/data.json', 'utf-8', (result) => {
  // 파일을 이용한 작업 수행
});
```

많은 비동기 호출을 처리하면 콜백 지옥이 발생한다:

```ts
loadFile('/data.txt', 'utf-8', (file) => {
  file.readText((url) => {
    request(url, (data) => {
      // 데이터를 이용한 작업 수행
    });
  });
});
```

프로미스를 이용하면 연쇄 호출로 깔끔해진다:

```ts
loadFilePromise('./data.txt', 'utf-8')
  .then((file) => file.text())
  .then((url) => request(url))
  .then((data) => {
    // 데이터를 이용한 작업 수행
  });

// async/await 사용
const file = await loadFilePromise('./data.txt', 'utf-8');
const url = await file.text();
const data = await request(url);
```

콜백 패턴을 자동으로 Promise로 바꾸는 `promisify` 함수를 만들자:

```ts
function promisify(fn: unknown): Promise<unknown> {
  // 구현 중
}

const loadFilePromise = promisify(loadFile);
```

### 함수 헤더를 튜플로 정의

모든 함수 헤더는 튜플 형식으로 정의할 수 있다:

```ts
declare function hello(name: string, msg: string): void;
// 다음과 같음
declare function hello(...args: [string, string]): void;

// 아주 유연하게 정의 가능
declare function h(a: string, b: string, c: string): void;
// 다음과 같음
declare function h(a: string, b: string, ...r: [string]): void;
// 다음과 같음
declare function h(a: string, ...r: [string, string]): void;
// 다음과 같음
declare function h(...r: [string, string, string]): void;
```

나머지 요소를 이용해 개수의 제한이 없는 인수 목록을 정의할 수 있다:

```ts
function tuple<T extends any[]>(...args: T): T {
  return args;
}

const numbers: number[] = getArrayOfNumbers();
const t1 = tuple('foo', 1, true); // [string, number, boolean]
const t2 = tuple('bar', ...numbers); // [string, ...number[]]
```

### 콜백 함수를 튜플로 표현

```ts
function loadFile(...args: [string, string, (result: File) => void]) {
  // 구현 중
}

function request(...args: [URL, (result: JSON) => void]) {
  // 구현 중
}
```

두 함수 모두 결과 형식이 다른 콜백으로 끝난다. 이를 제네릭으로 통일할 수 있다:

```ts
type Fn<Args extends unknown[], Res> = (...args: [...Args, (result: Res) => void]) => void;

type LoadFileFn = Fn<[string, string], File>;
type RequestFn = Fn<[URL], JSON>;
```

### promisify 구현

```ts
function promisify<Args extends unknown[], Res>(
  fn: (...args: [...Args, (result: Res) => void]) => void,
): (...args: Args) => Promise<Res> {
  return function (...args: Args) {
    return new Promise((resolve) => {
      function callback(res: Res) {
        resolve(res);
      }

      fn.call(null, ...[...args, callback]);
    });
  };
}
```

이 함수는 다음 작업을 수행한다:

1. 콜백을 제외한 모든 매개변수를 받는 함수를 반환한다
2. 새로 만든 `Promise`를 반환한다
3. 콜백을 만들어 `Promise`의 `resolve` 함수를 호출한다
4. 원래 함수에 기존 인수와 새 콜백을 붙여 호출한다

## 7.3 curry 함수 형식화 하기

**문제** 커링(currying) 함수를 형식화하려 한다. 커링이란 여러 인수를 받는 함수를 한 개의 인수를 받는 일련의 함수로 변환하는 기법이다.

**해결** 조건부 형식에 가변 튜플 형식을 조합하여 첫 매개변수를 잘라낸다.

**논의** 커링은 함수 인수 중 일부만 '적용'한다는 개념을 활용한다:

```ts
function add(a: number, b: number) {
  return a + b;
}

const curriedAdd = curry(add); // (a: number) => (b: number) => number
const add5 = curriedAdd(5); // (b: number) => number
const result1 = add5(2); // 7
const result2 = add5(3); // 8
```

실용적인 예제:

```ts
function applyClass(this: HTMLElement, method: 'remove' | 'add', className: string, event: Event) {
  if (this === event.target) {
    this.classList[method](className);
  }
}

const applyClassCurried = curry(applyClass);
const removeToggle = applyClassCurried('remove')('hidden');
document.querySelector('.toggle')?.addEventListener('click', removeToggle);
```

### 자바스크립트 구현

```ts
function curry(fn) {
  let curried = (...args) => {
    // 충분히 인수를 모으지 않았다면
    if (fn.length != args.length) {
      // 인수를 부분 적용하고 콜렉터 함수를 반환
      return curried.bind(null, ...args);
    }
    // 그렇지 않으면 모든 함수 호출
    return fn(...args);
  };
  return curried;
}
```

### Curried 타입 정의

```ts
type Curried<F> = F extends (...args: infer A) => infer R
  ? A extends [infer F, ...infer L]
    ? L extends []
      ? (a: F) => R
      : (a: F) => Curried<(...args: L) => R>
    : () => R
  : never;
```

단계별 동작:

1. 형식이 실제 함수인지 검사하고 인수를 `A`, 반환 형식을 `R`로 추론
2. 첫 번째 인수를 `F`로 잘라내고 나머지를 `L`에 저장
3. 남은 인수가 없으면 인수를 받지 않는 함수 반환
4. 인수가 남았으면 남은 매개변수로 `Curried` 형식을 재귀 호출

### 최종 구현

```ts
function curry<F extends Function>(fn: F): Curried<F> {
  let curried: Function = (...args: any) => {
    if (fn.length != args.length) {
      return curried.bind(null, ...args);
    }
    return fn(...args);
  };
  return curried as Curried<F>;
}
```

## 7.4 유연한 curry 함수 형식화 하기

**문제** 7.3절의 `curry` 함수는 임의의 인수를 허용하지만, 형식은 한 번에 한 인수만 허용한다.

**해결** 모든 가능한 튜플 조합을 덮는 함수 오버로드를 만든다.

**논의** `curry` 함수 자체는 정해지지 않은 수의 인수를 받는다:

```ts
function addThree(a: number, b: number, c: number) {
  return a + b + c;
}

const adder = curried(addThree);
const add7 = adder(5, 2); // 여러 인수를 한 번에 적용
const result = add7(2);
```

가능한 모든 형식:

```ts
type Adder = (a: number) => (b: number) => (c: number) => number;
type Adder = (a: number) => (b: number, c: number) => number;
type Adder = (a: number, b: number) => (c: number) => number;
type Adder = (a: number, b: number, c: number) => number;
```

### Overloads 타입

모든 부분 적용을 만드는 `Overloads` 형식:

```ts
type Overloads<A extends any[]> = A extends [infer A, ...infer L] ? [A] | [A, ...Overloads<L>] | [] : [];

// type Overloaded = [] | [string, number, string] | [string] | [string, number]
type Overloaded = Overloads<[string, number, string]>;
```

### Remove 타입

두 튜플을 탐색하면서 요소를 잘라내는 헬퍼:

```ts
type Remove<T extends any[], U extends any[]> = U extends [any, ...infer UL]
  ? T extends [any, ...infer TL]
    ? Remove<TL, UL>
    : never
  : T;
```

### 최종 Curried 타입

```ts
function curry<A extends any[], R extends any>(fn: (...args: A) => R): Curried<A, R> {
  // 이전 코드 참고
}

type Curried<A extends any[], R extends any> = A extends [infer F, ...infer L]
  ? <K extends Overloads<L>>(arg: F, ...args: K) => Curried<Remove<L, K>, R>
  : R;
```

이제 `curry`에 전달할 수 있는 모든 함수에 유연하게 사용할 수 있다.

## 7.5 가장 단순한 curry 함수 형식화 하기

**문제** 복잡한 curry 형식화는 유용하지만 단점도 많다. 더 단순한 해결책은?

**해결** 한 개의 순차적 단계만을 포함하는 `curry` 함수를 만든다.

**논의** 7.3절과 7.4절의 복잡한 형식은 몇 가지 단점이 있다:

- 인수에 `any`를 사용하고 형식 어서션을 사용해 형식 검사를 사실상 비활성화한다
- 인수 이름을 유지할 수 없다
- 자동 완성 기능이 제한된다

커링에는 두 가지 접근이 있다:

1. 고급 커링 기능으로 부분 적용을 적극 재사용
2. 일부 상황에서만 함수형 패턴 사용

두 번째 접근의 이상적인 인터페이스:

```ts
function applyClass(this: HTMLElement, method: 'remove' | 'add', className: string, event: Event) {
  if (this === event.target) {
    this.classList[method](className);
  }
}

const removeToggle = curry(applyClass, 'remove', 'hidden');
document.querySelector('button')?.addEventListener('click', removeToggle);
```

### 간단한 구현

```ts
function curry(f, ...t) {
  return (...u) => f(...t, ...u);
}
```

### 형식 추가

```ts
type Fn<T extends any[], U extends any[]> = (...args: [...T, ...U]) => any;

function curry<T extends any[], U extends any[], R>(f: (...args: [...T, ...U]) => R, ...t: T) {
  return (...u: U) => f(...t, ...u);
}
```

이 접근의 장점:

- **100% 형식 안전성**: 타입스크립트가 제네릭 형식을 정확히 추론한다
- **자동 완성 제공**: 모든 단계에서 적절한 힌트를 제공한다
- **정보 유지**: 원래 형식의 레이블을 유지하며 예상 인수를 안다

현재 `curry`는 원래 버전만큼 유연하지 않지만, 실무에서는 이 버전이 더 유용할 수 있다. 활용 사례에 따라 절충안을 선택하면 된다.

## 7.6 튜플로 열거형 만들기

**문제** 열거형의 문제들을 피하면서 유효한 값을 쉽게 선택하고 싶다.

**해결** 튜플을 열거형으로 만든다.

**논의** 형식 시스템에 가까운 패턴:

```ts
const Direction = {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
} as const;

type Direction = (typeof Direction)[keyof typeof Direction];

function move(direction: Direction) {
  // 구현
}

move(30); // 동작하지 않음!
move(0); // 동작함!
move(Direction.Left); // 이 역시 동작함!
```

하지만 많은 문자열 열거형 항목을 처리하면 중복이 많다:

```ts
const Commands = {
  Shift: 'shift',
  Xargs: 'xargs',
  Tail: 'tail',
  // ... 중복 많음
} as const;
```

### 헬퍼 함수로 해결

```ts
const commandItems = ['echo', 'grep', 'sed', 'awk', 'cut', 'uniq', 'head', 'shift'] as const;

function capitalize(x: string): string {
  return x.charAt(0).toUpperCase() + x.slice(1);
}

function createEnum(arr, numeric) {
  let obj = {};
  for (let [i, el] of arr.entries()) {
    obj[capitalize(el)] = numeric ? i : el;
  }
  return obj;
}
```

### TupleToUnion 타입

```ts
type TupleToUnion<T extends readonly string[]> = T extends readonly [
  ...infer Rest extends string[],
  infer Key extends string,
]
  ? Key | TupleToUnion<Rest>
  : never;
```

재귀 과정을 자세히 보면:

```ts
type Direction = ['up', 'down', 'left', 'right'];
type DirectionUnion = TupleToUnion<Direction>;

// 1단계: "right" | TupleToUnion<["up", "down", "left"]>
// 2단계: "right" | "left" | TupleToUnion<["up", "down"]>
// 3단계: "right" | "left" | "down" | TupleToUnion<["up"]>
// 4단계: "right" | "left" | "down" | "up" | TupleToUnion<[]>
// 5단계: "right" | "left" | "down" | "up" | never
// 최종: "right" | "left" | "down" | "up"
```

### Enum 타입 (문자열 버전)

```ts
type Enum<T extends readonly string[], N extends boolean = false> = Readonly<{
  [K in TupleToUnion<T> as Capitalize<K>]: K;
}>;
```

### length 프로퍼티 활용

튜플의 길이에 접근할 수 있다:

```ts
type DirectionLength = Direction['length']; // 4
```

각 재귀 호출에서 길이 정보를 활용:

```ts
type TupleToUnion<T extends readonly string[]> = T extends readonly [
  ...infer Rest extends string[],
  infer Key extends string,
]
  ? { key: Key; val: Rest['length'] } | TupleToUnion<Rest>
  : never;
```

### Enum 타입 (숫자 지원)

```ts
type Enum<T extends readonly string[], N extends boolean = false> = Readonly<{
  [K in TupleToUnion<T> as Capitalize<K['key']>]: N extends true ? K['val'] : K['key'];
}>;
```

### 최종 구현

```ts
type Values<T> = T[keyof T];

function createEnum<T extends readonly string[], B extends boolean>(arr: T, numeric?: B) {
  let obj: any = {};
  for (let [i, el] of arr.entries()) {
    obj[capitalize(el)] = numeric ? i : el;
  }
  return obj as Enum<T, B>;
}

const Command = createEnum(commandItems, false);
type Command = Values<typeof Command>;
```

## 7.7 함수 시그니처의 모든 요소 분할하기

**문제** 함수의 인수 형식과 반환 형식을 외부에서도 사용하려 한다.

**해결** 내장 헬퍼 형식 `Parameters<F>`와 `ReturnType<F>`을 사용한다.

**논의** 제네릭 함수 내부에서는 형식 정보를 얻을 수 있다:

```ts
function defer<Par extends unknown[], Ret>(fn: (...par: Par) => Ret, ...args: Par): () => Ret {
  return () => fn(...args);
}

const log = defer(console.log, 'Hello, world!');
log();
```

하지만 함수 밖에서도 같은 정보를 사용하고 싶을 때가 있다:

```ts
type Fn = (...args: any[]) => any;

function defer<F extends Fn>(fn: F, ...args: Parameters<F>): () => ReturnType<F> {
  return () => fn(...args);
}
```

### 내장 헬퍼 타입의 정의

```ts
type Parameters<F extends (...args: any) => any> = F extends (...args: infer P) => any ? P : never;

type ReturnType<F extends (...args: any) => any> = F extends (...args: any) => infer R ? R : any;
```

### 함수 외부에서 인수 준비

```ts
type Result = {
  page: URL;
  title: string;
  description: string;
};

function search(query: string, tags: string[]): Promise<Result[]> {
  throw 'to be done';
}

const searchParams: Parameters<typeof search> = ['Variadic tuple types', ['TypeScript', 'JavaScript']];

search(...searchParams);
const deferredSearch = defer(search, ...searchParams);
```

이 패턴은 "한 번 정의한 함수 시그니처를 다른 곳에서 다시 적지 않고 재사용"할 수 있게 해준다. 함수형 유틸리티를 조합할 때 매우 유용하다.
