# 7장 가변 튜플 형식

## 7.1 concat 함수 형식화 하기

**문제** 두 배열을 이어 붙이는 `concat` 헬퍼를 제공하려는데, 배열 요소 하나하나의 타입까지 정확히 추적할 수 있는 선언을 만들고 싶다. 단순 오버로드를 쌓아 올리는 접근은 유지보수가 너무 어렵다.

**해결** 가변 튜플 형식을 이용해 “길이는 정해졌지만 구체적인 모양은 나중에 채워지는” 형식을 만들어 두 배열을 병합한다.

**논의** 자바스크립트 구현 자체는 간단하다.

```ts
function concat(arr1: unknown[], arr2: unknown[]) {
  return [...arr1, ...arr2];
}
```

문제는 타입 정의가 폭발한다는 점이다. 예를 들어 두 번째 배열이 비어 있을 때만 따져도 오버로드가 이렇게 늘어난다.

```ts
function concat(arr1: [], arr2: []): [];
function concat<A>(arr1: [A], arr2: []): [A];
function concat<A, B>(arr1: [A, B], arr2: []): [A, B];
function concat<A, B, C>(arr1: [A, B, C], arr2: []): [A, B, C];
// ...
```

두 번째 배열이 요소 하나를 가질 때, 둘, 셋… 같은 경우까지 고려하면 조합 수는 기하급수적으로 늘어난다. 이 지점에서 튜플 타입의 장점이 드러난다. 튜플은 길이가 고정되고 각 요소의 타입을 모두 알고 있다는 사실을 타입 시스템에 알려 줄 수 있다.

```ts
type PersonProps = [string, number];
const [name, age]: PersonProps = ["Stefan", 37];
```

가변 튜플 타입을 쓰면 “앞에는 문자열, 끝에는 숫자, 사이는 아직 모름” 같은 식의 묘사가 가능하다.

```ts
type Foo<T extends unknown[]> = [string, ...T, number];
type Bar<T extends unknown[], U extends unknown[]> = [...T, string, ...U];
```

이 두 가지 기능을 합쳐 `concat` 시그니처를 일반화하면 된다. 먼저 각 배열을 제네릭 튜플로 선언하고, 반환형을 `[...T, ...U]`로 잡는다.

```ts
function concat<T extends unknown[], U extends unknown[]>(
  arr1: T,
  arr2: U
): [...T, ...U] {
  return [...arr1, ...arr2];
}
```

튜플 그대로 넘겨줄 땐 타입 정보가 그대로 유지된다.

```ts
const tupleConcat = concat([1, 2, 3], [6, 7, "a"] as const);
// tupleConcat: [1, 2, 3, 6, 7, "a"]
```

반면 단순 배열(`string[]`, `number[]`)을 전달하면 타입스크립트는 가능한 모든 조합을 포괄하는 `(string | number)[]`을 반환형으로 추론한다. 즉, 오버로드 한 무더기 대신 한 줄짜리 선언으로 정확한 행동을 설명할 수 있다.

## 7.2 promisify 함수 형식화 하기

**문제** 콜백 기반 API(예: `fs.readFile`, `request`)를 `Promise` 기반으로 바꾸고, 동시에 콜백의 인수·반환 타입을 완벽히 보존하고 싶다.

**해결** 함수 인수 목록을 튜플로 간주해, 콜백 전에 등장하는 모든 매개변수를 제네릭 가변 튜플로 추상화한다.

**논의** 콜백 패턴의 단점은 깊은 중첩과 “콜백 지옥”이다.

```ts
function loadFile(
  filename: string,
  encoding: string,
  callback: (result: File) => void
) {
  // 구현
}

loadFile("/data.json", "utf-8", (result) => {
  // 파일로 작업
});
```

프로미스로 바꾸면 체인이 깔끔해진다.

```ts
loadFilePromise("./data.txt", "utf-8")
  .then((file) => file.text())
  .then((url) => request(url))
  .then((data) => {
    // 데이터로 작업
  });
```

이제 `promisify` 함수가 필요하다. 콜백 함수의 매개변수는 튜플로 표기할 수 있다. `loadFile(...args: [string, string, (result: File) => void])`처럼 말이다. 이를 일반화하면 다음과 같은 함수 타입을 얻는다.

```ts
type Fn<Args extends unknown[], Res> = (
  ...args: [...Args, (result: Res) => void]
) => void;

type LoadFileFn = Fn<[string, string], File>;
type RequestFn = Fn<[URL], JSON>;
```

`Args`는 콜백 앞의 모든 매개변수, `Res`는 콜백이 받는 결과 타입을 나타낸다. 이를 토대로 `promisify` 시그니처와 구현을 작성한다.

```ts
function promisify<Args extends unknown[], Res>(
  fn: (...args: [...Args, (result: Res) => void]) => void
): (...args: Args) => Promise<Res> {
  return (...args: Args) =>
    new Promise<Res>((resolve) => {
      function callback(res: Res) {
        resolve(res);
      }

      fn(...[...args, callback]);
    });
}
```

작동 순서는 다음과 같다.

1. 콜백을 제외한 모든 매개변수(`Args`)를 받는 함수를 반환한다.
2. 새 `Promise`를 만들고 내부에서 `resolve`를 잡아 둔다.
3. 기존 콜백을 대체할 함수를 만들어 `resolve`를 호출하도록 연결한다.
4. 원본 함수에 기존 인수와 새 콜백을 붙여 호출한다.

이제 `const loadFilePromise = promisify(loadFile);`처럼 쓰면 타입스크립트는 “파일 경로, 인코딩 → `Promise<File>`” 흐름을 자동으로 추론한다. 콜백 기반 API라면 무엇이든 동일한 제네릭으로 포장할 수 있다.

## 7.3 curry 함수 형식화 하기

**문제** 커링은 여러 개의 인수를 받는 함수를 인수 하나만 받는 함수들의 연쇄로 바꾸는 기법이다. 이를 타입 친화적으로 구현해 커링된 각 단계도 완전한 타입 추론을 제공하도록 만들고 싶다.

**해결** 조건부 타입과 가변 튜플을 조합해 “첫 번째 인수를 잘라 내고 나머지를 재귀적으로 처리”하는 `Curried<F>` 타입을 정의한다.

**논의** 자바스크립트 커링 헬퍼 `curry`는 다음과 같이 생겼다.

```ts
function curry(fn: Function) {
  const curried = (...args: unknown[]) => {
    if (fn.length !== args.length) {
      return curried.bind(null, ...args);
    }
    return fn(...args);
  };
  return curried;
}
```

이를 타입스크립트로 옮기려면 전달된 함수의 매개변수 목록을 튜플로 추출하고, 한 번에 하나씩 잘라 내면서 재귀적으로 시그니처를 만들어야 한다. 다음 제네릭 타입이 핵심이다.

```ts
type Curried<F> = F extends (...args: infer A) => infer R
  ? A extends [infer First, ...infer Rest]
    ? Rest extends []
      ? (a: First) => R
      : (a: First) => Curried<(...args: Rest) => R>
    : () => R
  : never;
```

`infer`로 추출한 첫 번째 인수 `First`를 인수로 받는 함수를 만들고, 아직 남은 타입 `Rest`를 다시 `Curried`에 넣어 동일한 과정을 반복한다. 이 타입을 실제 구현에 붙이면 된다.

```ts
function curry<F extends Function>(fn: F): Curried<F> {
  const curried: Function = (...args: unknown[]) => {
    if (fn.length !== args.length) {
      return curried.bind(null, ...args);
    }
    return fn(...args);
  };
  return curried as Curried<F>;
}
```

이제 `const curriedAdd = curry((a: number, b: number) => a + b);`라고 쓰면 타입스크립트가 `(a: number) => (b: number) => number`를 정확히 추론한다. 각 단계에서 어떤 인수가 이미 적용됐는지도 IDE가 알려 준다.

## 7.4 유연한 curry 함수 형식화 하기

**문제** 7.3절의 커리는 “항상 인수 하나씩만 받는” 버전이었다. 하지만 실제로는 `(a)(b, c)`나 `(a, b)(c)`처럼 한 번에 여러 인수를 적용할 수 있는 커링 헬퍼를 쓰는 경우도 많다.

**해결** 함수 오버로드 후보를 “가능한 모든 인수 튜플의 부분집합”으로 확장하고, 이미 소비한 인수를 제거해 남은 시그니처를 재귀적으로 연결한다.

**논의** `addThree` 함수의 가능한 호출 분기(그림 7-1)는 `[number, number, number]` 전체를 한꺼번에 넘기는 경우부터 하나씩 끊어 넘기는 경우까지 다양하다. 이를 타입으로 표현하려면 인수 튜플에서 “앞부분을 포함한 모든 부분 배열”을 생성해야 한다.

```ts
type Overloads<A extends any[]> = A extends [infer First, ...infer Rest]
  ? [First] | [First, ...Overloads<Rest>]
  : [];
```

`Overloads<[string, number, string]>`은 `[] | [string] | [string, number] | [string, number, string]`처럼 계산된다. 이 타입을 이용해 커링 단계별로 허용되는 인수 조합을 표현할 수 있다.

또한 이미 소비한 인수를 제외한 “남은” 인수를 얻어야 한다. 아래 `Remove` 타입은 두 튜플을 동시에 순회하면서 첫 번째 튜플에서 두 번째 튜플의 길이만큼 잘라낸 나머지를 돌려준다.

```ts
type Remove<T extends any[], U extends any[]> = U extends [any, ...infer UL]
  ? T extends [any, ...infer TL]
    ? Remove<TL, UL>
    : never
  : T;
```

이제 `Curried` 정의를 다음과 같이 고도화할 수 있다.

```ts
type Curried<A extends any[], R extends any> = A extends [infer F, ...infer L]
  ? <K extends Overloads<L>>(
      arg: F,
      ...args: K
    ) => Curried<Remove<L, K>, R>
  : R;
```

`Curried<[number, number, number], number>`를 펼치면 첫 번째 호출에서 `number`를 받고, 이어서 `[]`, `[number]`, `[number, number]` 중 하나를 추가 인수로 요구하며, 남은 인수를 재귀적으로 계산한다. 이렇게 하면 `(a)(b)(c)`, `(a, b)(c)`, `(a)(b, c)`, `(a, b, c)`가 모두 타입 안전하게 지원된다.

## 7.5 가장 단순한 curry 함수 형식화 하기

**문제** 고급형 커링은 멋지지만, `as` 단언과 `any`가 많아지고 자동 완성도 제한된다. “한 단계만 부분 적용”할 수 있는 단순한 인터페이스가 필요하다.

**해결** 커링 함수를 “선행 인수 묶음 `T`와 나중 인수 `U`를 한 번씩만 붙이는” 구조로 제한하고, 가변 튜플 두 개를 이어 붙이는 타입 정의만으로 끝낸다.

**논의** 7.4절 버전은 모든 경우의 수를 덮는 대신 구현과 타입이 매우 복잡했다. 반대로 다음과 같은 간단한 시그니처는 대부분의 실무 시나리오를 충족하며 인수 이름과 레이블을 잃지 않는다.

```ts
function curry<T extends any[], U extends any[], R>(
  f: (...args: [...T, ...U]) => R,
  ...t: T
) {
  return (...u: U) => f(...t, ...u);
}
```

여기서 `T`는 이미 부분 적용한 매개변수 모음, `U`는 나중에 전달될 매개변수 모음이다. 반환 함수 역시 튜플 `U` 그대로를 인수로 받아 `R`을 돌려준다. 이 접근은 다음과 같은 장점을 가진다.

- 타입스크립트가 사용 시점에서 `T`와 `U`를 정확히 추론하므로 100% 타입 안정성이 보장된다.
- 추가적인 조건부 타입이나 재귀 없이, 구현과 시그니처가 거의 동일한 모양이다.
- 원본 함수의 인수 레이블이 그대로 유지되어 IDE 힌트가 풍부하다.

```ts
function applyClass(
  this: HTMLElement,
  method: "remove" | "add",
  className: string,
  event: Event
) {
  if (this === event.target) {
    this.classList[method](className);
  }
}

const removeToggle = curry(applyClass, "remove", "hidden");
document
  .querySelector("button")
  ?.addEventListener("click", removeToggle);
```

커링을 꼭 “한 인수씩”으로 제한할 필요는 없다. 팀의 합의와 요구 사항에 맞춰 적당한 타입 수준을 선택하면 된다.

## 7.6 튜플로 열거형 만들기

**문제** 열거형은 허용 가능한 값을 강제하는 데 유용하지만, 숫자/문자열 enum이 가진 런타임 비용과 실수 가능성을 피하고 싶다. 입력 튜플만 주면 일관된 열거형 객체와 타입을 동시에 얻고 싶다.

**해결** 문자열 튜플을 받아 키를 `Capitalize`로 재지은 뒤, 값은 문자열 그대로 혹은 0부터 시작하는 숫자 인덱스로 채우는 헬퍼를 정의한다. 튜플을 유니온으로 바꾸는 재귀 타입을 활용한다.

**논의** 우선 문자열 배열을 기반으로 하는 전통적인 열거형 패턴을 살펴보자.

```ts
const Direction = {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
} as const;

type Direction = (typeof Direction)[keyof typeof Direction];
```

키와 값을 늘 손으로 맞춰줘야 하기 때문에 긴 목록을 다루기 어렵다. 대신 “원본 문자열 목록” 하나만 유지하도록 만들자.

```ts
const commandItems = [
  "echo",
  "grep",
  "sed",
  "awk",
  "cut",
  "uniq",
  "head",
  "shift",
] as const;
```

먼저 튜플을 유니온으로 펼치는 헬퍼 `TupleToUnion`을 정의한다.

```ts
type TupleToUnion<T extends readonly string[]> = T extends readonly [
  ...infer Rest extends string[],
  infer Key extends string
]
  ? Key | TupleToUnion<Rest>
  : never;
```

문자열 키를 대문자로 바뀐 버전으로 매핑하고, 값은 문자열 그대로 둘 수도 있고 숫자로 바꿀 수도 있게 `Enum` 타입을 만든다.

```ts
type Enum<T extends readonly string[], N extends boolean = false> = Readonly<{
  [K in TupleToUnion<T> as Capitalize<K>]: N extends true ? number : K;
}>;
```

숫자 값을 위해서는 튜플의 길이 정보가 필요하다. `TupleToUnion`을 변형해 `{ key: string; val: number }` 객체들의 유니온을 만든 뒤 `N` 플래그에 따라 값을 선택하면 된다. 마지막으로 런타임 구현을 타입과 맞춘다.

```ts
type Values<T> = T[keyof T];

function capitalize(x: string) {
  return x.charAt(0).toUpperCase() + x.slice(1);
}

function createEnum<T extends readonly string[], B extends boolean>(
  arr: T,
  numeric?: B
) {
  const obj: any = {};
  for (const [i, el] of arr.entries()) {
    obj[capitalize(el)] = numeric ? i : el;
  }
  return obj as Enum<T, B>;
}

const Command = createEnum(commandItems, false);
type Command = Values<typeof Command>;
```

생성된 키는 `Echo`, `Grep`, `Sed`처럼 일정한 규칙을 따르고, 원본 튜플만 수정하면 타입도 자동으로 갱신된다. 덕분에 반복 작업과 오타 위험을 크게 줄일 수 있다.

## 7.7 함수 시그니처의 모든 요소 분할하기

**문제** 제네릭 함수 내부에서는 `infer`로 인수와 반환형을 뽑아 쓸 수 있지만, 함수 밖에서도 같은 정보를 재사용하고 싶다.

**해결** 내장 헬퍼 `Parameters<F>`와 `ReturnType<F>`를 활용하면 된다. 두 헬퍼 모두 함수 시그니처를 튜플 형태로 취급해 각각 인수 배열과 반환 타입을 돌려준다.

**논의** 예를 들어 `defer`는 함수를 나중으로 미루되, 미리 인수까지 저장해 두는 헬퍼다. 직접 제네릭을 쓰면 다음처럼 작성할 수 있다.

```ts
function defer<Par extends unknown[], Ret>(
  fn: (...par: Par) => Ret,
  ...args: Par
) {
  return () => fn(...args);
}
```

하지만 함수 외부에서도 동일한 타입 정보를 알고 싶다면 내장 헬퍼를 쓰자.

```ts
type Fn = (...args: any[]) => any;

function defer<F extends Fn>(fn: F, ...args: Parameters<F>) {
  return () => fn(...args);
}
```

`Parameters<F>`와 `ReturnType<F>`는 각각 다음과 같은 조건부 타입으로 정의되어 있다.

```ts
type Parameters<F extends (...args: any) => any> = F extends (
  ...args: infer P
) => any
  ? P
  : never;

type ReturnType<F extends (...args: any) => any> = F extends (
  ...args: any
) => infer R
  ? R
  : any;
```

덕분에 아래처럼 함수 외부에서 인수 튜플을 따로 선언해 둘 수 있다.

```ts
type Result = {
  page: URL;
  title: string;
  description: string;
};

function search(query: string, tags: string[]): Promise<Result[]> {
  throw new Error("TODO");
}

const searchParams: Parameters<typeof search> = [
  "Variadic tuple types",
  ["TypeScript", "JavaScript"],
];

search(...searchParams);
const deferredSearch = defer(search, ...searchParams);
```

이 패턴은 “한 번 정의한 함수 시그니처를 다른 곳에서 다시 적지 않고 재사용”할 수 있게 해 준다. 특히 함수형 유틸리티를 조합할 때 매우 유용하다.
