자 열 템 플 릿 리 터 럴 형 식
타 입 스 크 립 트 의 형 식 시 스 템 에 서 모 든 값 은 값 이 면 서 동 시 에 형 식 이 다 . 이 를 리 터 럴 형 식 이 라
부 르 며 다 른 리 터 럴 형 식 과 유 니 온 을 만 들 어 서 허 용 하 는 값 의 집 합 을 명 확 하 게 형 식 으 로 정 의
할 수 있 다 . s t r i n g 의 하 위 집 합 을 예 로 살 펴 보 자 . 집 합 의 일 부 가 되 어 야 하 는 문 자 열 을 정 확
히 정 의 하 고 수 많 은 오 류 를 배 제 할 수 있 다 . 반 대 편 끝 은 다 시 전 체 문 자 열 집 합 이 된 다 .
하 지 만 중 간 에 무 엇 인 가 존 재 한 다 면 어 떻 게 될 까 ? 특 정 문 자 열 패 턴 이 존 재 하 는 지 확 인 하 고
나 머 지 는 더 유 연 하 게 동 작 하 도 록 형 식 을 정 의 할 수 있 다 면 어 떨 까 ? 문 자 열 템 플 릿 리 터 럴 형 식
s i n g t e m p l a t e h t e r a l t r e 은 정 확 히 이 런 기 능 을 제 공 한 다 . 이 를 이 용 해 문 자 열 의 특 정 부 분 은 미 리 정
의 하 고 나 머 지 부 분 은 다 양 하 게 활 용 할 수 있 도 록 유 용 하 게 열 린 형 식 으 로 정 의 할 수 있 다 .
심 지 어 조 건 부 형 식 과 함 께 하 면 문 자 열 을 아 주 작 은 조 각 으 로 나 누 고 같 은 조 각 을 새 형 식 에
재 활 용 할 수 있 다 . 이 는 정 말 강 력 한 도 구 다 . 특 히 많 은 자 바 스 크 립 트 코 드 가 문 자 열 의 패 턴 에
의 존 하 는 상 황 이 라 면 더 욱 그 렇 다
이 장 에 서 는 문 자 열 템 플 릿 리 터 럴 형 식 을 더 다 양 하 게 활 용 하 는 방 법 을 살 펴 본 다 . 단 순 한 문
자 열 패 턴 을 준 수 하 는 것 부 터 시 작 해 문 자 열 형 태 에 따 라 매 개 변 수 와 형 식 을 추 출 하 는 기 능 까
지 문 자 열 을 형 식 으 로 파 싱 하 는 힘 을 확 인 할 수 있 다 .
이 책 에 서 소 개 하 는 시 나 리 오 는 실 생 활 에 서 가 져 온 예 제 다 . 문 자 열 템 플 릿 리 터 럴 형 식 으 로
할 수 있 는 일 은 무 궁 무 진 하 다 . 사 람 들 은 문 자 열 템 플 릿 리 터 럴 형 식 을 활 용 해 철 자 검 사 기
( h t t p s : / / o r e i l . l y / 6 3 z 2 r ) 나 S O L 파 서 ( h t t p s : / / o r e i l . y / f a s v x ) 등 을 구 현 했 다 . 이 멋 진 기
능 으 로 불 가 능 한 것 은 아 무 것 도 없 어 보 일 정 도 다 .
6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 2 5
6 . 1 사 용 자 정 의 이 벤 트 시 스 템 정 의 하 기
문 제 사 용 자 정 의 이 벤 트 시 스 템 을 만 들 때 모 든 이 벤 트 명 은 " o n 으 로 시 작 하 도 록 이 름 규 칙 을 정 하 려 한 다 .
해 결 문 자 열 템 플 릿 리 터 럴 형 식 을 이 용 해 문 자 열 패 턴 을 기 술 한 다 .
논 의 자 바 스 크 립 트 이 벤 트 시 스 템 에 서 는 흔 히 이 벤 트 앞 에 특 정 문 자 열 을 붙 인 다 . 보 통 이 벤
트 와 이 벤 트 핸 들 러 는 o n 으 로 시 작 한 다 ( 물 론 구 현 마 다 다 르 다 ) .
이 런 규 칙 을 준 수 하 는 이 벤 트 시 스 템 을 만 들 려 한 다 . 타 입 스 크 립 트 의 문 자 열 형 식 에 서 는 모 든 가
능 한 문 자 열 이 나 문 자 열 리 터 럴 형 식 으 로 구 성 된 유 니 온 형 식 의 하 위 집 합 을 받 아 들 일 수 있 다 .
모 든 문 자 열 은 너 무 넓 지 만 유 니 온 형 식 은 유 연 성 이 떨 어 져 우 리 의 필 요 를 충 족 하 지 못 한 다 . 이
름 규 칙 이 존 재 하 더 라 도 실 생 활 에 서 는 가 능 한 모 든 이 벤 트 명 을 미 리 정 의 할 수 없 기 때 문 이 다 .
다 행 히 문 자 열 템 플 릿 리 터 럴 형 식 ( 줄 여 서 플 릿 리 터 럴 형 식 ) 은 우 리 가 원 하 는 기 능 을 제 공 한
다 . 템 플 릿 리 터 럴 형 식 을 이 용 하 면 유 연 성 을 유 지 하 면 서 도 문 자 열 리 터 럴 을 정 의 할 수 있 다 .
예 를 들 어 다 음 은 o n 으 로 시 작 하 는 모 든 문 자 열 을 허 용 하 는 형 식 이 다 .
type EventName = 'on${string}';
템 플 릿 리 터 럴 형 식 은 자 바 스 크 립 트 의 템 플 릿 문 자 열 의 문 법 을 빌 렸 다 . 자 바 스 크 립 트 에 서 는 백
틱 ( ' ) 으 로 템 플 릿 문 자 열 을 표 현 한 다 .
$ t } 문 법 을 이 용 해 변 수 , 함 수 호 출 등 자 바 스 크 립 트 표 현 식 을 문 자 열 에 추 가 할 수 있 다 .
function greet(name: string) {
return 'Hi, ${name}!*;
}
greet("Stefan"); // "Hi, Stefan!"
타 입 스 크 립 트 의 템 플 릿 리 터 럴 형 식 도 비 슷 하 다 . 타 입 스 크 립 트 에 서 는 자 바 스 크 립 트 표 현 식 대
신 형 식 을 값 의 집 합 으 로 추 가 할 수 있 다 . H T M L 의 헤 딩 요 소 를 표 현 하 는 문 자 열 형 식 을 다 음
처 럼 정 의 할 수 있 다 .
2 2 6 실 무 로 통 하 는 타 입 스 크 립 트
type Levels = 1 / 2 1 3 1 4 1 5 | 6;
1 / " H 1 " i " H 2 " : " H 3 " : " H 4 " : " H S " { " H 6 " 으 로 해 석 됨
type Headings = 'H${Levels}';
L e v e L s 는 n u m b e r 의 하 위 집 합 이 고 , H e a d i n g s 는 H 로 시 작 해 야 하 고 뒤 로 는 L e v e l s 와 호 환
되 는 값 이 와 야 함 이 라 는 의 미 다 .
E v e n t N a m e 으 로 돌 아 가 보 자 .
type EventName = 'on${string}*;
E v e n t N a m e 은 o n " 으 로 시 작 하 는 문 자 열 ( 빈 문 자 열 포 함 ) ' 을 의 미 한 다 . E v e n t N a m e 을 이 용 해
간 단 한 이 벤 트 시 스 템 을 만 들 어 보 자 . 첫 번 째 단 계 로 콜 백 함 수 를 수 집 한 다 .
한 개 의 매 개 변 수 E v e n t o b j e c t 를 갖 는 C a l L b a c k 이 라 는 함 수 형 식 을 정 의 한 다 . E v e n t o b j e c t
는 이 벤 트 정 보 의 값 을 포 함 하 는 제 네 릭 형 식 이 다 .
type EventObject<T> = {
val: T;
type Callback<T = any> = (ev: EventObject<T>) => void;
또 한 모 든 등 록 된 이 벤 트 콜 백 을 저 장 할 E v e n t s 형 식 도 필 요 하 다 .
type Events = {
[x: EventName]: Callback[] | undefined;
E v e n t N a m e 은 s t r i n g 의 유 효 한 하 위 집 합 이 므 로 이 를 인 덱 스 접 근 자 로 사 용 한 다 . 지 금 까 지 정
의 한 형 식 을 활 용 해 E v e n t S y s t e m 클 래 스 를 만 든 다 .
class EventSystem {
events: Events;
c o n s t r u c t o r {
6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 2 7
this.events = {};
}
defineEventHandlerev: EventName, cb: Callback): void {
t h i s . e v e n t s [ e v ] = t h i s . e v e n t s [ e v ] ? ? [ ] ;
this.events[ev]?.push(cb);
}
trigger(ev: EventName, value: any) {
let callbacks = this.events[ev];
if (callbacks) {
callbacks. forEach((cb) → {
생 성 자 는 새 이 벤 트 저 장 소 를 만 들 고 d e f i n e E v e n t H a n d l e r 는 E v e n t N a m e 과 C a l l b a c k 을 인
수 로 받 아 이 벤 트 저 장 소 에 저 장 한 다 . T r i g g e r 는 E v e n t N a m e 을 인 수 로 받 아 콜 백 이 등 록 되 었
다 면 E v e n t o b j e c t 로 모 든 등 록 된 콜 백 을 실 행 한 다 .
첫 번 째 단 계 를 완 료 했 다 . 이 벤 트 를 정 의 할 때 형 식 안 전 성 을 갖 췄 다 .
const system = new EventSystem;
system.defineEventHandler ("click", () → > (});
1 / ^ ' " C l i c k " ' 형 식 의 인 수 는 ' o n s { s t r i n g } ' 형 식 의
/ / 매 개 변 수 에 할 당 될 수 없 습 니 다 . t s ( 2 3 4 5 )
system.defineEventHandler ("onClick", () => (});
system.defineEventHandler ("onchange", () → > (});
6 . 2 절 에 서 는 문 자 열 조 작 형 식 과 키 매 핑 으 로 이 시 스 템 을 개 선 하 는 방 법 을 설 명 한 다 .
2 2 8 실 무 로 통 하 는 타 입 스 크 립 트
6 . 2 문 자 열 조 작 형 식 과 키 매 핑 으 로 이 벤 트 콜 백 만 들 기
문 제 아 무 객 체 를 받 아 각 프 로 퍼 티 에 와 쳐 함 수 를 추 가 하 는 w a t c h 함 수 를 제 공 해 서 이 벤 트 콜 백 을 정 의
하 도 록 허 용 하 려 한 다 .
해 결 키 매 핑 을 이 용 해 새 문 자 열 프 로 퍼 티 키 를 만 든 다 . 와 쳐 함 수 가 적 절 한 낙 타 표 기 법 m e d
c a s i n g 을 사 용 하 도 록 문 자 열 조 작 형 식 을 이 용 한 다 .
논 의 6 . 1 절 의 이 벤 트 형 식 시 스 템 은 어 느 정 도 완 성 된 상 태 다 . 이 벤 트 핸 들 러 를 등 록 하 고 이
벤 트 를 발 생 시 킬 수 있 다 . 이 제 감 시 w a c h 기 능 을 추 가 해 보 자 . 콜 백 을 등 록 할 수 있 도 록 유 효 한
객 체 를 확 장 하 고 , 프 로 퍼 티 가 바 뀌 면 등 록 된 콜 백 을 실 행 한 다 . p e r s o n 객 체 를 정 의 한 다 고 가
정 하 면 o n A g e C h a n g e d 와 o n N a m e C h a n g e d 이 벤 트 를 리 스 닝 할 수 있 다 .
let person = {
name: "Stefan",
age: 40,
};
const watchedPerson = system.watch(person);
watchedPerson.onAgeChanged ((ev) => {
console. log(ev.val, "changed!!");
} ) ;
w a t c h e d P e r s o n . a g e = 4 1 ; 1 / 콜 백 호 출
각 프 로 퍼 티 는 o n 으 로 시 작 해 C h a n g e d 로 끝 나 며 이 벤 트 객 체 매 개 변 수 를 포 함 하 는 콜 백 을 수
락 하 는 메 서 드 가 있 다 .
w a t c h e d o b j e c t < T > 라 는 헬 퍼 형 식 ( 이 를 이 용 해 이 전 에 설 명 한 메 서 드 를 추 가 할 수 있 음 ) 으 로
새 이 벤 트 핸 들 러 메 서 드 를 정 의 한 다 .
type WatchedObject<T> = {
[K in string & keyof T as 'on${K}Changed* ]: (
ev: Callback<T[K]>
) => void;
! !
6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 2 9
많 은 내 용 이 담 겨 있 으 므 로 한 가 지 씩 살 펴 보 자 .
1 T 의 모 든 키 를 반 복 하 므 로 매 핑 된 형 식 을 정 의 한 다 . s t r i n g 문 자 열 키 에 만 관 심 이 있 으 므 로 s t r i n g &
k e y o f T 인 터 섹 션 을 이 용 해 심 볼 이 나 숫 자 를 제 거 한 다 .
2 다 음 으 로 이 키 를 새 문 자 열 로 재 매 핑 r e m a p 하 므 로 문 자 열 템 플 릿 리 터 럴 형 식 을 정 의 한 다 . 이 형 식 은 o n 으
로 시 작 하 며 매 핑 과 정 에 서 K 키 를 취 한 다 음 C h a n g e d 를 붙 인 다 .
3 프 로 퍼 티 키 는 콜 백 을 수 락 하 는 함 수 를 가 리 킨 다 . 콜 백 자 체 는 이 벤 트 객 체 를 인 수 로 받 으 며 이 객 체 의 제
네 릭 을 올 바 로 치 환 해 서 이 이 벤 트 객 체 가 감 시 중 인 객 체 의 원 래 형 식 을 포 함 함 을 확 신 할 수 있 다 .
현 재 기 능 은 멋 지 지 만 중 요 한 세 부 사 항 이 빠 졌 다 . W a t c h o b j e c t 를 p e r s o n 에 사 용 할 때 모 든
생 성 된 이 벤 트 메 서 드 에 는 o n 뒤 에 대 문 자 가 오 지 않 는 다 . 내 장 문 자 열 조 작 형 식 을 이 용 해 문 자
열 형 식 을 대 문 자 로 바 꿀 수 있 다 .
type WatchedObject<T> = 1
[K in string & keyof T as 'on${Capitalize<K>}Changed*]: (
ev: Callback<T[K]>
) → > void;
} ;
C a p i t a l i z e 외 에 L o n e r c a s e , U p p e r c a s e , U n c a p i t a l i z e 등 도 있 다 . 편 집 기 로 M a t c h e d o b j e c t 〈 t y p e o f
p e r s o n > 의 형 식 을 확 인 해 보 면 다 음 처 럼 생 성 된 형 식 을 확 인 할 수 있 다 .
type WatchedPerson = {
onNameChanged: (ev: Callback<string>) => void;
onAgeChanged: (ev: Callback<number>) => void;
} ;
이 제 형 식 설 정 을 마 쳤 으 므 로 구 현 을 시 작 한 다 . 먼 저 두 헬 퍼 함 수 를 만 든 다 .
function capitalize(inp: string) {
return inp.charAt(0). topperCase() + inp.slice(1);
function handlerName(name: string): EventName {
return 'on${capitalize(name)}Changed as EventName;
}
}
2 3 0 실 무 로 통 하 는 타 입 스 크 립 트
두 헬 퍼 함 수 가 재 매 핑 , 문 자 열 조 작 두 가 지 타 입 스 크 립 트 동 작 을 흉 내 내 도 록 한 다 .
c a p i t a l i z e 는 문 자 열 의 첫 번 째 글 자 를 대 문 자 로 바 꾸 고 , h a n d l e N a m e 은 접 두 어 나 접 미 어 를
추 가 한 다 . h a n d L e r N a m e 에 서 는 타 입 스 크 립 트 에 형 식 이 바 뀌 었 음 을 알 려 줄 약 간 의 형 식 어 서
션 이 필 요 하 다 . 자 바 스 크 립 트 에 서 는 다 양 한 방 법 으 로 문 자 열 을 변 형 할 수 있 는 데 , 타 입 스 크 립
트 에 서 는 그 결 과 가 대 문 자 버 전 이 될 것 인 지 를 알 수 없 다 .
다 음 으 로 이 벤 트 시 스 템 에 w a t c h 기 능 을 구 현 한 다 . 임 의 의 객 체 를 받 아 기 존 프 로 퍼 티 와 와 쳐
프 로 퍼 티 를 모 두 포 함 하 는 객 체 를 반 환 하 는 제 네 릭 함 수 를 만 든 다 .
P r o x y 객 체 를 이 용 해 g e t 과 s e t 호 출 을 가 로 채 면 , 프 로 퍼 티 가 바 뀌 었 을 때 이 벤 트 핸 들 러 를
실 행 하 도 록 할 수 있 다 .
class EventSystem {
1 / 지 면 상 생 략
watch<T extends object>(obj: T): T & WatchedObject<T> {
const self = this;
return new ProxyCobj, {
get(target, property) {
/ / ( 1 )
i f (
typeof property === "string" &i&
property.startsWith("on") &
property.endsWith("Changed")
) {
/ / ( 2 )
return (cb: Callback) => {
self.defineEventHandler(property as EventName, cb);
}
1 (3)
return target[property as keyof T];
/ / 완 료 로 설 정 . . .
}) as T & WatchedObject<T>;
W a t c h e d o b j e c t < T > 의 프 로 퍼 티 에 접 근 하 면 g e t 이 호 출 된 다 .
6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 3 1
• 프 로 퍼 티 명 이 o n 으 로 시 작 해 C h a n g e d 로 끝 난 다 .
• 이 런 상 황 이 라 면 콜 백 을 허 용 하 는 함 수 를 반 환 한 다 . 함 수 자 체 는 d e f i n e E v e n t H a n d l e r 를 통 해 콜 백 을
이 벤 트 저 장 소 로 추 가 한 다 .
• 이 외 의 모 든 상 황 에 서 는 일 반 프 로 퍼 티 접 근 으 로 처 리 한 다 .
이 제 원 래 객 체 의 값 을 설 정 할 때 마 다 저 장 된 이 벤 트 가 발 생 한 다 . 따 라 서 모 든 s e t 호 출 을 바
꿔 야 한 다 .
class EventSystem {
/ / . . . 지 면 상 생 략
watch<T extends object›(obj: T): T & WatchedObject<T> {
const self = this;
return new Proxy (obj, &
1 / 위 에 서 가 져 옴 . . .
set(target, property, value) {
i f (property in target & typeof property === "string") {
/ / ( 1 )
target[property as keyof T] = value;
1 / ( 2 )
self. trigger(handlerName(property), value);
return true;
}
return false;
} ,
}) as T & WatchedObject<T>;
}
}
다 음 과 같 은 과 정 이 실 행 된 다 .
1 값 을 설 정 한 다 . 어 쨌 든 객 체 를 갱 신 해 야 한 다 .
2 t r i g g e r 함 수 를 호 출 해 모 든 등 록 된 콜 백 을 실 행 한 다 .
타 입 스 크 립 트 가 올 바 른 방 향 으 로 나 아 가 도 록 몇 가 지 형 식 어 서 션 을 사 용 해 야 한 다 . 결 과 적 으
로 새 객 체 를 만 든 다 .
작 업 을 완 료 했 다 ! 예 제 코 드 를 처 음 부 터 실 행 하 면 서 이 벤 트 시 스 템 이 어 떻 게 동 작 하 는 지 확 인
해 보 자 .
2 3 2 실 무 로 통 하 는 타 입 스 크 립 트
l e t person = {
name: "Stefan",
age: 40,
const watchedPerson = system.watch(person);
watchedPerson.onAgeChanged ((ev) = {
console. log(ev.val, "changed!!");
} ) ;
w a t c h e d P e r s o n . a g e = 4 1 ; 1 / " 4 1 c h a n g e d ! ! " 기 록
문 자 열 템 플 릿 리 터 럴 형 식 은 문 자 열 조 작 형 식 , 키 재 매 핑 과 함 께 새 객 체 를 즉 석 에 서 만 들 수 있
도 록 돕 는 다 . 이 런 강 력 한 도 구 를 이 용 하 면 고 급 자 바 스 크 립 트 객 체 를 더 튼 튼 하 게 만 들 수 있 다 .
6 . 3 포 맷 함 수 구 현 하 기
문 제 포 맷 문 자 열 을 받 아 실 젯 값 으 로 플 레 이 스 홀 더 를 치 환 하 는 함 수 의 형 식 을 만 들 어 야 한 다 .
해 결 문 자 열 템 플 릿 리 터 럴 형 식 에 서 플 레 이 스 홀 더 명 을 추 론 하 는 조 건 부 형 식 을 만 든 다 .
논 의 응 용 프 로 그 램 은 중 괄 호 로 플 레 이 스 홀 더 를 정 의 하 는 포 맷 문 자 열 을 만 들 수 있 다 . 두 번
째 매 개 변 수 는 포 맷 문 자 열 에 정 의 된 플 레 이 스 홀 더 치 환 에 사 용 할 객 체 를 받 는 다 . 따 라 서 각
플 레 이 스 홀 더 는 포 맷 문 자 열 로 정 의 되 며 프 로 퍼 티 키 마 다 연 관 된 값 이 따 라 온 다 .
format ("Hello {world}. My name is {you}.", {
world: "World",
you: "Stefan"
});
이 함 수 는 사 용 자 가 필 요 한 프 로 퍼 티 를 빠 뜨 리 지 않 고 모 두 추 가 하 도 록 상 기 시 킨 다 . 우 선 아 주
넓 은 형 식 으 로 함 수 인 터 페 이 스 를 정 의 한 다 . 포 맷 문 자 열 의 형 식 은 S t r i n g 이 며 포 매 팅 매 개 변
수 는 s t r i n g 키 와 임 의 의 값 을 갖 는 R e c o r d 형 식 이 다 .
6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 3 3
function format(fmtString: string, params: Record<string, any›): string {
throw "unimplemented";
}
다 음 으 로 제 네 릭 을 추 가 해 인 수 를 구 체 적 인 값 이 나 리 터 럴 형 식 으 로 고 정 하 려 한 다 .
f m t s t r i n g 을 제 네 릭 형 식 T ( s t r i n g 의 하 위 집 합 ) 로 바 꾸 었 다 . 여 전 히 문 자 열 을 함 수 로 전 달
할 수 있 는 상 황 인 데 , 실 제 로 리 터 럴 문 자 열 을 전 달 하 면 해 당 리 터 럴 형 식 을 분 석 해 패 턴 을 확
인 한 다 ( 더 자 세 한 내 용 은 4 . 3 절 참 고 ) .
function format<T extends string>(
fmtString: T,
params: Record<string, any>
) : s t r i n g {
throw "unimplemented";
}
T 로 형 식 을 고 정 했 으 므 로 f m t S t r i n g 을 F o r m a t K e y s 제 네 릭 형 식 의 형 식 매 개 변 수 로 전 달 할
수 있 다 . 이 조 건 부 형 식 은 포 맷 문 자 열 이 중 괄 호 와 호 환 되 는 지 검 사 한 다 .
type FormatKeys<
T extends s t r i n g

> = T extends ^${string}{${string}}${string}*
? T
: never;
포 맷 문 자 열 을 다 음 처 럼 확 인 한 다 .
• 문 자 열 로 시 작 한 다 . 이 문 자 열 은 빈 문 자 열 일 수 있 다 .
• 그 뒤 로 { , 문 자 열 , } 이 차 례 로 등 장 한 다 .
• 그 뒤 에 는 다 시 문 자 열 이 등 장 한 다 .
포 맷 문 자 열 에 딱 한 개 의 플 레 이 스 홀 더 가 존 재 하 는 지 확 인 하 는 것 이 다 . 그 렇 다 면 전 체 포 맷
문 자 열 을 반 환 하 고 그 렇 지 않 으 면 n e v e r 를 반 환 한 다 .
type A = FormatKeys<"Hello {world}">; / / "Hello {world}"
type B = FormatKeys<"Hello">; / / never
2 3 4 실 무 로 통 하 는 타 입 스 크 립 트
F o r m a t K e y s 는 전 달 한 문 자 열 이 포 맷 문 자 열 인 지 아 닌 지 알 려 준 다 . 하 지 만 우 리 는 포 맷 문 자
열 의 특 정 부 분 ( 중 괄 호 를 감 싼 부 분 ) 에 더 관 심 이 있 다 . 타 입 스 크 립 트 의 i n f e r 키 워 드 를 이 용
해 타 입 스 크 립 트 에 포 맷 문 자 열 이 이 패 턴 과 일 치 하 면 중 괄 호 사 이 에 등 장 하 는 리 터 럴 형 식 을
붙 잡 아 형 식 변 수 로 추 가 하 도 록 지 시 한 다 .
type FormatKeys‹
T extends s t r i n g
> = T extends '${string}{${infer Key}}${string}_
> ? Key
> : never;
> 이 런 식 으 로 하 위 문 자 열 을 추 출 하 고 필 요 한 때 재 활 용 할 수 있 다 .
> type A = Formatkeys<"Hello {world}">; // "world"
> type B = FormatKeys<"Hello">; / / never
> 멋 지 다 ! 첫 번 째 플 레 이 스 홀 더 명 을 추 출 했 다 . 이 제 나 머 지 를 확 인 해 보 자 . 여 러 플 레 이 스 홀 더 가
> 존 재 할 수 있 으 므 로 첫 번 째 플 레 이 스 홀 더 이 후 의 모 든 내 용 을 가 져 다 R e s t 라 는 형 식 변 수 로
> 저 장 한 다 . R e s t 는 빈 문 자 열 이 거 나 다 시 분 석 해 야 할 문 자 열 을 포 함 할 수 있 으 므 로 이 조 건 은
> 항 상 참 이 다 .
> R e s t 를 가 져 다 가 t r u e 분 기 에 서 K e y 와 유 니 온 형 식 을 취 하 면 서 F o r m a t K e y s < R e s t > 를 호 출 한 다 .
> type FormatKeys<
> T extends string
> = T extends '${string}{${infer Key}}${infer Rest}'
> ? Key | FormatKeys<Rest>
> : never;
> 이 는 재 귀 조 건 부 형 식 이 다 . 유 니 온 ) 이 결 과 다 .
> 플 레 이 스 홀 더 들 의 유 니 온 ( 즉 , 포 매 팅 객 체 의 키 로 사 용 할 수 있 는
> type A = FormatKeys<"Hello {world}">; // "world"
> type B = Formatkeys‹ "Hello {world}. I'm {you}.">; // "world" I "you"
> type C = FormatKeys<"Hello">; / / never
> 6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 3 5
> 이 제 F o r m a t K e y s 를 완 성 해 보 자 . T 를 고 정 했 으 므 로 이 를 F o r m a t K e y s 의 인 수 로 전 달 할 수 있
> 으 며 이 결 과 를 다 시 R e c o r d 의 인 수 로 사 용 한 다 .
> function format<T extends string>(
> fmtString: I,
> params: Record<FormatKeys<T>, any>
> ): string {
> throw "unimplemented";
> }
> 이 제 모 든 형 식 을 준 비 했 으 니 구 현 을 살 펴 보 자 ! 지 금 까 지 정 의 한 형 식 을 아 름 답 게 뒤 집 으 면 구
> 현 이 된 다 . p a r a m s 의 모 든 키 를 반 복 하 면 서 중 괄 호 의 모 든 내 용 물 을 관 련 값 으 로 치 환 한 다 .
> function format<T extends string>(
> fmtString: T,
> params: Record<FormatKeys<T>, any>
> ) : string {
> let r e t : string = fmtString;
> for ( l e t k in params) {
> ret = ret.replaceAll(_{${k}}*, params[k as keyof typeof params]);
}
return ret;
}
두 가 지 형 식 에 특 히 주 목 하 자 .
• r e t 의 형 식 을 s t r i n g 으 로 설 정 했 고 , f m t S t r i n g 은 T ( s t r i n g 의 하 위 형 식 ) 로 설 정 했 다 . 따 라 서 r e t 도 T
다 . 값 을 바 꾸 면 T 의 형 식 이 바 뀌 므 로 값 을 바 꿀 수 없 음 을 의 미 한 다 . s t r i n g 이 라 는 넓 은 형 식 으 로 바 꾸
면 r e t 을 쉽 게 바 꿀 수 있 다 .
• 객 체 키 k 가 p a r a m s 의 실 제 키 인 지 확 인 해 야 한 다 . 이 는 타 입 스 크 립 트 의 실 패 안 전 장 치 때 문 에 필 요 한 해
결 책 이 다 . 더 자 세 한 내 용 은 9 . 1 절 에 서 확 인 할 수 있 다 .
9 . 1 절 의 정 보 를 이 용 해 일 부 형 식 어 서 션 을 제 거 하 고 최 종 버 전 의 f o r m a t 함 수 를 만 든 다 .
function format<T extends string, K extends Record<FormatKeys<T>, any>>(
fmtString: T,
params: K
): string {
2 3 6 실 무 로 통 하 는 타 입 스 크 립 트
let ret: string = fmtString;
for ( l e t k i n params) ‹
ret = ret.replaceAll({${k}}_, params[k]);
> }
> return ret;
> }
> 문 자 열 을 분 리 하 고 프 로 퍼 티 키 를 추 출 하 는 기 능 은 정 말 강 력 하 다 . 전 세 계 의 타 입 스 크 립 트 개
> 발 자 들 은 이 패 턴 을 이 용 해 형 식 을 강 화 한 다 . 예 를 들 어 익 스 프 레 스 ( h t t p s : / / e x p r e s s j s . c o m )
> 웹 서 버 개 발 자 들 이 그 러 하 다 . 앞 으 로 이 도 구 를 이 용 해 더 좋 은 형 식 을 얻 는 다 양 한 예 제 를 살
> 펴 본 다 .
> 6 . 4 포 맷 매 개 변 수 형 식 추 출 하 기
> 문 제 플 레 이 스 홀 더 의 형 식 을 정 의 할 수 있 도 록 6 . 3 절 의 포 맷 함 수 를 확 장 하 려 한 다 .
> 해 결 중 첩 된 조 건 부 형 식 을 만 들 고 형 식 맵 으 로 형 식 을 찾 는 다 .
> 논 의 이 전 에 살 펴 본 예 제 를 확 장 해 보 자 . 이 번 에 는 모 든 플 레 이 스 홀 더 정 보 뿐 아 니 라 플 레 이
> 스 홀 더 에 특 정 형 식 집 합 을 정 의 하 는 기 능 을 추 가 하 려 한 다 . 형 식 은 선 택 형 이 어 야 하 며 플 레 이
> 스 홀 더 명 뒤 에 는 콜 론 을 붙 여 야 하 고 자 바 스 크 립 트 의 기 본 형 식 중 하 나 여 야 한 다 . 잘 못 된 형
> 식 의 값 을 전 달 하 면 형 식 오 류 가 발 생 하 길 기 대 한 다 .
> format ("Hello {world:string}. I'm {you}, {age:number} years old.", {
> world: "World",
> age: 40,
> you: "Stefan",
> 3);
> 참 고 로 6 . 3 절 의 원 래 구 현 을 살 펴 보 자 .
> type FormatKeys<
> T extends string
> 6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 3 7
> = T extends "${string}{${infer Key}}${infer Rest}'
> ? Key | FormatKeys<Rest>
> : n e v e r ;
> function format<T extends string>(
> fmtString: T,
> params: Record<FormatKeys<T>, any>
> ): s t r i n g {
> l e t r e t : s t r i n g = fmtString;
> for ( l e t k in params) {
> ret = ret.replace(_{${k}}', params[k as keyof typeof params]);
}
return r e t ;
}
이 를 달 성 하 려 면 두 가 지 작 업 을 해 야 한 다 .
1 p a r a m s 형 식 을 R e c o r d F o r m a t K e y s < T 〉 , a n y > 에 서 각 프 로 퍼 티 와 관 련 된 적 절 한 형 식 을 포 함 하 는 실
제 객 체 형 식 으 로 바 꾼 다
2 자 바 스 크 립 트 기 본 형 을 추 출 할 수 있 도 록 F o r m a t K e y s 내 에 서 문 자 열 템 플 릿 리 터 럴 형 식 을 적 용 한 다 .
우 선 F o r m a t o b j < T > 라 는 새 형 식 을 소 개 한 다 . 이 형 식 은 F o r m a t K e y s 처 럼 동 작 하 지 만 , 단 순 히
문 자 열 키 를 반 환 하 는 대 신 같 은 키 를 새 객 체 형 식 으 로 매 핑 한 다 . 따 라 서 유 니 온 형 식 대 신 인
터 섹 션 형 식 을 이 용 해 재 귀 ( 각 재 귀 에 서 프 로 퍼 티 를 더 추 가 함 ) 를 연 결 해 야 하 고 종 료 조 건 을
n e v e r 에 서 { } 로 바 꿔 야 한 다 . n e v e r 와 인 터 섹 션 을 수 행 하 면 전 체 결 과 형 식 은 n e v e r 가 된 다 .
이 런 방 식 으 로 새 프 로 퍼 티 를 결 과 형 식 에 포 함 하 지 않 는 다 .
type FormatObj<
T extends string
>= T extends '${string}${infer Key}}${infer Rest}'
> ? { [K in Key]: any } & FormatObj<Rest>
> : t ;
> F o r m a t o b j c T > 는 R e c o r d c F o r m a t K e y s < T > , a n y > 와 같 은 방 식 으 로 동 작 한 다 . 아 직 어 떤 플 레
> 이 스 홀 더 형 식 도 추 출 하 지 않 았 지 만 , 전 체 객 체 형 식 을 제 어 할 수 있 으 므 로 각 객 체 형 식 을 쉽
> 게 설 정 할 수 있 다 .
> 2 3 8 실 무 로 통 하 는 타 입 스 크 립 트
> 다 음 으 로 콜 론 분 리 자 를 찾 도 록 F o r m a t o b j < T > 의 파 싱 조 건 을 바 꾼 다 . : 문 자 를 찾 았 으 면
> T y p e 에 서 이 후 문 자 열 리 터 럴 형 식 을 추 론 하 고 이 를 매 핑 된 키 의 형 식 으 로 사 용 한 다 .
> type FormatObj<
> T extends string
> = T extends '${string}${infer Key}:${infer Type}}${infer Rest}'
> ? { [K in Key]: Type } & FormatObj ‹Rest>
> : t ;
> 이 제 원 하 는 기 능 을 거 의 완 성 했 지 만 한 가 지 문 제 가 남 았 다 . 우 리 는 문 자 열 리 터 럴 형 식 을 추
> 론 한 다 . 예 를 들 어 { a g e : n u m b e r } 를 파 싱 할 때 a g e 의 형 식 은 리 터 럴 문 자 열 " n u m b e r " 다 . 이
> 문 자 열 을 실 제 형 식 으 로 변 환 해 야 한 다 . 다 른 조 건 부 형 식 을 수 행 하 거 나 맵 형 식 을 검 색 할 수
> 있 다 .
> type MapFormat Type = {
> string: string;
> number: number;
> boolean: boolean;
> [x: string]: any;
> 3
> 그 렇 게 하 면 어 떤 형 식 이 어 떤 키 와 연 관 되 는 지 간 단 히 확 인 할 수 있 고 다 른 모 든 문 자 열 과 관
> 련 해 서 는 멋 진 폴 백 ( a l b a c k 을 가 질 수 있 다 .
> type A = MapFormat Type["string"]; / / string
> type B = MapFormatType["number"]; // number
> type C = MapFormatType["notavailable"]; // any
> M a p F o r m a t T y p e 을 F o r m a t o b j < T > 에 적 용 해 보 자 .
> type FormatObj<
> T extends s t r i n g
> = T extends '${string}{${infer Key}:${infer Type}}${infer Rest}'
> ? { [K in Key]: MapFormatType[Type] } & FormatObj<Rest>
> ： ｛ ；
> 6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 3 9
> 거 의 완 성 했 다 ! 하 지 만 모 든 플 레 이 스 홀 더 는 형 식 ( 선 택 형 ) 을 정 의 할 수 있 어 야 한 다 . 하 지 만
> 현 재 파 싱 조 건 에 서 는 : 분 리 자 를 명 시 적 으 로 요 구 하 므 로 형 식 을 정 의 하 지 않 는 모 든 플 레 이
> 스 홀 더 는 프 로 퍼 티 를 만 들 어 내 지 않 는 다 .
> 플 레 이 스 홀 더 를 검 사 한 이 후 에 형 식 을 검 사 하 면 이 문 제 를 해 결 할 수 있 다 .
> type FormatObj<
> T extends string
> = T extends '${string}{${infer Key}}${infer Rest}'
? Key extends '${infer KeyPart}:${infer TypePart}'
? { [K in KeyPart]: MapFormatType[TypePart] } & FormatObj<Rest>
: { [K in Key]: any } & FormatObj<Rest>
: 0 ;
다 음 처 럼 형 식 을 이 해 할 수 있 다 .
1 플 레 이 스 홀 더 가 있 는 지 검 사 한 다 .
2 플 레 이 스 홀 더 가 있 으 면 형 식 애 너 테 이 션 이 있 는 지 검 사 한 다 . 있 으 면 키 를 포 맷 형 식 으 로 매 핑 하 고 없 으 면
원 래 키 를 a n y 로 매 핑 한 다 .
3 이 외 의 상 황 에 는 빈 객 체 를 반 환 한 다 .
이 렇 게 기 능 을 완 성 했 다 . 한 가 지 실 패 안 전 장 치 를 추 가 할 수 있 다 . 형 식 정 의 를 포 함 하 지 않 는
플 레 이 스 홀 더 를 a n y 형 식 으 로 설 정 하 는 대 신 해 당 형 식 이 적 어 도 t o s t r i n g ( ) 을 구 현 하 도 록
기 대 할 수 있 다 . 이 를 이 용 해 문 자 열 을 얻 을 수 있 기 때 문 이 다 .
type FormatObj<
T extends string
> = T extends '${string}${infer Key}}${infer Rest}'
> ? Key extends '${infer KeyPart}:${infer TypePart}'
> ? { [K in KeyPart]: MapFormatType[TypePart] } & FormatObj<Rest>
> : { [K in Key]: { toString(): string } } & FormatObj<Rest>
> : { } ;
> 이 를 새 형 식 f o r m a t 에 적 용 하 고 구 현 을 갱 신 한 다 .
> function format<T extends string, K extends FormatObj<T>>(
> fmtString: T,
> 2 4 0 실 무 로 통 하 는 타 입 스 크 립 트
> params: K
> ) : string 1
> let ret: string = fmtString;
> for ( l e t k in params) {
> let val = _${params[k]}_;
> let searchPattern = new RegExp({${k}:?.*?}', "g");
r e t = ret.replaceAll(searchPattern, val);
}
return ret;
}
정 규 표 현 식 을 이 용 해 이 름 을 가 능 한 형 식 애 너 테 이 션 으 로 치 환 한 다 . 타 입 스 크 립 트 가 알 아 서
모 든 것 을 처 리 할 수 있 으 므 로 함 수 내 에 서 는 형 식 을 검 사 할 필 요 가 없 다 .
문 자 열 템 플 릿 리 터 럴 형 식 을 재 귀 , 형 식 검 색 등 다 른 도 구 와 결 합 한 조 건 부 형 식 을 이 용 하 면
몇 줄 의 코 드 로 도 복 잡 한 관 계 를 지 정 할 수 있 음 을 알 았 다 . 형 식 은 더 좋 아 졌 고 , 코 드 는 튼 튼 해
졌 다 . 개 발 자 라 면 누 구 나 이 런 A P I 를 사 용 하 고 싶 을 것 이 다 .
6 . 5 재 귀 한 계 처 리 하 기
문 제 문 자 열 을 유 효 한 프 로 퍼 티 키 로 변 환 하 는 문 자 열 템 플 릿 리 터 럴 형 식 을 만 들 었 다 . 헬 퍼 형 식 을 설 정
하 다 보 니 재 귀 한 계 에 다 다 랐 다 .
해 결 누 적 기 법 을 이 용 해 꼬 리 호 출 최 적 화 ( a i l - c a l l o p i n i z a t i o n 를 진 행 한 다 .
논 의 타 입 스 크 립 트 의 문 자 열 템 플 릿 리 터 럴 형 식 과 조 건 부 형 식 을 합 치 면 즉 석 에 서 새 문 자
열 형 식 을 만 들 수 있 다 . 이 를 프 로 퍼 티 키 로 사 용 하 거 나 유 효 문 자 열 을 검 사 하 는 데 사 용 할 수
있 다 .
이 때 재 귀 가 일 어 난 다 . 즉 , 함 수 의 재 귀 호 출 처 럼 같 은 형 식 을 반 복 호 출 할 수 있 는 데 , 반 복 호
출 할 수 있 는 깊 이 에 한 계 가 있 다 .
예 를 들 어 T r i m T > 는 문 자 열 의 처 음 과 끝 에 존 재 하 는 공 백 을 제 거 하 는 형 식 이 다 .
type Trim<T extends string> =
6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 4 1
T extends ' ${infer X } ' ? Trim<X> :
T extends '${infer X } ' ? Trim<X> :
> T;
> 이 형 식 은 먼 저 시 작 부 분 에 공 백 이 있 는 지 검 사 하 고 , 나 머 지 를 추 론 하 면 서 같 은 작 업 을 반 복
> 한 다 . 앞 쪽 의 공 백 을 모 두 제 거 했 다 면 문 자 열 뒤 쪽 으 로 같 은 검 사 를 반 복 한 다 . 앞 , 뒤 의 모 든
> 공 백 을 제 거 하 면 작 업 이 끝 나 면 서 마 지 막 분 기 로 이 동 해 남 은 문 자 열 을 반 환 한 다 .
> type Trimmed = Trim<" key ">; // "key"
> 형 식 을 반 복 호 출 하 는 재 귀 가 일 어 났 다 . 타 입 스 크 립 트 는 재 귀 호 출 이 형 식 내 에 서 자 체 적 으 로
> 일 어 남 을 알 수 있 으 며 이 를 꼬 리 호 출 최 적 화 로 평 가 할 수 있 다 . 즉 , 다 음 재 귀 과 정 을 같 은 호
> 출 스 택 프 레 임 에 서 처 리 할 수 있 다 .
> 노 트 자 바 스 크 립 트 의 호 출 스 택 을 더 자 세 히 알 고 싶 다 면 토 머 스 헌 터 T h o m a s H u n t e r 의 책 「 D i s t r i b u t e d
> Systems with Node.js(https://learning.oreilly.com/Library/view/distributed-systens-with/9781492077282),
> 를 참 고 하 자 .
> 조 건 부 형 식 을 재 귀 호 출 하 는 타 입 스 크 립 트 의 기 능 을 이 용 해 임 의 의 문 자 열 에 서 공 백 이 나 유
> 효 하 지 않 은 문 자 를 제 거 하 고 유 효 한 문 자 열 을 만 들 려 한 다 .
> 우 선 공 백 을 제 거 하 는 T r i m < T > 과 비 슷 한 헬 퍼 형 식 을 만 든 다 .
> type RemoveWhiteSpace<T extends string> = T extends '${infer A} ${infer B}'
? RemoveWhiteSpace<^${Uncapitalize<A>}${Capitalize<B>}>
: T;
공 백 이 있 는 지 검 사 하 고 , 공 백 앞 이 나 뒤 의 문 자 열 ( 빈 문 자 열 일 수 있 음 ) 을 추 론 한 다 음 , 새 로
만 든 문 자 열 형 식 으 로 같 은 형 식 을 다 시 호 출 한 다 . 첫 번 째 추 론 결 과 의 첫 문 자 를 소 문 자 로 만
들 고 두 번 째 추 론 결 과 의 첫 문 자 를 대 문 자 로 만 든 다 . 따 라 서 낙 타 표 기 법 을 따 르 는 문 자 열 식
별 자 가 완 성 된 다 .
모 든 공 백 을 제 거 할 때 까 지 이 를 반 복 한 다 .
2 4 2 실 무 로 통 하 는 타 입 스 크 립 트
type Identifier = RemoveWhiteSpace<"Hello World!">; / / "helloWorld!"
다 음 으 로 남 은 문 자 열 이 유 효 한 지 검 사 한 다 . 이 번 에 도 재 귀 를 이 용 한 다 . 포 함 하 는 문 자 열 로 쪼 개 어 대 문 자 와 소 문 자 버 전 을 각 각 만 든 다 .
문 자 열 을 한 문 자 를
type StringSplit<T extends string> = T extends '${infer Char}${infer Rest}'
? Capitalize<Char> | Uncapitalize<Char> | StringSplit<Rest>
: n e v e r ;
type Chars = StringSplit<"abcdefghijklmnopqrstuvwxyz">;
/ "a"| "A" | "b"| "B"| "c" | "C"|"d" | "D" | "e" | "E"|
/ "f"| " F | "g" | "G" | "h" | "H" | i " I "I" | "j" | "J" !
1 "k" | "K" | "T"| "L" "m" | "M" | "n" | "N" | "O"| O" I
/ " p " | " p " | " q " | "Q"| " r " | "R" | " s " / "s" | "t" | "T" |
1 " U " | " U " | " " | " " | " w " | " W " | " x " | " Х " | " y " | " Y " !
/ "z" | "Z"
첫 번 째 글 자 를 가 져 와 대 문 자 , 소 문 자 를 만 들 고 더 이 상 문 자 열 에 문 자 가 없 을 때 까 지 이 를 반
복 한 다 . 이 재 귀 에 서 는 각 단 계 의 결 과 를 유 니 온 형 식 과 함 께 호 출 하 므 로 꼬 리 호 출 최 적 화 를
할 수 없 다 . 여 기 서 5 0 개 의 문 자 를 처 리 할 때 재 귀 한 계 에 다 다 른 다 ( 타 입 스 크 립 트 컴 파 일 러 의
상 한 h a r d m i t ) . 따 라 서 기 본 알 파 벳 만 사 용 하 면 문 제 가 없 다 !
하 지 만 다 음 단 계 에 서 I d e n t i f i e r 를 만 들 려 할 때 첫 번 째 한 계 에 부 딪 힌 다 . 여 기 서 는 문 자
유 효 성 을 검 사 한 다 . 우 선 R e m o v e N h i t e S p a c e < T > 형 식 을 호 출 해 공 백 을 제 거 하 고 낙 타 표 기 법
으 로 문 자 열 을 변 환 한 다 . 그 리 고 이 결 과 문 자 열 이 유 효 한 지 검 사 한 다 .
s t r i n g S p l i t c T > 처 럼 첫 번 째 문 자 를 가 져 와 서 추 가 로 추 론 결 과 내 에 서 형 식 검 사 를 수 행
한 다 . 가 져 온 문 자 가 유 효 한 지 확 인 하 고 나 머 지 를 가 져 온 다 . 그 리 고 유 효 한 문 자 열 을 다 시 붙
이 고 남 은 문 자 열 을 재 귀 적 으 로 검 사 한 다 . 첫 번 째 문 자 가 유 효 하 지 않 으 면 나 머 지 문 자 열 로
C r e a t e I d e n t i f i e r c T 〉 를 호 출 한 다 .
type CreateIdentifier<T extends string> =
RemoveWhiteSpace<T> extends '${infer A extends Chars}${infer Rest}'
? '${A}${CreateIdentifier<Rest>}
1 / ^ 형 식 인 스 턴 스 화 는 깊 이 가 매 우 깊 으 며 무 한 할 수 도 있 습 니 다 . t s ( 2 5 8 9 )
: RemoveWhiteSpace<T> extends '${infer A}${infer Rest}'
6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 4 3
? CreateIdentifier<Rest>
: T;
이 때 첫 번 째 재 귀 한 계 가 등 장 한 다 . 타 입 스 크 립 트 는 이 형 식 을 인 스 턴 스 화 할 때 무 한 하 고 너
무 깊 은 반 복 이 일 어 날 수 있 다 는 경 고 를 한 다 . 문 자 열 템 플 릿 리 터 럴 형 식 에 서 재 귀 호 출 을 사
용 하 면 호 출 스 택 오 류 가 일 어 날 수 있 음 을 의 미 한 다 . 게 다 가 여 기 서 는 꼬 리 호 출 최 적 화 도 할
수 없 다 .
이 를 해 결 할 방 법 이 있 다 . 꼬 리 호 출 최 적 화 를 활 성 화 하 려 면 재 귀 호 출 이 독 립 적 으 로 일 어 나 야
한 다 . 누 적 자 기 법 l c u l a t o r l e c h i q u e 을 이 용 해 이 를 달 성 할 수 있 다 . A c C 라 부 르 는 두 번 째 문 자 열
형 식 매 개 변 수 를 전 달 하 고 빈 문 자 열 로 인 스 턴 스 화 한 다 . 이 를 누 적 자 로 사 용 한 다 . 즉 , 중 간 결
과 를 누 적 자 로 저 장 하 고 다 음 호 출 시 이 를 전 달 하 는 방 식 이 다 .
type CreateIdentifier<T extends string, Acc extends string = ""› =
RemoveWhiteSpace<T> extends '${infer A extends Chars}${infer Rest}*
? CreateIdentifier<Rest, "${Acc}${A}>
: RemoveWhiteSpace<T> extends '${infer A}${infer Rest}*
? CreateIdentifier<Rest, Acc>
: Acc;
이 제 결 과 는 두 번 째 매 개 변 수 로 저 장 되 며 , 재 귀 호 출 은 독 립 적 으 로 일 어 난 다 . 출 을 모 두 마 치 면 ( 재 귀 종 료 분 기 를 통 해 ) , 최 종 결 과 를 저 장 한 누 적 자 를 반 환 한 다 .
필 요 한 재 귀 호
type Identifier = CreateIdentifier‹"Hello Wor!ld!">; / / "helloWorld"
물 론 문 자 열 을 식 별 자 로 만 드 는 더 좋 은 방 법 도 많 다 . 하 지 만 조 건 부 형 식 을 재 귀 와 활 용 하 는
상 황 에 서 는 언 제 든 이 러 한 문 제 를 겪 을 수 있 다 . 이 런 상 황 에 서 는 누 적 자 기 법 을 이 용 해 문 제
를 해 결 한 다 .
2 4 4 실 무 로 통 하 는 타 입 스 크 립 트
6 . 6 템 플 릿 리 터 럴 을 구 별 자 로 사 용 하 기
문 제 백 엔 드 요 청 상 태 를 p e n d i n g 에 서 e r r o r 나 s u c c e s s 로 변 경 하 는 상 태 머 신 을 모 델 링 하 려 한 다 .
다 양 한 백 엔 드 요 청 에 이 들 상 태 를 적 용 하 면 서 내 부 형 식 은 하 나 로 유 지 해 야 한 다 .
해 결 문 자 열 템 플 릿 리 터 럴 을 구 별 된 유 니 온 의 구 별 자 로 사 용 한 다 .
논 의 백 엔 드 에 서 데 이 터 를 가 져 올 때 항 상 같 은 작 업 이 일 어 난 다 . 요 청 을 보 내 고 나 면 응 답
을 기 다 리 거 나 ( p e n d i n g ) , 결 과 데 이 터 를 얻 거 나 ( S u c c e s s ) , 요 청 이 거 부 되 어 오 류 가 반 환 된 다
( e r r o r ) . 예 를 들 어 다 음 은 사 용 자 의 로 그 인 요 청 관 련 상 태 를 보 여 준 다 .
type UserRequest =
{ {
state: "USER_ PENDING";
}
{ {
state: "USER_ERROR";
message: string;
}
' {
state: "USER_SUCCESS";
data: User;
사 용 자 의 주 문 을 가 져 올 때 도 이 상 태 를 재 활 용 할 수 있 다 . 로 드 p y l o r d 만 요 청 형 식 에 맞 게 조 절 한 다 .
성 공 했 을 때 각 상 태 의 이 름 과 페 이
type OrderRequest =
state: "ORDER_PENDING";
state: "ORDER_ERROR";
message: string;
}
state: "ORDER_SUCCESS";
data: Order;
6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 4 5
리 덕 스 R e c u x ( h t t p s : / / r e d u x . j s . o r g ) 같 은 전 역 상 태 처 리 기 법 을 사 용 할 때 도 이 런 식 별 자 로
상 태 를 구 분 한 다 . 하 지 만 상 태 형 식 을 조 금 더 좁 히 고 싶 다 .
타 입 스 크 립 트 에 서 는 템 플 릿 리 터 럴 형 식 의 구 별 자 를 이 용 해 구 별 된 유 니 온 형 식 을 만 들 수 있
다 . 따 라 서 이 패 턴 을 이 용 해 모 든 백 엔 드 요 청 을 합 칠 수 있 다 .
type Pending = {
state: '${Uppercase<string>}\_PENDING ;
> } ;
> type Err = {
> state: '${Uppercase<string>}_ERROR*;
message: string;
} ;
type Success = {
state: '${Uppercase<string>}\_SUCCESS ;
> data: any;
> type BackendRequest = Pending | Err | Success;
> 확 실 히 전 보 다 좋 아 졌 다 . 각 유 니 온 형 식 멤 버 의 상 태 프 로 퍼 티 는 대 문 자 로 시 작 하 는 문 자 열 이
> 며 , 뒤 로 밑 줄 과 관 련 상 태 문 자 열 이 등 장 함 을 알 수 있 다 . 그 리 고 늘 그 랬 듯 이 이 를 하 위 형 식
> 으 로 좁 힐 수 있 다 .
> function execute(req: BackendRequest) {
> switch (req.state) {
> case "USER_PENDING" :
> / / req: Pending
> console. log("Login pending...");
> break;
> case "USER_ERROR":
> / / req: Err
> throw new Error(Login failed: ${req-message}*);
case "USER_SUCCESS" :
/ / req: Success
login(req-data);
break;
case "ORDER_PENDING" :
2 4 6 실 무 로 통 하 는 타 입 스 크 립 트
/ / req: Pending
console. log("Fetching orders pending");
break;
case "ORDER_ERROR":
/ / req: Err
throw new Error (Fetching orders failed: ${req-message}*);
case "ORDER_SUCCESS" :
/ / req: Success
displayOrder(req.data);
break;
}
}
전 체 문 자 열 을 구 별 자 의 첫 구 분 자 로 사 용 하 는 것 은 다 소 과 할 수 있 다 . 알 려 진 다 양 한 요 청 의
하 위 집 합 을 만 들 고 문 자 열 조 작 형 식 을 이 용 하 면 올 바 른 하 위 형 식 을 얻 을 수 있 다 .
type RequestConstants = "user" | "order";
type Pending = {
state: '${Uppercase<RequestConstants>}\_PENDING* ;
> type Err = {
> state: '${Uppercase«RequestConstants>}_ERROR ;
message: string;
3;
type Success = {
state: '${Uppercase«RequestConstants>}\_SUCCESS' ;
> data: any;
> 이 렇 게 오 타 의 가 능 성 을 줄 였 다 ! 또 한 모 든 데 이 터 를 D a t a 형 식 의 전 역 상 태 객 체 에 저 장 했 다 .
> 이 제 이 를 이 용 해 모 든 가 능 한 B a c k e n d R e q u e s t 형 식 을 도 출 할 수 있 다 . k e y o f D a t a 를 이 용
> 해 B a c k e n d R e q u e s t 상 태 를 구 성 하 는 문 자 열 키 를 얻 는 다 .
> type Data = {
> user: User / null;
> order: Order | null;
> 6 장 문 자 열 템 플 릿 리 터 럴 형 식 2 4 7
> type RequestConstants = keyof Data;
> type Pending = {
> state: '${Uppercase<RequestConstants>}\_PENDING* ;
> 3;
> type Err = 1
> state: '${Uppercase<RequestConstants>}_ERROR' ;
message: string;
};
P e n d i n g 과 E r r 에 는 잘 동 작 하 지 만 , " u s e r " 나 " o r d e r " 등 과 관 련 된 실 제 데 이 터 형 식 이 필 요
한 S u c c e s s 는 아 직 동 작 하 지 않 는 다 .
인 덱 스 접 근 을 이 용 해 D a t a 에 서 알 맞 은 d a t a 프 로 퍼 티 형 식 을 얻 을 수 있 다 .
type Success = {
state: *${Uppercase<RequestConstants>}\_SUCCESS\* ;
> data: NonNullable<Data[RequestConstants]>;
> 팁 N o n N u l l a b l e c T > 를 이 용 해 유 니 온 형 식 의 n u l L 과 u n d e f i n e d 을 제 거 할 수 있 다 . s t r i c t N u l l C h e c k s
> 를 켜 면 n u L L 과 u n d e f i n e d 가 모 든 형 식 에 서 제 외 된 다 . 따 라 서 널 종 류 의 상 태 가 필 요 하 면 수 동 으 로 추 가 하 고
> 반 대 로 필 요 하 지 않 을 땐 수 동 으 로 제 거 해 야 한 다 .
> 하 지 만 모 든 백 엔 드 요 청 시 d a t a 는 U s e r 나 O r d e r 가 될 수 있 으 며 요 청 의 종 류 를 추 가 하
> 면 d a t a 의 형 식 도 늘 어 난 다 . 모 든 R e q u e s t C o n s t a n t s 를 반 복 하 면 서 상 태 객 체 를 만 들 고 ,
> R e q u e s t C o n s t a n t s 의 인 덱 스 접 근 을 이 용 해 유 니 온 형 식 을 다 시 만 들 어 식 별 자 와 관 련 데 이
> 터 형 식 간 의 연 결 고 리 를 끊 었 다 .
> type Success = {
> [K in RequestConstants]: {
> state: "${Uppercase<K>}\_SUCCESS ;
> data: NonNullable<Data[K]>;
> 1};
> }[RequestConstants];
> 2 4 8 실 무 로 통 하 는 타 입 스 크 립 트
> 드 디 어 S u c c e s s 는 수 동 으 로 만 든 유 니 온 형 식 과 같 아 졌 다 .
> type Success = 1
> state: "USER_SUCCESS";
> d a t a : User;
> state: "ORDER_SUCCESS";
