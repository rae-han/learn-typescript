# 8장 헬퍼 형식

타입스크립트의 강점 중 하나는 다른 형식에서 원하는 형식을 파생할 수 있다는 점이다. 또한 한 형식이 바뀌면 다른 모든 파생된 형식에 자동으로 바뀐 내용이 적용된다. 이 덕분에 유지보수에 들이는 시간이 줄어들며 궁극적으로 더 강력한 형식 설정을 구현할 수 있다.

타입스크립트는 다양한 내장 유틸리티 형식을 제공하며, 지금까지 일부 내장 헬퍼를 살펴보았다. 하지만 내장 헬퍼로 충분하지 못할 때가 있다. 상황에 따라 원하는 결과를 얻으려고 알려진 기법을 다른 방식으로 적용하거나, 형식 시스템의 내부 동작을 깊숙이 파고들어야 한다. 따라서 직접 헬퍼 형식을 만들어야 할 상황이 발생한다.

이 장에서는 헬퍼 형식의 개념을 소개하고 사용자 정의 헬퍼 형식으로 다른 형식을 파생하는 능력을 확장하는 다양한 사례를 설명한다.

## 8.1 특정 프로퍼티를 선택형으로 설정하기

**문제** 특정 프로퍼티를 선택형으로 설정한 형식을 파생하고 싶다.

**해결** 두 객체 형식의 인터섹션을 수행하는 `SetOptional`이라는 사용자 정의 헬퍼 형식을 만든다.

```ts
type Person = {
  name: string;
  age: number;
  profession: string;
};
```

**논의**
`Person` 같은 형식이 있는데 모든 프로퍼티를 설정하지 않고 일부만 설정해도 되는 상황이 꽤 자주 발생한다. 다양한 형식을 유지보수하는 일은 피해야 하므로 현재 사용 중인 원래 모델에서 형식을 파생하려 한다.

### Partial<T> 헬퍼 형식

타입스크립트는 모든 프로퍼티를 선택형으로 변경하는 `Partial<T>`라는 내장 헬퍼 형식을 제공한다.

```ts
type Partial<T> = { [P in keyof T]?: T[P] };
```

### SetOptional 구현

`SetOptional` 형식을 구현하려면 먼저 선택형으로 설정할 키 집합을 추려야 한다.

```ts
type SelectPartial<T, K extends keyof T> = {
  [P in K]?: T[P];
};
```

> **노트**: 선택형 매핑 형식 변경자(optional mapped type modifier)는 프로퍼티 집합의 선택형 프로퍼티에 심볼(물음표)을 적용한다.

`Exclude` 헬퍼 형식을 이용해 나머지 키를 처리한다:

```ts
type SetOptional<T, K extends keyof T> = {
  [P in K]?: T[P];
} & {
  [P in Exclude<keyof T, K>]: T[P];
};

type OptionalAge = SetOptional<Person, 'age'>;
/*
type OptionalAge = {
  name: string;
  age?: number | undefined;
  profession: string;
};
*/
```

### 내장 헬퍼 형식을 조합한 버전

```ts
type SetOptional<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;
```

> **팁**: 편집기 힌트를 개선하려면 8.3절의 `Remap` 헬퍼 형식을 사용한다:
> ```ts
> type SetOptional<T, K extends keyof T = keyof T> = Remap<Partial<Pick<T, K>> & Omit<T, K>>;
> ```

### SetRequired와 OnlyRequired

반대로 일부 키가 꼭 필요한 상황이라면:

```ts
type SetRequired<T, K extends keyof T = keyof T> = Remap<Required<Pick<T, K>> & Omit<T, K>>;

type OnlyRequired<T, K extends keyof T = keyof T> = Remap<Required<Pick<T, K>> & Partial<Omit<T, K>>>;
```

| 헬퍼 타입 | 동작 | 사용 사례 |
|----------|------|----------|
| `Partial<T>` | 모든 프로퍼티 선택형 | 업데이트 함수 |
| `Required<T>` | 모든 프로퍼티 필수 | 완전한 객체 검증 |
| `SetOptional<T, K>` | 특정 프로퍼티만 선택형 | 부분 업데이트 |
| `SetRequired<T, K>` | 특정 프로퍼티만 필수 | 필수 필드 강제 |


## 8.2 중첩된 객체 바꾸기

**문제** `Partial`, `Required`, `Readonly` 등의 헬퍼 객체 형식은 객체의 첫 번째 수준만을 바꿀 수 있으며 중첩된 객체 프로퍼티는 처리하지 못한다.

**해결** 중첩된 객체에 같은 동작을 반복 수행할 재귀형 헬퍼 형식을 만든다.

```ts
type Settings = {
  mode: 'light' | 'dark';
  playbackSpeed: number;
  subtitles: {
    active: boolean;
    color: string;
  };
};
```

**논의**
`applySettings`는 기본 설정과 사용자 설정을 둘 다 받는다. 하지만 `subtitles`의 `active`처럼 조금 더 깊숙한 객체 프로퍼티를 바꾸려 하면 `Partial`만으로는 문제가 생긴다.

### DeepPartial 구현

```ts
type DeepPartial<T> = T extends object
  ? {
      [K in keyof T]?: DeepPartial<T[K]>;
    }
  : T;
```

> **팁**: 타입스크립트는 기본형 값을 만났을 때 재귀가 멈춘다. 오직 객체일 때만 더 깊숙이 들어가도록 조건을 추가하면 형식이 더 튼튼해지며 결과를 더 읽기 쉬워진다.

```ts
type DeepPartialSettings = DeepPartial<Settings>;
/*
type DeepPartialSettings = {
  mode?: "light" | "dark" | undefined;
  playbackSpeed?: number | undefined;
  subtitles?: {
    active?: boolean | undefined;
    color?: string | undefined;
  } | undefined;
};
*/
```

### Lodash merge로 해결

```ts
import { merge } from 'lodash';

function applySettings(defaultSettings: Settings, userSettings: DeepPartial<Settings>): Settings {
  return merge(defaultSettings, userSettings);
}
```

> **2025 업데이트**: structuredClone API가 모든 주요 런타임에서 지원되면서 깊은 복사가 더 쉬워졌다. 단, merge 기능은 별도 구현이 필요하다.


## 8.3 형식 재매핑하기

**문제** 형식을 직접 만들면 유연하고 자체 유지보수되는 형식을 만들 수 있지만, 편집기 힌트 측면에서는 아쉬운 점이 많다.

**해결** `Remap<T>`, `DeepRemap<T>` 헬퍼 형식을 이용해 편집기 힌트를 개선한다.

**논의**
`OnlyRequired`의 형식을 편집기로 확인해 보면 형식이 어떻게 만들어졌는지에 관한 정보를 얻을 수 있지만, 최종 형식 결과를 보여주지 않는다.

### Remap 헬퍼 형식

```ts
type Remap<T> = {
  [K in keyof T]: T[K];
};
```

`Remap<T>`은 모든 프로퍼티를 반복하면서 정의된 값으로 매핑하는 객체 형식이다. 갱신과 필터링은 일어나지 않으며 입력한 내용을 그대로 쏟아낸다.

```ts
type NameRequired = Remap<OnlyRequired<Person, 'name'>>;
/*
type NameRequired = {
  name: string;
  age?: number | undefined;
  profession?: string | undefined;
};
*/
```

> **노트**: 이를 `Debug`나 `Simplify`라 부르기도 한다. `Remap`은 같은 도구를 가리키는 또 다른 이름일 뿐이다.

### DeepRemap 구현

```ts
type DeepRemap<T> = T extends object
  ? {
      [K in keyof T]: DeepRemap<T[K]>;
    }
  : T;
```

> **팁**: `Remap` 적용 여부는 취향의 문제다. 구현을 자세히 알고 싶을 때도 있고, 확장 버전보다 중첩된 형식을 간단하게 표현하면 더 읽기 쉬울 때도 있다.


## 8.4 모든 필수 키 얻기

**문제** 객체에서 모든 필수(required) 프로퍼티를 추출하는 형식을 만들어야 한다.

**해결** 필수 키를 이용한 하위 형식 검사로 키를 거르는 매핑된 헬퍼 형식 `GetRequired<T>`를 만든다.

**논의**
선택형 프로퍼티는 형식 호환성에 큰 영향을 미친다. 물음표 같은 간단한 형식 변경자는 기존 형식을 크게 넓힌다.

### GetRequired 구현

```ts
type GetRequired<T> = {
  [K in keyof T as T[K] extends Required<T>[K] ? K : never]: T[K];
};
```

> **팁**: 조건을 만족하면 K를 출력하고 그렇지 않으면 `never`를 이용해 해당 프로퍼티를 제거한다.

### RequiredKeys와 GetOptional

```ts
type RequiredKeys<T> = keyof GetRequired<T>;

type GetOptional<T> = Omit<T, RequiredKeys<T>>;
```


## 8.5 최소한 한 개의 프로퍼티 허용하기

**문제** 어떤 형식을 사용할 때 최소한 한 개의 프로퍼티는 설정하도록 강제하고 싶다.

**해결** 객체를 한 개의 프로퍼티를 포함하는 여러 객체 유니온으로 분리하는 헬퍼 형식 `Split<T>`를 만든다.

```ts
type VideoFormatURLs = {
  format360p: URL;
  format480p: URL;
  format720p: URL;
  format1080p: URL;
};
```

**논의**
`Partial<VideoFormatURLs>`를 사용하면 빈 객체도 허용되어 문제가 된다.

### Split 형식 구현

```ts
type Split<T> = {
  [K in keyof T]: {
    [P in K]: T[P];
  };
}[keyof T];
```

> **팁**: 유니온 형식은 모든 교차 지점에 있는 값을 허용하므로, 이렇게 형식을 정의하면 한 개 이상의 프로퍼티를 제공할 수 있다.

```ts
function loadVideo(formats: Split<VideoFormatURLs>) {
  // 구현 중
}

loadVideo({}); // 오류 발생!
loadVideo({ format480p: new URL('...') }); // 동작함
```


## 8.6 정확히 한 개 허용, 모두 허용, 아무것도 허용하지 않기

**문제** 8.5절에서는 적어도 한 개 이상의 프로퍼티를 요구했지만, 정확히 한 개만 허용하거나 모두 허용하거나 아무것도 허용하지 않아야 할 때가 있다.

**해결** `ExactlyOne<T>`과 `AllOrNone<T, K>`을 만든다. 두 형식 모두 `Split<T>`의 파생형과 선택형 never 기법을 사용한다.

### ExactlyOne 구현

```ts
type ExactlyOne<T> = {
  [K in keyof T]: {
    [P in K]: T[P];
  } & {
    [P in Exclude<keyof T, K>]?: never;
  };
}[keyof T];
```

```ts
function loadVideo(formats: ExactlyOne<VideoFormatURLs>) {
  // 구현 중
}

loadVideo({ format360p: new URL('...') }); // 동작함

loadVideo({
  format360p: new URL('...'),
  format1080p: new URL('...'),
}); // 오류 발생!
```

### AllOrNone 구현

```ts
type AllOrNone<T, Keys extends keyof T> = (Required<Pick<T, Keys>> | Partial<Record<Keys, never>>) & Split<T>;
```

| 헬퍼 타입 | 허용 조건 | 사용 사례 |
|----------|----------|----------|
| `Split<T>` | 최소 1개 | 필수 선택 |
| `ExactlyOne<T>` | 정확히 1개 | 단일 옵션 선택 |
| `AllOrNone<T, K>` | 전부 또는 없음 | 관련 필드 그룹 |


## 8.7 유니온을 인터섹션 형식으로 변환하기

**문제** 여러 변형을 포함하는 유니온 형식으로 모델을 정의했다. 여기서 다른 형식을 파생하려면 유니온 형식을 인터섹션 형식으로 먼저 변환해야 한다.

**해결** 반변(contravariant) 위치를 사용하는 헬퍼 형식 `UnionToIntersection<T>`을 만든다.

```ts
type Video = BasicVideoData & (Format320 | Format480 | Format720 | Format1080);
```

**논의**
유니온 형식에 인덱스 접근을 하면 가장 낮은 공통 분모를 찾으려 시도하는데, 이 예제에서는 존재하지 않아 `never`가 된다.

### UnionToIntersection 구현

```ts
type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
```

### 공변과 반변 (Covariance and Contravariance)

| 개념 | 역할 | 예시 | 할당 규칙 |
|-----|------|------|----------|
| **공변** | 생산자 (Producer) | 함수 반환값, 변수 | 더 구체적인 것 → 더 일반적인 곳 |
| **반변** | 소비자 (Consumer) | 함수 매개변수 | 더 일반적인 것 → 더 구체적인 곳 |

> **팁**: 반변 위치에서 타입스크립트는 모든 가능한 입력을 처리해야 하므로 인터섹션을 만든다. 이 원리를 활용해 유니온을 인터섹션으로 변환한다.

### 실제 사용 예시

```ts
type Intersected = UnionToIntersection<Video['urls']>;
/*
{
  format320p: URL;
  format480p: URL;
  format720p: URL;
  format1080p: URL;
}
*/

type FormatKeys = keyof UnionToIntersection<Video['urls']>;
// "format320p" | "format480p" | "format720p" | "format1080p"
```


## 8.8 type-fest 사용하기

**문제** 지금까지 얻은 여러 헬퍼 형식을 쉽게 사용할 수 있도록 유틸리티 라이브러리를 만들려 한다.

**해결** 필요한 모든 기능을 type-fest에서 이미 제공할 것이다.

**논의**
이 장에서는 표준 타입스크립트에서 제공하지 않는 유용한 몇 가지 헬퍼 형식을 소개했다.

### type-fest의 특징

1. **광범위한 문서화**: 특정 헬퍼 형식의 사용법에서 시작해 사용 사례와 시나리오도 제공한다.
2. **경계 상황 처리**: `PartialDeep<T>`은 `Map`, `Set`, 배열 등 모든 경계 상황을 다룬다.
3. **거절된 형식 목록과 이유 제공**: 사용 사례가 제한적이거나 더 좋은 대안이 있을 때 형식 추가를 거절한다.
4. **기존 헬퍼 형식 학습 기회**: 타입스크립트의 내장 헬퍼 형식에 대한 예제와 사용 방법도 제공한다.
5. **활발한 유지보수**: 많은 사람이 사용하며 오픈 소스 개발자들 덕에 안정적으로 개발이 진행 중이다.

> **팁**: 프로젝트의 특성에 따라 단순한 버전을 사용하는 편이 좋을 수도 있다. 복잡한 형식은 타입스크립트 형식 검사기에 부담을 줄 수 있다.

> **2025 업데이트**: type-fest 4.x 버전은 TypeScript 5.0+ 기능을 적극 활용한다. `const` 타입 매개변수, `NoInfer`, `satisfies` 등 최신 기능과 함께 사용하면 더 강력한 타입 안전성을 얻을 수 있다.

---

## 내장 유틸리티 타입 요약

| 유틸리티 | 동작 | 예시 |
|---------|------|------|
| `Partial<T>` | 모든 프로퍼티 선택형 | `Partial<Person>` |
| `Required<T>` | 모든 프로퍼티 필수 | `Required<Person>` |
| `Readonly<T>` | 모든 프로퍼티 읽기전용 | `Readonly<Person>` |
| `Pick<T, K>` | 특정 프로퍼티만 선택 | `Pick<Person, 'name'>` |
| `Omit<T, K>` | 특정 프로퍼티 제외 | `Omit<Person, 'age'>` |
| `Record<K, V>` | 키-값 객체 생성 | `Record<string, URL>` |
| `Exclude<T, U>` | 유니온에서 제외 | `Exclude<'a' \| 'b', 'a'>` |
| `Extract<T, U>` | 유니온에서 추출 | `Extract<'a' \| 'b', 'a'>` |
| `NonNullable<T>` | null/undefined 제거 | `NonNullable<string \| null>` |
| `ReturnType<F>` | 함수 반환 타입 | `ReturnType<typeof fn>` |
| `Parameters<F>` | 함수 매개변수 타입 | `Parameters<typeof fn>` |

## 커스텀 헬퍼 타입 요약

| 헬퍼 타입 | 용도 |
|----------|------|
| `SetOptional<T, K>` | 특정 프로퍼티만 선택형 |
| `DeepPartial<T>` | 중첩된 모든 프로퍼티 선택형 |
| `Remap<T>` / `Simplify<T>` | 편집기 힌트 개선 |
| `GetRequired<T>` | 필수 프로퍼티만 추출 |
| `Split<T>` | 최소 1개 프로퍼티 강제 |
| `ExactlyOne<T>` | 정확히 1개 프로퍼티 강제 |
| `UnionToIntersection<T>` | 유니온을 인터섹션으로 |
