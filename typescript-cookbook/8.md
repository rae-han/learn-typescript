# 8장 헬퍼 형식

타입스크립트의 강점 중 하나는 다른 형식에서 원하는 형식을 파생할 수 있다는 점이다. 또한 한 형식이 바뀌면 다른 모든 파생된 형식에 자동으로 바뀐 내용이 적용된다. 이 덕분에 유지보수에 들이는 시간이 줄어들며 궁극적으로 더 강력한 형식 설정을 구현할 수 있다.

타입스크립트는 다양한 내장 유틸리티 형식을 제공하며, 지금까지 일부 내장 헬퍼를 살펴보았다. 하지만 내장 헬퍼로 충분하지 못할 때가 있다. 상황에 따라 원하는 결과를 얻으려고 알려진 기법을 다른 방식으로 적용하거나, 형식 시스템의 내부 동작을 깊숙이 파고들어야 한다. 따라서 직접 헬퍼 형식을 만들어야 할 상황이 발생한다.

이 장에서는 헬퍼 형식의 개념을 소개하고 사용자 정의 헬퍼 형식으로 다른 형식을 파생하는 능력을 확장하는 다양한 사례를 설명한다. 결국 타입스크립트의 형식 시스템을 자체적인 함수형 메타프로그래밍 언어로 생각할 수 있다.

## 8.1 특정 프로퍼티를 선택형으로 설정하기

**문제** 특정 프로퍼티를 선택형으로 설정한 형식을 파생하고 싶다.

**해결** 두 객체 형식의 인터섹션을 수행하는 `SetOptional`이라는 사용자 정의 헬퍼 형식을 만든다.

**논의** 타입스크립트 프로젝트에 모든 모델을 설정하고 정의했으며 코드에서 이들을 참조하려 한다.

```ts
type Person = {
  name: string;
  age: number;
  profession: string;
};
```

`Person` 같은 형식이 있는데 모든 프로퍼티를 설정하지 않고 일부만 설정해도 되는 상황(프로퍼티 중 일부는 선택형)이 꽤 자주 발생한다. 다양한 형식을 유지보수하는 일은 피해야 하므로 현재 사용 중인 원래 모델에서 형식을 파생하려 한다.

### Partial<T> 헬퍼 형식

타입스크립트는 모든 프로퍼티를 선택형으로 변경하는 `Partial<T>`라는 내장 헬퍼 형식을 제공한다.

```ts
type Partial<T> = { [P in keyof T]?: T[P] };
```

이 헬퍼 형식은 모든 키에 선택형 매핑 형식 변경자를 사용해 프로퍼티를 선택형으로 만드는 매핑된 형식이다.

### SelectPartial 구현

`SetOptional` 형식을 구현하려면 먼저 선택형으로 설정할 키 집합을 추려야 한다.

```ts
type SelectPartial<T, K extends keyof T> = {
  [P in K]?: T[P];
};
```

> **노트**: 선택형 매핑 형식 변경자(optional mapped type modifier)는 프로퍼티 집합의 선택형 프로퍼티에 심볼(물음표)을 적용한다.

`SelectPartial<T, K extends keyof T>`에서 모든 키가 아니라 제공된 하위 집합 키만 매핑한다. `extends keyof T` 제네릭 제약 덕분에 유효한 프로퍼티 키만 전달할 수 있다.

```ts
type Age = SelectPartial<Person, 'age'>;
// type Age = { age?: number | undefined };
```

원하는 프로퍼티를 선택형으로 설정하며 절반의 작업을 완성했다. 하지만 나머지 프로퍼티는 사라진 상태다.

### Exclude를 이용한 나머지 키 처리

기존 객체 형식에 프로퍼티를 추가해 확장하는 가장 쉬운 방법은 다른 객체 형식과 인터섹션 형식을 취해 새 형식을 만드는 것이다.

`Exclude` 헬퍼 형식을 이용해 모든 나머지 키를 얻는다. `Exclude<T, U>`는 두 집합을 비교하는 조건부 형식이다. 집합 T의 요소가 U에 존재하면 `never`를 이용해 해당 요소를 제거하고 그렇지 않으면 형식에 그대로 둔다.

```ts
type Exclude<T, U> = T extends U ? never : T;
```

```ts
// 타입스크립트가 헬퍼 형식을 평가하는 단계
type ExcludeAge = Exclude<'name' | 'age', 'age'>;

// 1. 분배
type ExcludeAge = ('name' extends 'age' ? never : 'name') | ('age' extends 'age' ? never : 'age');

// 2. 평가
type ExcludeAge = 'name' | never;

// 3. 불필요한 never 제거
type ExcludeAge = 'name';
```

### SetOptional 완성

```ts
type SetOptional<T, K extends keyof T> = {
  [P in K]?: T[P];
} & {
  [P in Exclude<keyof T, K>]: T[P];
};

type OptionalAge = SetOptional<Person, 'age'>;
/*
type OptionalAge = {
  name: string;
  age?: number | undefined;
  profession: string;
};
*/
```

여러 키를 선택형으로 만들고 싶을 때는 유니온 형식으로 프로퍼티 키를 제공한다:

```ts
type OptionalAgeAndProf = SetOptional<Person, 'age' | 'profession'>;
```

### 내장 헬퍼 형식을 조합한 버전

```ts
type SetOptional<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;
```

- `Pick<T, K>`은 객체 T에서 키 K를 선택한다.
- `Omit<T, K>`은 객체 T에서 K를 제외한 나머지를 선택한다.
- `Partial<T>`는 모든 프로퍼티를 선택형으로 만든다.

### Remap으로 가독성 개선

편집기 힌트를 개선하려면 8.3절의 `Remap` 헬퍼 형식을 사용한다:

```ts
type SetOptional<T, K extends keyof T> = Remap<Partial<Pick<T, K>> & Omit<T, K>>;
```

### 기본값 설정 최적화

두 번째 인수에 기본값을 설정하면 더 유연해진다:

```ts
type SetOptional<T, K extends keyof T = keyof T> = Remap<Partial<Pick<T, K>> & Omit<T, K>>;
```

### SetRequired와 OnlyRequired

반대로 일부 키가 꼭 필요한 상황이라면:

```ts
type SetRequired<T, K extends keyof T = keyof T> = Remap<Required<Pick<T, K>> & Omit<T, K>>;

type OnlyRequired<T, K extends keyof T = keyof T> = Remap<Required<Pick<T, K>> & Partial<Omit<T, K>>>;
```

## 8.2 중첩된 객체 바꾸기

**문제** `Partial`, `Required`, `Readonly` 등의 헬퍼 객체 형식은 객체의 첫 번째 수준만을 바꿀 수 있으며 중첩된 객체 프로퍼티는 처리하지 못한다.

**해결** 중첩된 객체에 같은 동작을 반복 수행할 재귀형 헬퍼 형식을 만든다.

**논의** 사용자가 조절할 수 있는 다양한 설정을 제공하는 애플리케이션이 있다고 가정하자. 시간이 지나면서 설정을 쉽게 확장할 수 있도록 기본 설정과 사용자가 설정의 다른 부분만 저장한다.

```ts
type Settings = {
  mode: 'light' | 'dark';
  playbackSpeed: number;
  subtitles: {
    active: boolean;
    color: string;
  };
};

const defaults: Settings = {
  mode: 'dark',
  playbackSpeed: 1.0,
  subtitles: {
    active: false,
    color: 'white',
  },
};
```

### Partial의 한계

`applySettings`는 기본 설정과 사용자 설정을 둘 다 받는다:

```ts
function applySettings(defaultSettings: Settings, userSettings: Partial<Settings>): Settings {
  return { ...defaultSettings, ...userSettings };
}
```

첫 번째 수준에 있는 프로퍼티를 설정할 때는 문제없이 동작한다:

```ts
let settings = applySettings(defaults, { mode: 'light' });
```

하지만 `subtitles`의 `active`처럼 조금 더 깊숙한 객체 프로퍼티를 바꾸려 하면 문제가 생긴다:

```ts
let settings = applySettings(defaults, { subtitles: { active: true } });
// 오류: 'color' 속성이 '{ active: true; }' 형식에 없지만
// '{ active: boolean; color: string; }' 형식에서 필수입니다. ts(2741)
```

### DeepPartial 구현

모든 프로퍼티를 재귀적으로 탐색하며 각 수준에서 선택형 매핑 형식 변경자를 적용하는 `DeepPartial<T>`을 만들어야 한다.

```ts
type DeepPartial<T> = T extends object
  ? {
      [K in keyof T]?: DeepPartial<T[K]>;
    }
  : T;
```

타입스크립트는 기본형 값을 만났을 때 재귀가 멈춘다. 오직 객체일 때만 더 깊숙이 들어가도록 조건을 추가하면 형식이 더 튼튼해지며 결과를 더 읽기 쉬워진다.

```ts
type DeepPartialSettings = DeepPartial<Settings>;
/*
type DeepPartialSettings = {
  mode?: "light" | "dark" | undefined;
  playbackSpeed?: number | undefined;
  subtitles?: {
    active?: boolean | undefined;
    color?: string | undefined;
  } | undefined;
};
*/
```

### Lodash merge로 해결

비구조화를 이용한 객체 합치기도 `Partial<T>`처럼 오직 첫 수준에서만 동작한다. Lodash의 `merge` 함수를 활용해 이 문제를 해결한다:

```ts
import { merge } from 'lodash';

function applySettings(defaultSettings: Settings, userSettings: DeepPartial<Settings>): Settings {
  return merge(defaultSettings, userSettings);
}
```

`merge`는 두 객체의 인터섹션을 만들도록 인터페이스를 정의한다:

```ts
function merge<TObject, TSource>(object: TObject, source: TSource): TObject & TSource;
```

비슷한 방법으로 `DeepReadonly`와 `DeepRequired`를 만들 수 있다.

## 8.3 형식 재매핑하기

**문제** 형식을 직접 만들면 유연하고 자체 유지보수되는 형식을 만들 수 있지만, 편집기 힌트 측면에서는 아쉬운 점이 많다.

**해결** `Remap<T>`, `DeepRemap<T>` 헬퍼 형식을 이용해 편집기 힌트를 개선한다.

**논의** 타입스크립트의 형식 시스템으로 새 형식을 만들었는데, 편집기 힌트는 해독하기 아주 어려운 힌트를 제공할 때가 있다.

8.1절의 `OnlyRequired`를 살펴보자:

```ts
type OnlyRequired<T, K extends keyof T = keyof T> = Required<Pick<T, K>> & Partial<Omit<T, K>>;

type Person = {
  name: string;
  age: number;
  profession: string;
};

type NameRequired = OnlyRequired<Person, 'name'>;
```

`NameRequired`의 형식을 편집기로 확인해 보면 형식이 어떻게 만들어졌는지에 관한 정보를 얻을 수 있지만, 최종 형식 결과를 보여주지 않는다:

```
type NameRequired = Required<Pick<Person, "name">> & Partial<Omit<Person, "name">>
```

### Remap 헬퍼 형식

`Remap`이라는 단순하며 효율적인 형식을 이용하면 실제 형식과 비슷한 최종 결과물을 얻을 수 있다:

```ts
type Remap<T> = {
  [K in keyof T]: T[K];
};
```

`Remap<T>`은 모든 프로퍼티를 반복하면서 정의된 값으로 매핑하는 객체 형식이다. 갱신과 필터링은 일어나지 않으며 입력한 내용을 그대로 쏟아낸다. 따라서 타입스크립트는 매핑된 형식의 모든 프로퍼티를 출력하므로 실제 형식을 확인할 수 있다.

```ts
type NameRequired = Remap<OnlyRequired<Person, 'name'>>;
/*
type NameRequired = {
  name: string;
  age?: number | undefined;
  profession?: string | undefined;
};
*/
```

> **노트**: 이를 `Debug`나 `Simplify`라 부르기도 한다. `Remap`은 같은 도구를 가리키는 또 다른 이름일 뿐이다.

### DeepRemap 구현

`Remap<T>`도 첫 수준에서만 동작한다. 중첩된 형식은 재귀 버전을 만들어야 한다:

```ts
type DeepRemap<T> = T extends object
  ? {
      [K in keyof T]: DeepRemap<T[K]>;
    }
  : T;

type Subtitles = {
  active: boolean;
  color: string;
};

type Settings = {
  mode: 'light' | 'dark';
  playbackSpeed: number;
  subtitles: Subtitles;
};

type SettingsRemapped = DeepRemap<Settings>;
/*
type SettingsRemapped = {
  mode: "light" | "dark";
  playbackSpeed: number;
  subtitles: {
    active: boolean;
    color: string;
  };
};
*/
```

`Remap` 적용 여부는 취향의 문제다. 구현을 자세히 알고 싶을 때도 있고, 확장 버전보다 중첩된 형식을 간단하게 표현하면 더 읽기 쉬울 때도 있다.

## 8.4 모든 필수 키 얻기

**문제** 객체에서 모든 필수(required) 프로퍼티를 추출하는 형식을 만들어야 한다.

**해결** 필수 키를 이용한 하위 형식 검사로 키를 거르는 매핑된 헬퍼 형식 `GetRequired<T>`를 만든다.

**논의** 선택형 프로퍼티는 형식 호환성에 큰 영향을 미친다. 물음표 같은 간단한 형식 변경자는 기존 형식을 크게 넓힌다.

```ts
type Person = {
  name: string;
  age?: number;
};

function printPerson(person: Person): void {
  // ...
}

type Student = {
  name: string;
  semester: number;
};

const student: Student = {
  name: 'Stefan',
  semester: 37,
};

printPerson(student); // 동작함!
```

`Person`은 `age`를 정의했지만 `Student`는 `age`를 포함하지 않는다. `age`는 선택형이므로 `Student` 형식의 객체를 `printPerson`에 사용할 수 있다.

### Required<T>를 이용한 검사

어떤 객체의 모든 키가 필수인지 검사하려면 `Required<T>`를 사용한다:

```ts
type Name = {
  name: string;
};

type Test = Name extends Required<Name> ? true : false;
// type Test = true
```

선택형 프로퍼티를 포함하는 객체는:

```ts
type Person = {
  name: string;
  age?: number;
};

type Test = Person extends Required<Person> ? true : false;
// type Test = false
```

### GetRequired 구현

각 프로퍼티에 조건부 검사를 수행해 `Required` 버전의 하위 집합인지 확인한다:

```ts
type GetRequired<T> = {
  [K in keyof T as T[K] extends Required<T>[K] ? K : never]: T[K];
};
```

조건을 만족하면 K를 출력하고 그렇지 않으면 `never`를 이용해 해당 프로퍼티를 제거한다.

### RequiredKeys와 GetOptional

`GetRequired<T>`와 `keyof` 연산자를 이용하면 모든 필수 프로퍼티 키를 쉽게 얻을 수 있다:

```ts
type RequiredKeys<T> = keyof GetRequired<T>;
```

그리고 `Omit<T>`을 이용해 대상 객체에서 이들 프로퍼티를 제거한다:

```ts
type GetOptional<T> = Omit<T, RequiredKeys<T>>;
```

## 8.5 최소한 한 개의 프로퍼티 허용하기

**문제** 어떤 형식을 사용할 때 최소한 한 개의 프로퍼티는 설정하도록 강제하고 싶다.

**해결** 객체를 한 개의 프로퍼티를 포함하는 여러 객체 유니온으로 분리하는 헬퍼 형식 `Split<T>`를 만든다.

**논의** 다음처럼 URL 집합을 포함하는 객체를 정의하는 애플리케이션이 있다:

```ts
type VideoFormatURLs = {
  format360p: URL;
  format480p: URL;
  format720p: URL;
  format1080p: URL;
};
```

`loadVideo` 함수는 이들 비디오 포맷 URL 중 한 개 이상의 URL을 가져온다:

```ts
function loadVideo(formats: VideoFormatURLs) {
  // 구현 중
}
```

### Partial의 문제점

일부 비디오 포맷은 존재하지 않을 수 있으므로 `Partial<VideoFormatURLs>`를 이용해 매개변수 형식을 조절한다:

```ts
function loadVideo(formats: Partial<VideoFormatURLs>) {
  // 구현 중
}

loadVideo({
  format480p: new URL('...'),
  format720p: new URL('...'),
}); // 동작함

loadVideo({}); // 빈 객체도 허용됨 - 문제!
```

비디오를 불러오려면 최소한 한 개의 URL이 필요하기 때문에 빈 객체는 문제가 된다.

### Split 형식 구현

한 개의 프로퍼티만 설정하는 모든 상황을 포함하는 유니온 형식을 만들어야 한다:

```ts
type AvailableVideoFormats = { format360p: URL } | { format480p: URL } | { format720p: URL } | { format1080p: URL };
```

유니온 형식은 모든 교차 지점에 있는 값을 허용하므로, 이렇게 형식을 정의하면 한 개 이상의 프로퍼티를 제공할 수 있다.

매핑된 형식을 이용해 이를 구현한다:

```ts
type Split<T> = {
  [K in keyof T]: {
    [P in K]: T[P];
  };
}[keyof T];
```

단계별로 살펴보면:

```ts
// 1단계: 각 프로퍼티를 매핑
type Step1 = {
  [K in keyof VideoFormatURLs]: K;
};
/*
{
  format360p: "format360p";
  format480p: "format480p";
  format720p: "format720p";
  format1080p: "format1080p";
}
*/

// 2단계: 각 키에 대해 객체 형식 생성
type Step2 = {
  [K in keyof VideoFormatURLs]: {
    [P in K]: VideoFormatURLs[P];
  };
};
/*
{
  format360p: { format360p: URL };
  format480p: { format480p: URL };
  format720p: { format720p: URL };
  format1080p: { format1080p: URL };
}
*/

// 3단계: 인덱스 접근으로 유니온 생성
type Step3 = Step2[keyof VideoFormatURLs];
/*
{ format360p: URL } | { format480p: URL } | { format720p: URL } | { format1080p: URL }
*/
```

### 사용 예시

```ts
function loadVideo(formats: Split<VideoFormatURLs>) {
  // 구현 중
}

loadVideo({}); // 오류 발생!
loadVideo({ format480p: new URL('...') }); // 동작함
```

## 8.6 정확히 한 개 허용, 모두 허용, 아무것도 허용하지 않기

**문제** 8.5절에서는 적어도 한 개 이상의 프로퍼티를 요구했지만, 정확히 한 개만 허용하거나 모두 허용하거나 아무것도 허용하지 않아야 할 때가 있다.

**해결** `ExactlyOne<T>`과 `AllOrNone<T, K>`을 만든다. 두 형식 모두 `Split<T>`의 파생형과 선택형 never 기법을 사용한다.

**논의** 8.5절에서는 `Split<T>`을 이용해 최소한 한 개 매개변수를 제공하도록 하는 헬퍼 형식을 만들었다. 여기서는 정확히 한 개의 매개변수만 허용하도록 한다.

### 선택형 never 기법

3.8절에서 살펴본 선택형 never 기법을 이용한다. 허용하지 않는 나머지 프로퍼티는 모두 선택형으로 설정하고 값은 `never`로 설정한다.

### ExactlyOne 구현

```ts
type ExactlyOne<T> = {
  [K in keyof T]: {
    [P in K]: T[P];
  } & {
    [P in Exclude<keyof T, K>]?: never;
  };
}[keyof T];
```

결과 형식:

```ts
type ExactlyOneVideoFormat = ExactlyOne<VideoFormatURLs>;
/*
({ format360p: URL } & { format480p?: never; format720p?: never; format1080p?: never })
| ({ format480p: URL } & { format360p?: never; format720p?: never; format1080p?: never })
| ({ format720p: URL } & { format360p?: never; format480p?: never; format1080p?: never })
| ({ format1080p: URL } & { format360p?: never; format480p?: never; format720p?: never })
*/
```

```ts
function loadVideo(formats: ExactlyOne<VideoFormatURLs>) {
  // 구현 중
}

loadVideo({ format360p: new URL('...') }); // 동작함

loadVideo({
  format360p: new URL('...'),
  format1080p: new URL('...'),
}); // 오류 발생!
```

### Split과 ExactlyOne 통합

```ts
type Split<T, OptionalNever extends boolean = false> = {
  [K in keyof T]: {
    [P in K]: T[P];
  } & (OptionalNever extends false
    ? {}
    : {
        [P in Exclude<keyof T, K>]?: never;
      });
}[keyof T];

type ExactlyOne<T> = Split<T, true>;
```

### AllOrNone 구현

모든 인수를 제공하거나 아무 인수도 제공하지 않는 시나리오:

```ts
type AllOrNone<T, Keys extends keyof T> =
  | {
      [K in Keys]-?: T[K]; // 모두 사용할 수 있음
    }
  | {
      [K in Keys]?: never; // 또는 아무것도 사용할 수 없음
    };
```

`Split<T>`와 조합해 빈 객체 문제를 해결한다:

```ts
type AllOrNone<T, Keys extends keyof T> = (
  | {
      [K in Keys]-?: T[K];
    }
  | {
      [K in Keys]?: never;
    }
) &
  Split<T>;
```

내장 헬퍼 형식으로 더 읽기 쉽게:

```ts
type AllOrNone<T, Keys extends keyof T> = (Required<Pick<T, Keys>> | Partial<Record<Keys, never>>) & Split<T>;
```

```ts
function loadVideo(formats: AllOrNone<VideoFormatURLs, 'format360p' | 'format480p'>) {
  // 구현 중
}

loadVideo({
  format360p: new URL('...'),
  format480p: new URL('...'),
}); // 동작함 - 둘 다 제공

loadVideo({
  format1080p: new URL('...'),
}); // 동작함 - SD 포맷 없이 HD만

loadVideo({
  format360p: new URL('...'),
  format1080p: new URL('...'),
}); // 오류 - format480p 없이 format360p만 제공
```

## 8.7 유니온을 인터섹션 형식으로 변환하기

**문제** 여러 변형을 포함하는 유니온 형식으로 모델을 정의했다. 여기서 다른 형식을 파생하려면 유니온 형식을 인터섹션 형식으로 먼저 변환해야 한다.

**해결** 반변(contravariant) 위치를 사용하는 헬퍼 형식 `UnionToIntersection<T>`을 만든다.

**논의** 여러 변형을 포함하는 유니온 형식을 모델로 정의할 수 있다:

```ts
type BasicVideoData = {
  // 구현 중
};

type Format320 = { urls: { format320p: URL } };
type Format480 = { urls: { format480p: URL } };
type Format720 = { urls: { format720p: URL } };
type Format1080 = { urls: { format1080p: URL } };

type Video = BasicVideoData & (Format320 | Format480 | Format720 | Format1080);
```

### 유니온의 문제점

유니온 형식에 인덱스 접근을 하면 가장 낮은 공통 분모를 찾으려 시도하는데, 이 예제에서는 존재하지 않는다:

```ts
type FormatKeys = keyof Video['urls'];
// FormatKeys = never
// 의도한 결과가 아님!
```

### UnionToIntersection 구현

```ts
type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
```

이 코드를 이해하려면 다음 개념을 알아야 한다:

1. 두 개의 조건부 형식이 있다
2. 첫 번째는 함수 인수로 형식을 감싸고, 두 번째는 이를 푼다
3. 두 조건부 형식이 유니온을 인터섹션으로 변환한다

---

### 공변과 반변 (Covariance and Contravariance) 상세 설명

#### 공변 (Covariance)

**정의**: 하위 타입 관계가 그대로 유지되는 상황

```ts
declare let b: string;
declare let c: string | number;

c = b; // 할당 가능!
```

`string`은 `string | number`의 하위 형식이다. `string`의 모든 요소는 `string | number`에 포함되므로 `b`를 `c`에 할당할 수 있다. 이를 **공변**이라 한다.

**발생 위치**:

- 일반 변수 할당
- 함수의 반환 타입

#### 반변 (Contravariance)

**정의**: 하위 타입 관계가 **뒤집히는** 상황

```ts
type Fun<X> = (...args: X[]) => void;

declare let f: Fun<string>;
declare let g: Fun<string | number>;

g = f; // 할당 불가!
```

`f`는 숫자를 인수로 호출할 수 없으므로 `f`를 `g`에 할당할 수 없다. `g`의 일부 기능을 제공하지 못하기 때문이다. 이것이 **반변**이다.

**발생 위치**:

- 함수 매개변수

#### 생산자와 소비자 비유

| 개념     | 역할              | 예시              | 할당 규칙                       |
| -------- | ----------------- | ----------------- | ------------------------------- |
| **공변** | 생산자 (Producer) | 함수 반환값, 변수 | 더 구체적인 것 → 더 일반적인 곳 |
| **반변** | 소비자 (Consumer) | 함수 매개변수     | 더 일반적인 것 → 더 구체적인 곳 |

**생산자 예시** (공변):

```
엔터테인먼트 ← 음악 ← 락
(넓음)              (좁음)

데이비드 보위(락 생산자)는 음악 생산자로도 사용할 수 있다.
```

**소비자 예시** (반변):

```
에너지원 ← 식물 ← 대나무
(넓음)           (좁음)

잡식동물(에너지원 소비자)은 대나무도 먹을 수 있다.
대나무 소비자(판다)는 모든 에너지원을 소비할 수 없다.
```

#### 반변이 인터섹션을 만드는 이유

`f`가 `string`을 받고, `g`가 `string | number`를 받을 때, 둘이 공통으로 받는 것은:

```ts
(string | number) & string = string
```

반변 위치에서 타입스크립트는 모든 가능한 입력을 처리해야 하므로 인터섹션을 만든다.

---

### UnionToIntersection 단계별 분석

```ts
type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
```

#### 1단계: 네이키드 타입과 분배 조건부 형식

```ts
type WrapNaked<T> = T extends any ? { o: T } : never;

type Foo = WrapNaked<string | number | boolean>;
// 네이키드 형식이므로 분배됨:
// = WrapNaked<string> | WrapNaked<number> | WrapNaked<boolean>
// = { o: string } | { o: number } | { o: boolean }
```

네이키드 형식(감싸지 않은 T)은 유니온의 각 구성 요소에 조건부 형식을 분배한다.

#### 2단계: 함수로 감싸기

```ts
(T extends any ? (x: T) => any : never)
```

조건 `T extends any`는 항상 참이므로, 각 유니온 멤버를 함수 매개변수로 감싼다:

```ts
// 입력: { format320p: URL } | { format480p: URL } | ...

// 분배 후:
| ((x: { format320p: URL }) => any)
| ((x: { format480p: URL }) => any)
| ((x: { format720p: URL }) => any)
| ((x: { format1080p: URL }) => any)
```

#### 3단계: infer로 추론 (반변 위치)

```ts
... extends (x: infer R) => any ? R : never
```

함수 매개변수 위치에서 `R`을 추론한다. 이 위치는 **반변 위치**이므로, 타입스크립트는 모든 유니온 멤버를 만족시키는 인터섹션을 만든다:

```ts
// 반변 위치에서 추론하므로:
R = { format320p: URL } & { format480p: URL } & { format720p: URL } & { format1080p: URL };
```

#### 전체 과정 시각화

```
입력 유니온:
  A | B | C | D

      ↓ 네이키드 분배

  A extends any ? (x: A) => any : never
| B extends any ? (x: B) => any : never
| C extends any ? (x: C) => any : never
| D extends any ? (x: D) => any : never

      ↓ 첫 번째 조건 평가 (항상 true)

  ((x: A) => any) | ((x: B) => any) | ((x: C) => any) | ((x: D) => any)

      ↓ 두 번째 조건: infer R (반변 위치)

  함수 매개변수 위치에서 추론
  → 계약을 이행하려면 모든 타입을 처리해야 함
  → 인터섹션 생성

결과:
  A & B & C & D
```

---

### 실제 사용 예시

```ts
type Intersected = UnionToIntersection<Video['urls']>;
/*
{
  format320p: URL;
  format480p: URL;
  format720p: URL;
  format1080p: URL;
}
*/

type FormatKeys = keyof UnionToIntersection<Video['urls']>;
// "format320p" | "format480p" | "format720p" | "format1080p"
```

기존 유니온에 새 형식을 추가하면 `FormatKeys`는 자동으로 갱신된다. 한 곳에서만 유지보수하고 모든 곳에서 사용한다.

## 8.8 type-fest 사용하기

**문제** 지금까지 얻은 여러 헬퍼 형식을 쉽게 사용할 수 있도록 유틸리티 라이브러리를 만들려 한다.

**해결** 필요한 모든 기능을 type-fest에서 이미 제공할 것이다.

**논의** 이 장에서는 표준 타입스크립트에서 제공하지 않는 유용한 몇 가지 헬퍼 형식을 소개하면서 다양한 시나리오에서 얼마나 유연하게 이들을 사용할 수 있는지 살펴봤다.

### type-fest의 특징

1. **광범위한 문서화**: 특정 헬퍼 형식의 사용법에서 시작해 사용 사례와 시나리오도 제공한다.

2. **경계 상황 처리**: 예를 들어 `PartialDeep<T>`은 `Map`, `Set`, `ReadonlyMap`, `ReadonlySet`, 배열 등 모든 경계 상황을 다룬다.

3. **거절된 형식 목록과 이유 제공**: 사용 사례가 제한적이거나 더 좋은 대안이 있을 때 형식 추가를 거절한다.

4. **기존 헬퍼 형식 학습 기회**: 타입스크립트의 내장 헬퍼 형식에 대한 예제와 사용 방법도 제공한다.

5. **활발한 유지보수**: 많은 사람이 사용하며 오픈 소스 개발자들 덕에 안정적으로 개발이 진행 중이다.

### Integer<T> 예시

```ts
/**
 * A `number` that is an integer.
 * You can't pass a `bigint` as they are already guaranteed to be integers.
 * Use-case: Validating and documenting parameters.
 *
 * @example
 * import type {Integer} from 'type-fest';
 * declare function setYear<T extends number>(length: Integer<T>): void;
 *
 * @see NegativeInteger
 * @see NonNegativeInteger
 * @category Numeric
 */
export type Integer<T extends number> = `${T}` extends `${bigint}` ? T : never;
```

### 사용 권장 사항

- 프로젝트의 특성에 따라 8.2절의 단순한 `DeepPartial` 버전을 사용하는 편이 좋을 수도 있다
- 복잡한 형식은 타입스크립트 형식 검사기에 부담을 줄 수 있다
- 작은 집합의 헬퍼 형식을 사용할지 아니면 커뮤니티가 구현하는 라이브러리를 사용할지는 프로젝트 요구사항에 따라 결정한다

type-fest 덕분에 프로젝트에 추가할 헬퍼 형식 리소스를 한 개 더 확보했다!
