CHAPTER 1
프 로 젝 트 설 정
타 입 스 크 립 트 p e s c r i p 를 배 워 보 기 로 한 결 정 을 환 영 한 다 ! 어 떻 게 공 부 를 시 작 해 야 할 까 ? 프 로 젝
트 의 상 황 에 맞 는 다 양 한 방 법 으 로 타 입 스 크 립 트 를 여 러 프 로 젝 트 에 활 용 할 수 있 다 . 자 바 스 크
립 트 를 다 양 한 런 타 임 으 로 실 행 할 수 있 듯 이 , 타 입 스 크 립 트 도 상 황 에 따 라 다 양 한 방 법 으 로 설
정 할 수 있 다 .
이 장 에 서 는 프 로 젝 트 에 타 입 스 크 립 트 를 활 용 하 는 다 양 한 방 법 을 소 개 한 다 . 타 입 스 크 립 트 는
자 바 스 크 립 트 의 확 장 으 로 기 본 적 인 자 동 완 성 , 오 류 검 출 기 능 을 포 함 해 N o d e . j s 와 브 라 우 저
에 서 동 작 하 는 풀 스 택 애 플 리 케 이 션 을 구 성 할 수 있 다 .
자 바 스 크 립 트 도 구 는 끊 임 없 이 발 전 하 고 있 다 . 심 지 어 매 주 새 로 운 자 바 스 크 립 트 빌 드 체 인 과
새 로 운 프 레 임 워 크 가 나 오 는 듯 하 다 고 말 하 는 이 도 있 다 . 이 장 에 서 는 추 가 도 구 없 이 순 수 하
게 타 입 스 크 립 트 컴 파 일 러 로 수 행 할 수 있 는 작 업 을 살 펴 본 다 .
타 입 스 크 립 트 는 트 랜 스 파 일 레 이 션 ( r a m p i l a t o n 에 필 요 한 모 든 것 을 제 공 한 다 . 단 , 웹 배 포 시 사
용 하 는 간 소 화 , 최 적 화 기 능 은 포 함 하 지 않 는 다 . 대 신 E S B u i l d ( h t t p s : / / e s b u i l d . g i t h u b . i o )
나 웹 팩 w c b p i c k ( h t t p s : / / w e b p a c k . j s . o r g ) 등 으 로 간 소 화 , 최 적 화 기 능 을 처 리 할 수 있 다 . 또 는
B a b e l . j s ( h t t p s : / / b a b e l j s . i o ) 처 럼 타 입 스 크 립 트 를 완 벽 하 게 지 원 하 는 다 른 트 랜 스 파 일 러 를
사 용 할 수 있 다 .
번 들 러 b u n d e r 나 기 타 트 랜 스 파 일 러 는 이 장 의 주 제 와 는 관 련 이 없 으 므 로 이 에 관 한 내 용 은 관 련
된 도 구 나 프 로 그 램 의 문 서 에 서 타 입 스 크 립 트 에 해 당 하 는 부 분 을 찾 아 보 기 바 란 다 .
1 장 프 로 젝 트 설 정 2 3
타 입 스 크 립 트 는 역 사 가 1 0 년 이 넘 는 프 로 젝 트 라 서 때 로 는 호 환 성 때 문 에 어 쩔 수 없 이 포 함 하
는 옛 기 능 들 이 존 재 한 다 . 이 장 에 서 는 최 신 자 바 스 크 립 트 문 법 과 웹 표 준 개 발 을 주 로 다 룬 다 .
안 타 깝 지 만 인 터 넷 익 스 플 로 러 m i e m e t E x p l o r e r 8 이 나 N o d e . j s 1 0 을 지 원 하 는 플 랫 폼 은 개 발 하 기
쉽 지 않 을 것 이 다 . 하 지 만 이 장 과 공 식 타 입 스 크 립 트 문 서 ( h t t p s : / / t y p e s c r i p t l a n g . o r g ) 어
담 긴 지 식 을 바 탕 으 로 예 전 플 랫 폼 에 도 적 용 할 수 있 는 부 분 이 많 다 .
1 . 1 자 바 스 크 립 트 형 식 검 사 하 기
문 제 최 소 한 의 노 력 으 로 자 바 스 크 립 트 에 형 식 검 사 기 능 을 추 가 하 려 한 다 .
해 결 형 식 검 사 를 하 려 는 모 든 자 바 스 크 립 트 파 일 의 가 장 윗 부 분 에 a t s - c h e c k 주 석 을 추 가
한 다 .
논 의 타 입 스 크 립 트 는 자 바 스 크 립 트 의 상 위 집 합 이 므 로 유 효 한 모 든 자 바 스 크 립 트 코 드 는 유
효 한 타 입 스 크 립 트 코 드 다 . 따 라 서 타 입 스 크 립 트 를 이 용 해 일 반 자 바 스 크 립 트 에 서 오 류 를 검
출 할 수 있 다 .
개 발 과 정 에 온 전 한 타 입 스 크 립 트 를 사 용 할 수 없 는 상 황 이 라 면 본 격 적 으 로 타 입 스 크 립 트 를
도 입 하 지 않 고 개 발 과 정 에 도 움 이 되 는 기 본 적 인 힌 트 와 형 식 확 인 만 이 용 할 수 도 있 다 .
이 를 활 용 하 려 면 자 바 스 크 립 트 형 식 확 인 오 류 를 제 공 할 좋 은 편 집 기 나 I D E 가 필 요 하 다 . 비 주
얼 스 튜 디 오 코 드 V i s u a l S t u d i o C o d e ( V S C o d e ) ( h t t p s : / / c o d e . v i s u a l s t u d i o . c o m ) 는 이 를 지 원 하 는
훌 륭 한 편 집 기 다 . 비 주 얼 스 튜 디 오 코 드 는 타 입 스 크 립 트 가 출 시 되 기 도 전 에 타 입 스 크 립 트 를
활 용 한 첫 주 요 프 로 젝 트 이 기 도 하 다
자 바 스 크 립 트 나 타 입 스 크 립 트 를 구 현 하 는 많 은 개 발 자 가 비 주 얼 스 튜 디 오 코 드 를 추 천 한 다 .
요 즘 에 는 타 입 스 크 립 트 를 지 원 하 는 편 집 기 가 많 은 데 , 타 입 스 크 립 트 를 지 원 한 다 면 어 떤 편 집 기
를 사 용 하 든 괜 찮 다 .
비 주 얼 스 튜 디 오 코 드 로 자 바 스 크 립 트 형 식 확 인 기 능 을 사 용 할 수 있 다 . [ 그 림 1 - 1 ] 에 서 볼 수
있 듯 이 , 비 주 얼 스 튜 디 오 코 드 는 형 식 관 련 오 류 를 꼬 불 거 리 는 물 결 선 으 로 표 시 한 다 . 이 는 형 식
확 인 의 가 장 기 본 기 능 이 다 . 타 입 스 크 립 트 의 형 식 시 스 템 은 다 양 한 수 준 의 엄 격 함 을 제 공 한 다 .
2 4 실 무 로 통 하 는 타 입 스 크 립 트
. . . hello.js - 01
is hello.js 1 X
js hello.js > ...
You, 9 months ago | 1 author (You)
1
2
//@ts-check
let a*number = 1000;
4
5
i f (Math. random() < 0.5) {
a number = "Hello, World!"
Type ' s t r i n g ' i s not assignable to type '
}
7
昭
8
console. log (a_number * 10);
9
1 0
1 1
1 2
function addVAT (price, vat = 0.2) €
return price _ (1 + vat)
1 3
1 4
1 5
1 6
//@ts-expect-error
addVAT (1000, "0.2")
1 7
1 8
⑧ //@ts-expect-error
1 9
2 0
addVAT (1000) . toUpperCase() You, 9 months ago • update
涼
% @ 1 0 & Live Share Ln 20, Col 2 7 Spaces: 2 UTF-8 LF () J a v a S c r i p t ?
그 림 1 - 1 코 드 편 집 기 에 나 타 난 물 결 선 . 코 드 에 오 류 가 있 을 때 보 여 지 는 기 본 기 능
ㅠ
우 선 형 식 시 스 템 은 자 바 스 크 립 트 코 드 에 서 변 수 의 사 용 방 법 에 따 라 형 식 을 유 추 한 다 . 다 음 과
같 은 코 드 가 있 다 고 가 정 하 자
let a_number = 1000;
타 입 스 크 립 트 는 a _ n u m b e r 의 형 식 을 n u m b e r 로 정 확 하 게 유 추 한 다 .
하 지 만 자 바 스 크 립 트 의 형 식 은 동 적 이 라 는 점 이 문 제 다 . L e t , v a r , c o n s t 로 바 인 딩 된 변 수 의
형 식 은 이 후 어 떻 게 사 용 하 느 냐 에 따 라 달 라 질 수 있 다 . ' 다 음 예 제 코 드 를 살 펴 보 자 .
let a _number = 1000;
if (Math. random() < 0.5) {
a number = "Hello, World!";
1 c o n s t 바 인 딩 으 로 할 당 된 객 체 라 도 값 과 프 로 퍼 티 를 바 꿀 수 있 으 므 로 객 체 의 형 식 은 언 제 든 바 뀔 수 있 다 .
1 장 프 로 젝 트 설 정 2 5
}
console. log(a_number \* 10);
a
_ n u m b e r 에 n u m b e r 를 할 당 한 다 음 에 i f 문 의 조 건 이 참 이 면 이 변 수 를 s t r i n g 으 로 다 시 바 인
딩 한 다 . 마 지 막 행 에 서 a _ n u m b e r 에 숫 자 를 곱 하 지 만 않 는 다 면 여 기 까 지 는 문 제 가 없 다 . 현 재
코 드 는 약 5 0 퍼 센 트 의 확 률 로 예 기 치 않 은 동 작 을 일 으 킨 다 .
타 입 스 크 립 트 로 이 문 제 를 간 단 히 해 결 할 수 있 다 . 자 바 스 크 립 트 파 일 의 제 일 윗 부 분 에 a t s -
C h e c k 라 는 주 석 을 추 가 하 면 해 당 자 바 스 크 립 트 파 일 에 타 입 스 크 립 트 의 형 식 검 사 가 적 용 된 다 .
이 예 제 에 서 타 입 스 크 립 트 는 기 존 에 n u m b e r 로 유 추 되 었 던 변 수 형 식 에 s t r i n g 을 다 시 바 인 딩
하 려 는 시 도 를 확 인 한 다 . 따 라 서 편 집 기 에 다 음 과 같 은 오 류 가 나 타 난 다 .
/ / @ts-check
l e t a_number = 1000;
if (Math. random () < 0.5) <
a_number = "Hello, World!";
1 / ^ - - ' s t r i n g ' 형 식 은 ' n u m b e r ' 형 식 에 당 할 수 없 습 니 다 . t s ( 2 3 2 2 )
}
console. log(a_number * 10);
이 제 타 입 스 크 립 트 가 알 려 주 는 대 로 코 드 오 류 를 고 칠 수 있 다 .
자 바 스 크 립 트 형 식 추 론 은 쉽 지 않 다 . 다 음 예 제 에 서 타 입 스 크 립 트 는 기 본 값 과 함 께 곱 셈 , 뺄
셈 등 의 연 산 으 로 형 식 을 유 추 한 다 .
function addVAT(price, vat = 0.2) {
return price * (1 + vat);
}
a d d V a t 함 수 는 두 인 수 를 받 는 다 . 두 번 째 인 수 에 는 기 본 값 0 . 2 가 존 재 하 므 로 이 인 수 는 선 택
형 이 다 . 형 식 에 맞 지 않 는 인 수 를 제 공 하 면 타 입 스 크 립 트 가 경 고 를 보 낸 다 .
2 6 실 무 로 통 하 는 타 입 스 크 립 트
addVAT (1000, "a string");
1 1
1 1
^ - - ' s t r i n g ' 형 식 의 인 수 는 ' n u m b e r ' 형 식 의
매 개 변 수 에 할 당 될 수 없 습 니 다 . t s ( 2 3 4 5 )
또 한 함 수 본 문 에 서 곱 셈 , 덧 셈 연 산 을 수 행 하 므 로 이 함 수 가 n u m b e r 를 반 환 한 다 는 사 실 도 추
론 한 다 .
addVAT (1000). toUpperCase();
1 / ^ - - ' n u m b e r ' 형 식 에 ' t o u p p e r C a s e ' 속 성 이 없 습 니 다 . t s ( 2 3 3 9 )
형 식 유 추 로 는 일 부 오 류 만 검 출 할 수 있 다 . 자 바 스 크 립 트 파 일 에 서 는 함 수 인 수 에 주 석 을 달
아 J S D o c 형 식 주 석 을 연 결 할 수 있 다 . J S D o c ( h t t p s : / / j s d o c . a p p ) 주 석 규 칙 을 이 용 하 면 변
수 와 함 수 인 터 페 이 스 를 사 람 이 쉽 게 읽 을 수 있 으 며 동 시 에 기 계 도 이 를 해 석 할 수 있 다 . 타 입
스 크 립 트 는 이 들 주 석 을 이 해 할 수 있 으 므 로 형 식 시 스 템 의 형 식 검 사 에 이 를 활 용 한 다 .
/\** @type {number} */
let amount;
amount = 12' ;
1 1 ^
_ - ' s t r i n g ' 형 식 의 인 수 는 ' n u m b e r ' 형 식 의
매 개 변 수 에 할 당 될 수 없 습 니 다 . t s ( 2 3 4 5 )
1 \* \*

-
- Adds VAT to a price
- aparam {number} price The price without VAT
- aparam {number} vat The VAT [0-1]
-
- @returns {number}
- /
  function addVAT(price, vat = 0.2) {
  return price _ (1 + vat);
  }
  J S D o c 으 로 객 체 에 사 용 할 새 롭 고 복 잡 한 형 식 도 정 의 할 수 있 다 .
  1 장 프 로 젝 트 설 정 2 7
  1 _ \*
- @typedef {Object} Article
- @property {number) price
- @property {number} vat
- aproperty {string} string
- @property {boolean=} sold
- /
  1 \* \*
- 이 제 A r t i c l e 을 형 식 으 로 사 용 할 수 있 다 .
- @param {[Article]} articles
- /
  function totalAmount(articles) {
  return articles. reduce(total, article)= › {
  return total + addVAT(article);
  }, 0);
  }
  이 문 법 이 조 금 복 잡 해 보 일 수 있 다 . 1 . 3 절 에 서 는 객 체 에 주 석 을 추 가 하 는 더 좋 은 방 법 을 소
  개 한 다 .
  J S D o c 으 로 문 서 화 된 자 바 스 크 립 트 코 드 가 있 다 면 파 일 의 제 일 윗 부 분 에 한 행 을 추 가 하 여 코
  드 에 존 재 하 는 오 류 를 쉽 게 파 악 할 수 있 다 .
  1 . 2 타 입 스 크 립 트 설 치 하 기
  문 제 편 집 기 에 서 제 공 하 는 물 결 선 이 만 능 해 결 사 는 아 니 다 . 명 령 줄 피 드 백 , 상 태 코 드 , 설 정 , 자 바 스 크 립
  트 형 식 확 인 과 타 입 스 크 립 트 컴 파 일 옵 션 등 이 필 요 하 다 .
  해 결 노 드 N o d e 의 주 요 패 키 지 등 록 장 소 인 N P M ( h t t p s : / / n p m j s . c o m ) 에 서 타 입 스 크 립 트 를 설
  치 한 다 .
  논 의 타 입 스 크 립 트 로 구 현 된 코 드 는 자 바 스 크 립 트 로 컴 파 일 한 다 음 자 바 스 크 립 트 런 타 임
  ( h t t p s : / / n o d e j s . o r g ) 인 N o d e j s 를 주 요 실 행 환 경 으 로 운 영 한 다 . ? N o d e . j s 앱 을 구 현 하 는
  2 타 입 스 크 립 트 는 디 노 ( d e n o ) 브 라 우 저 등 다 양 한 자 바 스 크 립 트 런 타 임 에 서 도 동 작 하 지 만 이 들 이 주 요 실 행 대 상 은 아 니 다 .
  2 8 실 무 로 통 하 는 타 입 스 크 립 트
  상 황 이 아 니 더 라 도 자 바 스 크 립 트 애 플 리 케 이 션 의 도 구 는 노 드 에 서 실 행 된 다 . 따 라 서 노 드 공
  식 웹 사 이 트 ( h t t p s : / / n o d e j s . o r g ) 에 서 N o d e . j s 를 내 려 받 아 명 령 행 도 구 에 익 숙 해 지 도 록 노 력
  하 자 .
  새 프 로 젝 트 를 만 들 려 면 프 로 젝 트 폴 더 를 새 로 운 p a c k a g e . j s o n 으 로 초 기 화 해 야 한 다 . 이 파
  일 은 노 드 와 노 드 의 패 키 지 관 리 자 N P M 이 프 로 젝 트 의 콘 텐 츠 를 이 해 하 는 데 필 요 한 모 든 정
  보 를 포 함 한 다 . 다 음 처 럼 N P M 명 령 행 도 구 로 프 로 젝 트 폴 더 에 기 본 적 인 p a c k a g e . j s o n 파 일
  을 만 든 다 .
  $ npm init -y
  노 트 이 책 에 서 는 터 미 널 에 서 실 행 할 수 있 는 다 양 한 명 령 을 소 개 한 다 . 편 의 상 이 들 명 령 어 를 B A S H 또 는 리
  눅 스 , 맥 O S , 리 눅 스 용 윈 도 우 하 위 시 스 템 M i n d o w s S u b s y s t e m f o r L i n u x ( W S L ) 에 서 사 용 할 수 있 는 셸 에 서 나 타 나 는
  그 대 로 표 시 한 다 . 맨 앞 의 기 호 는 명 령 어 의 시 작 을 가 리 키 는 기 호 이 며 명 령 의 일 부 가 아 니 다 . 이 책 에 서 소 개 하
  는 모 든 명 령 은 파 워 셀 P o w e r S i h a l 을 포 함 한 일 반 윈 도 우 명 령 프 롬 프 트 에 서 도 동 작 한 다 .
  N P M 은 노 드 의 패 키 지 관 리 자 다 . N P M 은 C L l , 레 지 스 트 리 , 의 존 성 을 설 치 하 는 데 필 요 한 다
  양 한 도 구 를 포 함 한 다 . p a c k a g e . j s o n 을 설 치 했 다 면 N P M 으 로 타 입 스 크 립 트 를 설 치 한 다 . 예
  제 에 서 는 타 입 스 크 립 트 를 개 발 d c v d o p m e n 의 존 성 으 로 추 가 하 는 데 , 이 는 프 로 젝 트 를 N P M 의 라
  이 브 러 리 로 배 포 할 때 타 입 스 크 립 트 를 포 함 하 지 않 는 다 는 의 미 다 .
  $ npm install -D typescript
  타 입 스 크 립 트 를 전 역 으 로 설 치 하 면 매 번 타 입 스 크 립 트 컴 파 일 러 를 설 치 할 필 요 가 없 다 . 하 지
  만 프 로 젝 트 별 로 타 입 스 크 립 트 를 설 치 하 기 를 권 장 한 다 . 프 로 젝 트 를 얼 마 나 자 주 갱 신 하 느 냐 에
  따 라 프 로 젝 트 코 드 가 사 용 하 는 타 입 스 크 립 트 버 전 이 달 라 질 수 있 다 . 타 입 스 크 립 트 를 전 역 으
  로 설 치 하 거 나 업 데 이 트 한 다 면 기 존 프 로 젝 트 의 코 드 가 동 작 하 지 않 을 수 있 다 .
  1 장 프 로 젝 트 설 정 2 9
  노 트 N P M 으 로 프 런 트 엔 드 의 존 성 을 설 치 했 다 면 브 라 우 저 에 서 코 드 를 실 행 하 는 데 필 요 한 추 가 도 구 인 번
  들 러 를 설 치 해 야 한 다 . 타 입 스 크 립 트 는 모 듈 시 스 템 을 지 원 하 는 번 들 러 를 포 함 하 지 않 으 므 로 적 절 한 도 구 를 설
  치 해 야 한 다 . 웹 팩 ( h t t p s : / / w e b p a c k . j s . o r g ) . E S B u i l d ( h t t p s : / / e s b u i l d . g i t h u b . 1 o ) 등 의 도 구 를 흔 히 사 용 한
  다 . 모 든 도 구 는 타 입 스 크 립 트 도 실 행 할 수 있 다 . 또 는 1 . 8 절 에 서 설 명 하 듯 이 완 전 한 네 이 티 브 의 길 로 갈 수 도
  있 다 .
  타 입 스 크 립 트 를 설 치 했 고 , 새 타 입 스 크 립 트 프 로 젝 트 도 초 기 화 했 다 . N P X 는 프 로 젝 트 의 상 대
  경 로 에 설 치 된 명 령 행 유 틸 리 티 를 실 행 하 게 해 주 는 도 구 다 . 다 음 처 럼 N P X 를 사 용 한 다 .
  $ npx tsc --init
  프 로 젝 트 의 지 역 버 전 타 입 스 크 립 트 컴 파 일 러 를 실 행 하 면 서 새 t s c o n f i g . j s o n 을 만 들 도 록
  i n i t 플 래 그 를 전 달 한 다 .
  t s c o n f i g . j s o n 은 타 입 스 크 립 트 프 로 젝 트 의 핵 심 설 정 파 일 이 다 . 타 입 스 크 립 트 가 코 드 를 어
  떻 게 해 석 하 고 , 어 떻 게 의 존 성 에 형 식 을 제 공 하 며 , 어 떤 기 능 을 켜 고 끌 지 를 이 파 일 로 설 정 한 다 .
  다 음 은 타 입 스 크 립 트 가 기 본 으 로 설 정 하 는 옵 션 이 다 .
  {
  "compilerOptions" : {
  "target" : "es2016"
  "module": "commonjs", "esModuleInterop": true,
  "forceConsistentCasingInFileNames": true,
  "strict": true,
  "skipLibCheck": true
  }
  }
  이 파 일 을 자 세 히 살 펴 보 자
  t a r g e t 은 e s 2 0 1 6 으 로 , 프 로 젝 트 의 타 입 스 크 립 트 파 일 을 E C M A S c r i p t 2 0 1 6 문 법
  ( E C M A S c r i p t 배 포 연 도 를 E C M A S c r i p t 버 전 으 로 사 용 함 ) 으 로 컴 파 일 한 다 . 현 재 사 용 하 는
  브 라 우 저 나 작 업 환 경 에 따 라 더 최 신 버 전 이 나 e s 5 같 은 예 전 버 전 을 t a r g e t 으 로 설 정 할 수
  있 다 .
  3 0 실 무 로 통 하 는 타 입 스 크 립 트
  m o d u l e 은 c o m m o n j s 다 . 이 옵 션 을 이 용 하 면 E C M A S c r i p t 모 듈 문 법 을 사 용 할 수 있 다 . 하 지
  만 이 문 법 을 출 력 으 로 전 달 하 는 방 식 이 아 니 라 타 입 스 크 립 트 가 모 듈 문 법 을 C o m m o n j S 형
  식 으 로 컴 파 일 한 다 . 다 음 과 같 은 코 드 가 있 다 고 가 정 하 자 .
  import { name } from " /my-module";
  console. Log (name);
  /...
  이 코 드 를 컴 파 일 하 면 다 음 처 럼 바 뀐 다 .
  const my\*module_1 = require("-/my-module");
  console. log my_module_1.name);
  C o m m o n j s 는 N o d e . j s 의 모 듈 시 스 템 인 데 노 드 가 인 기 를 끌 면 서 동 시 에 유 명 해 졌 다 . N o d e .
  j s 는 E C M A S c r i p t 모 듈 도 지 원 하 는 데 이 는 1 . 9 절 에 서 살 펴 본 다 .
  e s M o d u l e I n t e r o p 은 E C M A S c r i p t 모 듈 이 외 의 임 포 트 된 모 듈 들 의 표 준 을 일 치 시 킨 다 .
  f o r c e C o n s i s t e n t C a s i n g I n F i l e N a m e s 는 대 소 문 자 를 구 별 하 는 파 일 시 스 템 지 원 하 는 옵 션 이
  다 . S k i p L i b C h e c k 는 오 류 가 없 는 형 식 정 의 파 일 ( 뒤 에 서 자 세 히 설 명 함 ) 들 을 설 치 했 다 고 가
  정 한 다 . 따 라 서 컴 파 일 러 가 형 식 정 의 파 일 을 다 시 검 사 하 지 않 으 므 로 컴 파 일 러 동 작 속 도 를
  조 금 높 일 수 있 다 .
  가 장 흥 미 로 운 기 능 은 엄 격 o t i d 모 드 다 . 이 옵 션 을 t r u e 로 설 정 하 면 타 입 스 크 립 트 가 일 부 영 역
  에 서 조 금 다 르 게 동 작 한 다 . 타 입 스 크 립 트 팀 은 이 를 이 용 해 자 신 들 의 형 식 시 스 템 이 어 떤 모
  습 이 어 야 할 지 를 정 의 한 다 .
  형 식 시 스 템 의 뷰 가 바 뀌 면 서 타 입 스 크 립 트 가 이 전 코 드 와 호 환 되 지 않 는 새 기 능 을 추 가 하 는
  상 황 이 라 면 엄 격 모 드 로 추 가 된 다 . 즉 , 타 입 스 크 립 트 를 업 데 이 트 하 면 서 엄 격 모 드 를 적 용 한 다
  면 어 느 순 간 코 드 가 동 작 하 지 않 을 수 있 다 .
  이 러 한 변 화 를 적 용 할 시 간 이 필 요 함 을 감 안 해 타 입 스 크 립 트 는 엄 격 모 드 안 에 서 기 능 별 로 엄
  격 모 드 를 켜 거 나 끌 수 있 도 록 허 용 한 다 .
  기 본 설 정 외 에 다 음 두 가 지 설 정 을 추 가 하 기 를 권 장 한 다 .
  1 장 프 로 젝 트 설 정 3 1
  {
  "compilerOptions": {
  . ١١٠٠
  "rootDir": "'/src",
  "outDir": "/dist"
  }
  }
  이 설 정 은 타 입 스 크 립 트 가 S r c 폴 더 에 서 소 스 파 일 을 수 집 하 고 컴 파 일 된 파 일 을 d i s t 폴 더 에
  저 장 하 도 록 지 시 한 다 . 이 설 정 을 이 용 하 면 구 현 코 드 와 빌 드 된 파 일 을 다 른 장 소 에 분 리 저 장
  할 수 있 다 . s r c 폴 더 는 직 접 만 들 어 야 하 지 만 d i s t 폴 더 는 컴 파 일 시 자 동 으 로 만 들 어 진 다 .
  이 제 설 정 이 끝 났 다 . 프 로 젝 트 설 정 을 마 쳤 으 므 로 S r c 폴 더 에 다 음 내 용 을 포 함 하 는 i n d e x . t s
  파 일 을 만 들 어 보 자 .
  console. log("Hello World");
  • t s 확 장 자 는 타 입 스 크 립 트 파 일 을 가 리 킨 다 . 다 음 처 럼 파 일 을 실 행 한 다 .
  $ npx tsc
  터 미 널 에 서 이 명 령 을 실 행 하 면 서 컴 파 일 러 가 제 대 로 동 작 하 는 지 확 인 한 다 .
  1 . 3 형 식 을 나 란 히 유 지 하 기
  문 제 일 반 적 인 자 바 스 크 립 트 코 드 로 구 현 한 함 수 의 형 식 정 보 를 편 집 기 가 적 절 하 게 보 여 주 었 으 면 한 다 .
  하 지 만 1 . 1 절 에 서 살 펴 본 것 처 럼 J S D o c 으 로 복 잡 한 객 체 형 식 을 정 의 하 고 싶 진 않 다 .
  해 결 형 식 정 의 파 일 을 옆 에 나 란 히 ' 둔 상 태 에 서 타 입 스 크 립 트 컴 파 일 러 를 자 바 스 크 립 트 확
  인 c e k J a v a r i p r 모 드 로 실 행 한 다 .
  3 2 실 무 로 통 하 는 타 입 스 크 립 트
  논 의 타 입 스 크 립 트 는 점 진 적 으 로 적 용 할 수 있 도 록 설 계 되 었 다 . ' 옆 에 나 란 히 ' 두 는 기 법 을 이
  용 해 타 입 스 크 립 트 문 법 으 로 제 네 릭 , 조 건 부 형 식 ( 5 장 에 서 설 명 ) 등 을 활 용 해 객 체 형 식 을 구
  현 할 수 있 으 므 로 복 잡 한 J S D o c 주 석 을 사 용 할 필 요 가 없 다 . 하 지 만 동 시 에 실 제 앱 은 자 바 스
  크 립 트 로 구 현 할 수 있 다 . 프 로 젝 트 에 서 적 당 한 위 치 ( e t y p e s 폴 더 추 천 ) 에 형 식 선 언 파 일 을
  만 든 다 . 이 파 일 은 • t s 로 끝 나 는 타 입 스 크 립 트 파 일 과 조 금 다 르 게 · d . t s 로 끝 난 다 . 이 파 일
  은 선 언 d e c h a r a t i o n 을 저 장 하 는 용 도 이 며 실 제 코 드 는 포 함 하 지 않 는 다 .
  이 파 일 에 인 터 페 이 스 , 형 식 별 칭 , 복 잡 한 형 식 을 구 현 할 수 있 다 .
  / / @types/person.d.ts
  1 / 다 음 과 같 은 모 양 을 갖 는 객 체 인 터 페 이 스
  export interface Person {
  name: string;
  age: number;
  }
  1 / 기 존 인 터 페 이 스 를 확 장 하 는 인 터 페 이 스
  1 / J S D o C 주 석 으 로 는 이 를 구 현 하 기 힘 들 다 .
  export interface Student extends Person {
  semester: number;
  }
  선 언 파 일 에 서 인 터 페 이 스 를 익 스 포 트 a p o n 했 다 는 사 실 을 주 목 하 자 . 자 바 스 크 립 트 파 일 에 서 임 포 트 m p o n 할 수 있 다 .
  익 스 포 트 한 인 터 페 이 스 를
  / / index.js
  /\*\* @typedef { import (". /@types/person").Person } Person \_/
  첫 행 의 주 석 은 타 입 스 크 립 트 가 a t y p e s / p e r s o n 에 서 P e r s o n 형 식 을 임 포 트 해 P e r s o n 이 라 는
  이 름 으 로 사 용 할 수 있 도 록 지 시 한 다 .
  마 치 s t r i n g 같 은 기 본 형 을 이 용 하 듯 이 이 식 별 자 로 함 수 매 개 변 수 나 객 체 에 주 석 을 추 가 할
  수 있 다 .
  1 장 프 로 젝 트 설 정 3 3
  1 / i n d e x . j s , 이 어 서
  / \* \*
-
- @param {Person person
  function printPerson(person) {
  console. log (person.name);
  }
  편 집 기 피 드 백 을 얻 으 려 면 1 . 1 절 에 서 설 명 했 듯 이 자 바 스 크 립 트 파 일 의 처 음 부 분 에 a t s -
  C h e c k 를 추 가 해 야 한 다 . 또 는 자 바 스 크 립 트 를 항 상 검 사 하 도 록 프 로 젝 트 를 설 정 한 다 .
  t s c o n f i g . j s o n 파 일 을 열 어 c h e c k J s 플 래 그 를 t r u e 로 설 정 한 다 . 이 제 편 집 기 는 s r c 폴 더
  의 모 든 자 바 스 크 립 트 파 일 을 읽 어 실 시 간 으 로 형 식 오 류 피 드 백 을 제 공 한 다 . 명 령 줄 에 서 n p x
  t s c 를 실 행 해 오 류 를 확 인 할 수 도 있 다 .
  다 음 처 럼 n o E m i t 을 t r u e 로 설 정 하 면 타 입 스 크 립 트 가 자 바 스 크 립 트 파 일 을 예 전 버 전 으 로 변
  환 하 지 않 도 록 한 다 .
  {
  "compilerOptions" : {
  "check]s": true,
  "noEmit": true,
  }
  }
  이 제 타 입 스 크 립 트 는 고 도 이 기 능 을 이 용 할 수 있 다 .
  소 스 파 일 을 읽 고 필 요 한 형 식 정 보 를 제 공 한 다 . 코 드 를 전 혀 바 꾸 지 않
  이 기 법 은 확 장 성 이 좋 다 . 프 리 액 트 P r e a c ( h t t p s : / / p r e a c t j s . o r g ) 같 은 유 명 한 자 바 스 크 립 트 라
  이 브 러 리 도 이 처 럼 동 작 하 며 사 용 자 와 기 여 자 모 두 에 게 훌 륭 한 도 구 를 제 공 한 다 .
  3 4 실 무 로 통 하 는 타 입 스 크 립 트
  1 . 4 프 로 젝 트 를 타 입 스 크 립 트 로 바 꾸 기
  문 제 타 입 스 크 립 트 의 모 든 장 점 을 프 로 젝 트 에 활 용 하 려 면 전 체 코 드 를 타 입 스 크 립 트 로 바 꿔 야 한 다 .
  해 결 모 듈 의 파 일 을 하 나 씩 . j s 에 서 t s 로 바 꾼 다 . 다 양 한 컴 파 일 러 옵 션 과 기 능 을 이 용 해
  이 후 발 생 하 는 오 류 를 해 결 한 다 .
  논 의 타 입 스 크 립 트 파 일 을 이 용 하 면 자 바 스 크 립 트 파 일 과 형 식 을 따 로 구 현 할 때 와 달 리 한
  파 일 에 모 두 포 함 할 수 있 으 므 로 편 집 기 지 원 이 향 상 되 며 , 더 다 양 한 타 입 스 크 립 트 기 능 을 이
  용 할 수 있 고 다 른 도 구 와 의 호 환 성 도 증 가 한 다 .
  하 지 만 파 일 확 장 자 를 . j s 에 서 . t s 로 바 꾸 는 순 간 많 은 오 류 가 발 생 하 므 로 확 장 자 변 경 으 로
  모 든 문 제 가 해 결 되 진 않 는 다 . 따 라 서 모 든 파 일 을 한 꺼 번 에 바 꾸 기 보 다 는 한 개 씩 바 꾸 면 서
  점 진 적 으 로 형 식 을 안 전 하 게 변 경 하 는 편 이 좋 다 .
  타 입 스 크 립 트 로 바 꾸 는 과 정 에 서 겪 는 가 장 큰 문 제 는 자 바 스 크 립 트 가 아 니 라 타 입 스 크 립 트
  프 로 젝 트 와 관 련 있 다 . 여 전 히 많 은 자 바 스 크 립 트 모 듈 을 사 용 해 야 하 는 데 이 모 듈 들 은 형 식
  정 보 를 제 공 하 지 않 으 므 로 형 식 검 사 단 계 에 서 오 류 가 발 생 한 다 .
  단 기 적 으 로 는 타 입 스 크 립 트 가 모 듈 을 불 러 오 고 자 바 스 크 립 트 파 일 을 참 조 하 지 만 자 바 스 크 립
  트 의 형 식 검 사 는 수 행 하 지 않 도 록 설 정 하 여 이 문 제 를 넘 어 갈 수 있 다 .
  {
  "compilerOptions": {
  "checkJs": false,
  "allows": true
  ~
  }
  이 제 n p x t s c 를 실 행 하 면 타 입 스 크 립 트 가 소 스 폴 더 에 저 장 된 모 든 자 바 스 크 립 트 와 타 입 스 크
  립 트 파 일 을 읽 은 다 음 , 대 상 폴 더 에 자 바 스 크 립 트 파 일 을 만 드 는 모 습 을 확 인 할 수 있 다 . 타 입
  스 크 립 트 는 지 정 된 대 상 버 전 과 호 환 되 도 록 코 드 를 변 환 한 다 .
  의 존 성 을 사 용 한 다 면 일 부 모 듈 이 형 식 정 보 를 제 공 하 지 않 을 수 있 다 . 이 때 는 다 음 처 럼 타 입
  스 크 립 트 오 류 가 발 생 한 다 .
  1 장 프 로 젝 트 설 정 3 5
  import \_ from "lodash";
  ^ - ' l o d a s h ' 모 듈 또 는 해 당 형 식 선 언 을 찾 을 수 없 습 니 다 . t s ( 2 3 0 7 )
  서 드 파 티 형 식 정 의 를 설 치 해 이 오 류 를 해 결 할 수 있 다 ( 1 . 5 절 참 고 ) .
  파 일 을 한 개 씩 변 환 하 다 보 면 한 파 일 에 서 발 생 하 는 모 든 형 식 문 제 를 해 결 할 수 없 을 때 도 있
  다 는 사 실 을 깨 닫 게 된 다 . 한 파 일 에 의 존 성 이 여 럿 일 수 있 으 므 로 한 문 제 를 해 결 하 려 면 여 러
  의 존 성 에 서 발 생 하 는 수 많 은 오 류 를 해 결 해 야 하 는 상 황 에 빠 진 다 .
  이 러 한 상 황 에 서 는 오 류 를 무 시 하 는 방 법 이 최 선 일 수 있 다 . 기 본 적 으 로 타 입 스 크 립 트 는
  n o E m i t O n E r r o r 를 f a l s e 로 설 정 한 다 .
  {
  "compilerOptions": {
  "noEmitOnError": f a l s e
  }
  }
  이 옵 션 을 f a l s e 로 설 정 하 면 프 로 젝 트 에 오 류 가 얼 마 나 있 든 지 관 계 없 이 타 입 스 크 립 트 는 결 과
  파 일 을 생 성 한 다 . 마 이 그 레 이 션 을 완 료 한 시 점 에 는 이 옵 션 을 다 시 켜 는 편 이 좋 다 .
  엄 격 모 드 에 서 타 입 스 크 립 트 의 n o I m p L i c i t A n y 플 래 그 는 t r u e 로 설 정 된 다 . 이 플 래 그 는 변 수 ,
  상 수 , 함 수 매 개 변 수 에 형 식 을 반 드 시 할 당 하 도 록 강 제 한 다 . 다 음 처 럼 a n y 를 사 용 할 수 있 다 .
  function printPerson(person: any) {
  1 / 말 이 되 지 않 는 코 드 지 만 a n y 로 컴 파 일 을 통 과 할 수 있 다 .
  console. log(person.gobbleydegook);
  }
  1 / 이 코 드 도 말 이 되 지 않 지 만 a n y 를 사 용 하 면 컴 파 일 은 통 과 한 다 .
  printPerson (123);
  a n y 는 모 든 형 식 을 허 용 한 다 . 모 든 값 은 a n y 와 호 환 되 므 로 a n y 는 모 든 프 로 퍼 티 에 접 근 하 고
  모 든 메 서 드 를 호 출 할 수 있 게 허 용 한 다 . 사 실 상 a n y 는 형 식 검 사 를 무 력 화 하 므 로 변 환 과 정 에
  서 이 를 적 절 하 게 활 용 하 면 숨 쉴 틈 을 만 들 수 있 다 .
  3 6 실 무 로 통 하 는 타 입 스 크 립 트
  a n y 가 아 닌 u n k n o w n 으 로 매 개 변 수 를 지 정 할 수 도 있 다 . 매 개 변 수 를 u n k n o w n 으 로 설 정 하 면
  함 수 에 모 든 것 을 전 달 할 수 있 지 만 형 식 을 파 악 하 기 전 까 지 는 이 변 수 로 아 무 일 도 할 수 없 다 .
  형 식 검 사 를 수 행 하 지 않 으 려 는 행 바 로 위 에 e t s - i g n o r e 주 석 을 추 가 하 면 형 식 검 사 오 류 를
  무 시 할 수 있 다 . 파 일 의 처 음 행 에 a t s - i g n o r e 주 석 을 추 가 하 면 해 당 모 듈 전 체 에 형 식 검 사
  를 수 행 하 지 않 는 다 .
  a t s - e x p e c t - e r r o r 는 변 환 과 정 에 서 매 우 유 용 하 게 사 용 할 수 있 는 주 석 지 시 어 다 . e t s -
  e x p e c t - e r r o r 는 a t s - i g n o r e 와 비 슷 하 지 만 형 식 검 사 과 정 에 서 발 생 하 는 오 류 를 생 략 하 며 ,
  형 식 오 류 가 발 생 하 지 않 으 면 빨 간 물 결 선 을 표 시 한 다 .
  변 환 과 정 에 서 이 를 적 절 하 게 활 용 하 면 타 입 스 크 립 트 로 변 환 한 부 분 을 파 악 하 는 데 도 움 이 된
  다 . Q t s - e x p e c t - e r r o r 지 시 어 를 추 가 한 곳 을 모 두 제 거 했 다 면 변 환 이 완 료 된 것 이 다 .
  function printPerson(person: Person) {
  console. log (person.name);
  }
  / / 다 음 오 류 는 생 략
  // @ts-expect-error
  printPerson (123);
  function printNumber(nr: number) {
  console. log(nr);
  }
  // v- Unused '@ts-expect-error' directive. ts (2578)
  / / @ts-expect-error
  printNumber (123);
  서 로 의 의 무 를 바 꾸 는 것 이 이 기 법 의 장 점 이 다 . 보 통 은 함 수 에 올 바 른 값 을 전 달 해 야 하 는 데 ,
  이 를 이 용 하 면 함 수 가 유 효 한 입 력 을 처 리 하 는 지 확 인 할 수 있 다 .
  변 환 과 정 에 서 오 류 를 없 애 는 방 식 에 한 가 지 공 통 점 이 있 다 . 명 시 적 으 로 설 정 했 다 는 점 이 다 .
  즉 , 명 시 적 으 로 a t s - e x p e c t - e r r o r 주 석 을 설 정 하 거 나 함 수 매 개 변 수 를 a n y 로 설 정 해 모 든
  파 일 의 형 식 검 사 를 무 시 하 도 록 설 정 했 다 . 이 렇 게 오 류 를 잠 시 없 애 서 변 환 과 정 에 서 당 장 은
  빠 져 나 갈 구 멍 을 만 들 수 있 으 며 나 중 에 모 든 오 류 를 제 거 했 는 지 확 인 할 수 있 다 .
  1 장 프 로 젝 트 설 정 3 7
  1 . 5 D e f i n i t e l y T y p e d 에 서 형 식 불 러 오 기
  문 제 타 입 스 크 립 트 로 구 현 되 지 않 은 의 존 성 을 사 용 하 는 데 이 의 존 성 은 형 식 을 제 공 하 지 않 는 다 .
  해 결 D e f i n i t e l y T y p e d ( h t t p s : / / o r e i l . L y / n 2 4 x 2 ) 에 서 커 뮤 니 티 가 유 지 보 수 하 는 형 식 정 의
  를 설 치 한 다 .
  논 의 D e f i n i t e l y T y p e d 는 매 우 크 고 활 동 적 인 깃 허 브 ( i h u ) 저 장 소 ( p o s t o n 로 , 커 뮤 니 티 가 가
  발 하 고 유 지 보 수 하 는 고 품 질 의 타 입 스 크 립 트 형 식 정 의 를 제 공 한 다 .
  현 재 1 0 , 0 0 0 개 정 도 의 형 식 정 의 가 있 으 며 거 의 모 든 자 바 스 크 립 트 라 이 브 러 리 가 있 다 .
  모 든 형 식 정 의 는 린 트 , 검 사 를 거 쳐 N o d e . j s 패 키 지 레 지 스 트 리 N P M 의 e t y p e s 네 임 스 페
  이 스 에 배 포 된 다 . [ 그 림 1 - 2 ] 처 럼 N P M 은 각 패 키 지 정 보 사 이 트 를 통 해 D e f i n i t e l y T y p e d
  정 의 를 사 용 할 수 있 는 지 를 보 여 준 다 .
  п р т
  Naphthalene Possum Management
  Search packages
  Pro Teams
  S e a r c h
  Pricing
  Sign Up
  Documentation
  Sign In
  react D T
  18.2.0 • Public • Published 10 months ago
  E Readme N C o d e • 1 Dependency 品 1 0 5 , 7 2 1 D e p e n d e n t s • 1,297 Versions
  r e a c t
  Install
  > npm i react
  > React is a JavaScript library for creating user
  > interfaces.
  > Repository

# github.com/facebook/react

The r e a c t package contains only the
functionality necessary to define React
components. It is typically used together with a
React renderer like react-dom for the web, or
Homepage © reactjs.org/

- Weekly Downloads
  2 0 , 9 2 1 , 5 7 5
  ..:...١
  그 림 1 - 2 N P M 의 r e a c t 사 이 트 는 패 키 지 명 옆 에 D T 로 고 를 보 여 준 다 . 이 는 D e f i n i t e l y T y p e d 형 식 정 의 를 시 용 할
  수 있 다 는 뜻 이 다 .
  3 8 실 무 로 통 하 는 타 입 스 크 립 트
  로 고 를 클 릭 하 면 형 식 정 의 를 제 공 하 는 사 이 트 로 이 동 한 다 . 퍼 스 트 파 티 형 식 정 의 를 제 공 하 는
  패 키 지 에 는 [ 그 림 1 - 3 ] 에 서 처 럼 패 키 지 명 옆 에 작 은 T S 로 고 가 나 타 난 다 .
  Nebulous Plasma Muffin
  Q Search packages
  Pro Teams Pricing Documentation
  S e a r c h sign Up sign in
  @types/react I t s
  18.2.0 • Public • Published 4 days ago
  Readme E Code Beta) 3 Dependencies 品 1 5 , 1 4 1 D e p e n d e n t s
  Installation Install
  npm i n s t a l l --save @types/react
  Summary
  This package contains type definitions for React
  (https://react.dev/).
  Details
  > 457 Versions
  > npm i @types/react
  > Repository
  > #github.com/DefinitelyTyped/D…..
  > Homepage © github.com/DefinitelyTyped/D...

* Weekly Downloads
  2 3 , 3 0 9 , 3 6 5
  그 림 1 - 3 D e f i n i t e l y T y p e d 에 서 제 공 하 는 리 액 트 형 식 정 의
  다 음 처 럼 유 명 한 자 바 스 크 립 트 프 레 임 워 크 리 액 트 의 형 식 을 포 함 하 는 e t y p e s / r e a c t 패 키 지 를
  여 러 분 의 지 역 의 존 성 으 로 설 치 할 수 있 다 .

# R e a c t 설 치

$ npm i n s t a l l --save react

# T y p e D e f i n i t i o n s 설 치

$ npm i n s t a l l --save-dev @types/react
노 트 이 예 제 에 서 는 애 플 리 케 이 션 을 개 발 하 는 과 정 에 의 존 성 을 사 용 하 며 컴 파 일 된 결 과 는 형 식 을 사 용 할 필
요 가 없 으 므 로 형 식 을 개 발 의 존 성 으 로 추 가 했 다 .
1 장 프 로 젝 트 설 정 3 9
기 본 적 으 로 타 입 스 크 립 트 는 프 로 젝 트 의 루 트 폴 더 로 부 터 상 대 경 로 인 a t y p e s 폴 더 에 저 장 된
형 식 정 의 를 이 용 한 다 . 타 입 스 크 립 트 는 n o d e _ m o d u L e s / e t y p e s 에 저 장 된 모 든 형 식 정 의 도 사
용 한 다 . 이 는 a t y p e s / r e a c t 같 은 N P M 설 치 물 을 저 장 하 는 폴 더 다 .
타 입 스 크 립 트 가 이 렇 게 동 작 하 는 이 유 는 t s C o n f i g . j s o n 의 t y p e R o o t s 컴 파 일 러 옵 션 이 0
t y p e s 와 . / n o d e _ m o d u l e s / a t y p e s 로 설 정 되 었 기 때 문 이 다 . 이 D e f i n i t e l y T y p e d 의 형 식 정
의 를 사 용 하 려 고 이 설 정 을 덮 어 쓸 때 는 기 존 폴 더 를 포 함 해 야 한 다 .
{
"compilerOptions": {
"typeRoots": [
"./typings",
" /node_modules/@types"
]
}
}
형 식 정 의 를 n o d e _ m o d u l e s / e t y p e s 로 설 치 하 면 타 입 스 크 립 트 가 컴 파 일 시 자 동 으 로 이 를 불
러 온 다 . 이 는 전 역 으 로 선 언 하 는 형 식 이 있 다 면 타 입 스 크 립 트 가 이 를 모 두 사 용 한 다 는 의 미 다 .
다 음 은 원 하 는 패 키 지 만 전 역 으 로 선 언 하 도 록 허 용 하 는 컴 파 일 러 옵 션 t y p e s 를 사 용 하 는 예 다 .
{
"compilerOptions": {
"types": [
"node",
"jest"
]
}
}
이 설 정 은 전 역 설 정 에 만 영 향 을 미 친 다 . i m p o r t 문 으 로 노 드 모 듈 을 불 러 오 면 타 입 스 크 립 트
는 @ t y p e s 에 서 올 바 른 형 식 을 불 러 온 다 .
1 / a t y p e s / L o d a s h 가 설 치 되 어 있 으 면 이 N P M 패 키 지 로 부 터
/ / 적 절 한 형 식 정 의 를 얻 는 다 .
import _ from "lodash"
4 0 실 무 로 통 하 는 타 입 스 크 립 트
const result = _.flattenDeep([1, [2, [3, [4]], 5]1);
1 . 7 절 에 서 이 설 정 을 다 시 살 펴 본 다 .
1 . 6 풀 스 택 프 로 젝 트 설 정 하 기
문 제 공 유 된 의 존 성 을 이 용 해 N o d e j s 와 브 라 우 저 를 대 상 으 로 삼 는 풀 스 택 애 플 리 케 이 션 을 구 현 하 려 한 다 .
해 결 프 런 트 엔 드 , 백 엔 드 용 t s c o n f i g 파 일 을 각 각 만 들 고 c o m p o s i t e 로 공 유 된 의 존 성 을 불
러 온 다 .
논 의 N o d e . j s 와 브 라 우 저 모 두 자 바 스 크 립 트 를 실 행 하 지 만 , 개 발 자 가 환 경 에 서 수 행 할 것 으
로 기 대 하 는 바 가 크 게 다 르 다 . N o d e . j s 는 서 버 , 명 령 줄 도 구 , U I 없 이 실 행 되 는 u - h e d l e s 환 경
을 예 상 한 다 . 또 한 자 체 A P I 집 합 과 표 준 라 이 브 러 리 를 제 공 한 다 . 다 음 과 같 은 간 단 한 스 크 립
트 로 H T T P 서 버 를 시 작 할 수 있 다 .
const http = require('http'); •
const hostname = '127.0.0.1';
const port = process.env.PORT | | 3 0 0 0 ;
const server = http.createServer((req, res) => {
res.statusCode = 200;
res. setHeader ('Content-Type', 'text/plain');
res.end 'Hello World');
} ) ;
server. listen(port, hostname, () → {
console. log(*Server running at http://${hostname}:${port}/*); ®
});
이 코 드 는 자 바 스 크 립 트 이 며 구 체 적 으 로 는 N o d e . j s 코 드 다 .
1 장 프 로 젝 트 설 정 4 1
1 ' h t t p ' 는 H T T P 와 관 련 된 N o d e . j s 모 듈 의 내 장 기 능 이 다 . r e q u i r e 로 이 모 듈 을 불 러 올 수 있 는 데
r e q u i r e 를 통 해 C o m m o n J S 라 불 리 는 노 드 의 모 듈 시 스 템 의 일 부 임 을 알 수 있 다 . 1 . 9 절 에 서 살 펴 본
것 처 럼 N o d e j s 에 서 는 다 양 한 방 법 으 로 모 듈 을 로 드 할 수 있 다 . 하 지 만 요 즘 은 C o m m o n J S 를 가 장 보
편 적 으 로 사 용 한 다 .
② p r o c e s s 는 현 재 N o d e s . j s 를 실 행 하 는 프 로 세 스 의 환 경 변 수 정 보 를 포 함 하 는 전 역 객 체 다 . 이 또 한
N o d e . j s 전 용 기 능 이 다 .
③ 거 의 모 든 자 바 스 크 립 트 런 타 임 이 c o n s o l e 관 련 함 수 를 제 공 한 다 . 하 지 만 N o d e . j s 에 서 는 브 라 우 저 와 다
르 게 동 작 한 다 . 노 드 에 서 는 표 준 출 력 S T D O U T 으 로 메 시 지 를 출 력 하 지 만 브 라 우 저 에 서 는 개 발 도 구 로 행 을
출 력 한 다 .
N o d e . j s 전 용 A P I 도 많 다 . 하 지 만 이 는 브 라 우 저 의 자 바 스 크 립 트 도 마 찬 가 지 다 .
import { msg } from ' ./msg.js; 0
document. querySelector ('button')?.addEventListener ("click", () → { @
console. log(msg); ®
} ) ;
① E C M A S c r i p t 모 듈 은 수 년 간 모 듈 을 불 러 오 는 방 법 을 따 로 찾 지 못 했 으 나 마 침 내 자 바 스 크 립 트 와 브 라
우 저 로 불 러 오 는 방 법 을 찾 았 다 . 이 행 은 다 른 자 바 스 크 립 트 모 듈 에 서 객 체 를 불 러 오 는 코 드 다 . 이 코 드
는 브 라 우 저 에 서 네 이 티 브 로 구 동 되 며 N o d e j s 의 두 번 째 모 듈 시 스 템 이 다 ( 1 . 9 절 참 고 ) .
② 브 라 우 저 의 자 바 스 크 립 트 는 U I 이 벤 트 와 상 호 작 용 하 도 록 만 들 어 졌 다 . D o c u m e n t 객 체 와 문 서 객 체 모 델
D o c u m e n t O g l e c i M o d e ( D O M ) 의 요 소 를 가 리 키 는 q u e r y S e l e c t o r 개 념 은 브 라 우 저 에 만 존 재 한 다 . 예 를 들
어 " c L i c k " 이 벤 트 를 리 스 닝 하 도 록 이 벤 트 리 스 너 를 추 가 할 수 있 다 . N o d e j s 에 는 이 런 개 념 이 없 다 .
③ 다 시 c o n s o l e 이 나 왔 다 . N o d e j s 와 A P I 는 같 지 만 실 행 결 과 는 조 금 다 르 다 .
둘 은 서 로 다 른 점 이 많 아 서 한 타 입 스 크 립 트 프 로 젝 트 로 모 두 를 지 원 하 기 는 어 렵 다 . 풀 스 택
애 플 리 케 이 션 을 구 현 하 려 면 각 스 택 을 처 리 하 는 두 가 지 타 입 스 크 립 트 설 정 파 일 을 만 들 어 야
한 다 .
먼 저 백 엔 드 를 살 펴 보 자 . N o d e . j s 로 E x p r e s s . j s 서 버 ( 익 스 프 레 스 B p c s 는 노 드 의 유 명 한 서 버
프 레 임 워 크 다 ) 를 만 든 다 고 가 정 하 자 . 1 . 1 절 에 서 살 펴 봤 듯 이 먼 저 새 N P M 프 로 젝 트 를 만 든
다 음 익 스 프 레 스 를 의 존 성 으 로 설 치 한 다 .
$ npm i n s t a l l --save express
4 2 실 무 로 통 하 는 타 입 스 크 립 트
D e f i n i t e l y T y p e d 에 서 N o d e . j s 와 익 스 프 레 스 형 식 정 의 를 설 치 한 다 .
$ npm i n s t a l l -D @types/express @types/node
s e r v e r 라 는 새 폴 더 를 만 든 다 . N o d e . j s 코 드 를 여 기 에 저 장 한 다 . t s c 로 새 t s c o n f i g . j s o n
파 일 을 만 들 지 않 고 프 로 젝 트 의 s e r v e r 폴 더 에 새 t s c o n f i g . j s o n 파 일 을 직 접 만 든 다 . 다 음
은 t s c o n f i g . j s o n 파 일 내 용 이 다 .
/ / server/sconfig. json
{
"compilerOptions": {
"target": "ESNext",
"lib": [
"ESNext"
"module": "commonjs",
"rootDir": "./", "moduleResolution": "node",
"types": [
"node"
"outDir": "…/dist/server", "esModuleInterop": true,
"forceConsistentCasinaInFileNames": true,
"strict": true,
"skipLibCheck": true
}
이 제 대 부 분 설 정 이 무 엇 을 의 미 하 는 지 이 해 할 수 있 을 것 이 다 . 그 중 에 서 몇 가 지 만 살 펴 보 자 .
• m o d u l e 프 로 퍼 티 를 c o m m o n j s ( 즉 , 원 래 N o d e j s 모 듈 시 스 템 ) 으 로 설 정 한 다 . 모 든 i m p o r t , e x p o r t 구
문 은 각 각 대 응 하 는 C o m m o n J S 코 드 로 변 환 된 다 .
• t y p e s 프 로 퍼 티 를 [ " n o d e " ] 로 설 정 한 다 . 이 프 로 퍼 티 는 전 역 으 로 이 용 하 려 는 모 든 라 이 브 러 리 를 포 함 한
다 . " n o d e " 를 전 역 으 로 포 함 하 면 , 전 역 으 로 제 공 되 는 r e q u i r e , p r o c e s s 및 기 타 N o d e j s 전 용 형 식 정
보 를 얻 게 된 다 .
1 장 프 로 젝 트 설 정 4 3
다 음 처 럼 서 버 코 드 를 컴 파 일 한 다 .
$ npx tsc -p server/sconfig. json
클 라 이 언 트 설 정 파 일 을 살 펴 보 자 .
/ / client/tsconfig.json
{
"compilerOptions": {
"target": "ESNext",
"lib": [
"DOM",
"ESNext"
] ,
"module": "ESNext",
"rootDir": "./",
"moduleResolution": "node",
"types": [],
"outDir": "/dist/client",
"esModuleInterop": true, "forceConsistentCasingInFileNames": true,
"strict": true,
"skipLibCheck": true
}
}
이 전 설 정 파 일 과 비 슷 한 데 그 중 몇 가 지 옵 션 만 살 펴 보 자 .
• D O M 을 L i b 프 로 퍼 티 에 추 가 했 다 . 브 라 우 저 와 관 련 된 모 든 형 식 정 의 를 이 용 한 다 는 의 미 다 . D e f i n i t e l y
T y p e d 를 통 해 N o d e j s 형 식 을 설 치 할 때 타 입 스 크 립 트 는 컴 파 일 러 의 브 라 우 저 에 제 공 되 는 가 장 최 신
형 식 정 의 를 가 져 온 다 .
• t y p e s 배 열 은 비 었 다 . 따 라 서 전 역 형 식 에 서 " n o d e " 를 제 거 한 다 . p a c k a g e . j s o n 파 일 별 로 형 식 정 의 를
설 치 할 수 있 으 므 로 기 존 에 설 치 한 " n o d e " 형 식 은 전 체 코 드 에 서 사 용 할 수 있 게 된 다 . 하 지 만 c L i e n t 에
서 는 이 정 의 가 필 요 없 으 므 로 삭 제 한 다 .
다 음 처 럼 프 런 트 엔 드 를 컴 파 일 한 다 .
$ npx tsc -p client/tsconfig. json
4 4 실 무 로 통 하 는 타 입 스 크 립 트
두 가 지 다 른 t s c o n f i g . j s o n 파 일 을 만 들 었 다 . 비 주 얼 스 튜 디 오 코 드 같 은 편 집 기 는 폴 더
별 로 저 장 된 t s c o n f i g . j s o n 의 설 정 정 보 만 을 가 져 온 다 . t s c o n f i g . j s o n 대 신 t s c o n f i g .
s e r v e r . j s o n 과 t s c o n f i g . c l i e n t . j s o n 이 라 고 이 름 을 바 꾸 어 서 프 로 젝 트 의 루 트 폴 더 에 저
장 하 는 방 법 도 있 다 ( 물 론 관 련 디 렉 터 리 프 로 퍼 티 를 적 절 하 게 바 꿔 야 함 ) . t s c 는 알 맞 은 설 정
파 일 을 이 용 하 면 서 문 제 가 있 으 면 오 류 를 일 으 킨 다 . 하 지 만 편 집 기 에 서 는 아 무 일 도 일 어 나 지
않 거 나 기 본 설 정 을 이 용 해 작 업 을 이 어 간 다 .
의 존 성 을 공 유 해 야 한 다 면 문 제 가 조 금 복 잡 해 진 다 . 프 로 젝 트 레 퍼 런 스 와 컴 포 지 트 프 로 젝 트
c o m p o s i t e P r o i c 를 이 용 해 이 문 제 를 해 결 할 수 있 다 . 즉 , 공 유 된 코 드 를 특 정 폴 더 로 추 출 한 후 다
른 프 로 젝 트 가 이 폴 더 코 드 에 의 존 함 을 타 입 스 크 립 트 에 알 린 다 .
c l i e n t , s e r v e r 디 렉 터 리 와 같 은 수 준 에 s h a r e d 폴 더 를 만 든 다 . 다 음 은 s h a r e d 의 t s c o n f i g .
j s o n 내 용 이 다 .
/ / shared/tsconfig.json
{
"compilerOptions": {
"composite": true,
"target": "ESNext"
"module": "ESNext"
"rootDir": "../shared/",
"moduleResolution": "Node",
"types": [],
"declaration": true,
"outDir": "../dist/shared",
"esModuleInterop": true,
"forceConsistentCasingInFileNames": true,
"strict": true,
"skipLibCheck": true
3
}
두 가 지 프 로 퍼 티 만 살 펴 보 자 .
• c o m p o s i t e 플 래 그 를 t r u e 로 설 정 했 다 . 이 는 다 른 프 로 젝 트 가 이 프 로 젝 트 를 참 조 할 수 있 도 록 허 용 한 다 .
• d e c L a r a t i o n 도 t r u e 로 설 정 했 다 . 이 플 래 그 는 다 른 프 로 젝 트 가 형 식 정 보 를 불 러 올 수 있 도 록 코 드 에 서
d . t s 파 일 을 생 성 한 다 .
1 장 프 로 젝 트 설 정 4 5
c l i e n t / t s c o n f i g . j s o n 과 s e r v e r / t s c o n f i g . j s o n 에 다 음 행 을 추 가 한 다 음 클 라 이 언 트 와
서 버 코 드 에 서 공 유 된 정 보 를 가 져 올 수 있 다 .
/ / server/sconfig. json
/ / client/tsconfig. json
{
"compilerOptions" : {
1 / 이 전 과 같 음
} ,
"references": [
{
"path": "../shared/tsconfig.json"
}
}
설 정 을 마 쳤 다 . 공 유 된 의 존 성 을 구 현 한 다 음 클 라 이 언 트 와 서 버 코 드 에 서 이 를 사 용 할 수 있 다 .
하 지 만 이 방 식 에 는 문 제 가 있 다 . 예 를 들 어 모 델 과 형 식 정 보 만 공 유 한 다 면 이 기 법 으 로 아
무 문 제 가 없 지 만 , 실 제 기 능 을 공 유 해 야 할 때 는 두 다 른 모 듈 시 스 템 ( 노 드 의 C o m m o n J S 와
브 라 우 저 의 E C M A S c r i p t 모 듈 ) 이 컴 파 일 된 한 파 일 로 합 쳐 질 수 없 다 는 사 실 을 깨 닫 게 된 다 .
E S N e x t 모 듈 을 만 들 면 C o m m o n j S 코 드 에 서 이 를 임 포 트 할 수 없 고 반 대 로 C o m m o n j S 코
드 를 만 들 면 이 를 브 라 우 저 에 서 임 포 트 할 수 없 다 .
이 를 해 결 하 는 두 가 지 방 법 이 있 다 .
• C o m m o n J S 를 컴 파 일 한 다 음 번 들 러 가 브 라 우 저 의 모 듈 해 석 을 처 리 하 게 할 수 있 다 .
• E C M A S c r i p t 모 듈 로 컴 파 일 한 다 음 이 모 듈 에 기 반 한 최 신 N o d e j s 애 플 리 케 이 션 을 구 현 할 수 있 다 . 자
세 한 내 용 은 1 . 9 절 을 참 고 하 자 .
새 프 로 젝 트 를 시 작 하 는 독 자 라 면 두 번 째 방 법 을 강 력 히 권 장 한 다 .
4 6 실 무 로 통 하 는 타 입 스 크 립 트
1 . 7 테 스 트 설 정 하 기
문 제 테 스 트 를 구 현 하 고 싶 은 데 테 스 팅 프 레 임 워 크 의 글 로 벌 정 의 들 ( 전 역 으 로 정 의 된 모 든 변 수 , 함 수 , 객
체 를 가 리 킴 ) 이 제 품 코 드 를 방 해 한 다 .
해 결 ] 개 발 과 빌 드 용 t s c o n f i g 를 따 로 만 들 고 빌 드 용 에 서 는 모 든 테 스 트 파 일 을 제 외 한 다 .
논 의 자 바 스 크 립 트 와 N o d e . j s 생 태 계 에 는 많 은 단 위 테 스 팅 프 레 임 워 크 와 테 스 트 러 너 가 있
다 . 각 제 품 은 세 부 사 항 이 나 동 작 방 식 이 서 로 다 르 고 때 로 는 특 정 요 구 사 항 에 맞 춰 동 작 한 다 .
이 들 중 일 부 는 다 른 제 품 보 다 더 매 력 적 인 기 능 을 제 공 한 다 .
아 바 A r ( h t t p s : / / o r e i l . L y / R 6 x F r ) 같 은 테 스 트 러 너 는 프 레 임 워 크 를 영 역 으 로 가 져 올 때 모 듈
임 포 트 에 의 존 하 지 만 , 다 른 제 품 은 전 역 선 언 집 합 을 제 공 한 다 . 예 를 들 어 모 카 M o c h ( h t t p s : / /
m o c h a j s . o r g ) 를 살 펴 보 자 .
import assert from "assert";
import { add } from "..";
describe("Adding numbers", () => {
it("should add two numbers", () → > {
assert.equal(add (2, 3), 5);
});
} ) ;
a s s e r t 는 N o d e . j s 의 내 장 어 서 션 a s e r t i o n 라 이 브 러 리 에 서 가 져 왔 지 만 , d e s c r i b e 와 i t 등 다 양
한 키 워 드 는 모 카 가 제 공 하 는 전 역 선 언 에 서 가 져 온 다 . 이 들 은 모 카 C L I 가 실 행 중 일 동 안 만
존 재 한 다 .
형 식 설 정 시 이 때 문 에 약 간 의 문 제 가 발 생 한 다 . 이 들 기 능 은 테 스 트 를 구 현 할 때 필 요 하 지 만
실 제 애 플 리 케 이 션 을 실 행 할 때 는 존 재 하 지 않 기 때 문 이 다 .
두 가 지 설 정 파 일 을 만 들 어 이 문 제 를 해 결 할 수 있 다 . 편 집 기 가 인 식 하 도 록 만 든 t s c o n f i g .
j s o n 파 일 은 개 발 시 사 용 하 고 ( 1 . 6 절 참 고 ) , 다 른 애 플 리 케 이 션 을 컴 파 일 할 때 사 용 할 t s c o n f i g .
b u i l d . j s o n 을 따 로 만 든 다 .
첫 번 째 설 정 파 일 은 모 카 형 식 을 포 함 한 모 든 필 요 한 전 역 정 의 를 포 함 한 다 . 두 번 째 파 일 은
1 장 프 로 젝 트 설 정 4 7
컴 파 일 시 테 스 트 파 일 을 포 함 하 지 않 는 다 .
이 과 정 을 단 계 별 로 살 펴 보 자 . 이 예 제 에 서 는 모 카 를 사 용 했 지 만 , 제 스 트 ( h t t p s : / / j e s t j s .
1 o ) 같 은 전 역 설 정 을 제 공 하 는 러 너 도 같 은 방 식 으 로 동 작 한 다 .
우 선 모 카 관 련 형 식 을 설 치 한 다 .
$ npm i n s t a l l --save-dev mocha @types/mocha @types/node
새 로 운 t s c o n f i g . b a s e . j s o n 을 만 든 다 . 개 발 용 환 경 과 빌 드 용 환 경 은 포 함 해 야 하 는 파 일 집
합 과 활 성 화 할 라 이 브 러 리 목 록 만 다 를 뿐 이 므 로 이 외 의 컴 파 일 설 정 은 공 유 할 수 있 도 록 한
파 일 에 저 장 한 다 . 다 음 은 N o d e . j s 애 플 리 케 이 션 설 정 파 일 의 예 다 .
}
기 본 적 으 로 소 스 파 일 은 S r c 폴 더 에 있 고 테 스 트 파 일 은 t e s t 폴 더 에 있 어 야 한 다 . 하 지 만 이 절
의 설 정 파 일 은 프 로 젝 트 의 어 느 위 치 에 나 . t e s t . t s 로 끝 나 는 파 일 을 만 들 수 있 게 허 용 한 다 .
기 본 개 발 환 경 을 제 공 할 새 t s c o n f i g . j s o n 파 일 을 만 든 다 . 편 집 기 피 드 백 을 제 공 하 고 모 카
로 테 스 트 를 실 행 하 는 용 도 로 이 파 일 을 사 용 한 다 . 기 존 t s c o n f i g . b a s e . j s o n 의 기 본 설 정 을
상 속 받 으 면 서 타 입 스 크 립 트 에 컴 파 일 할 파 일 의 위 치 를 알 려 준 다 .
/ / tsconfig.json
{
"extends": "./tsconfig.base.json",
"compilerOptions": {
"types": [
/ / tsconfig.base.json
{
"compilerOptions": {
"target": "esnext"
"module": "commonjs",
"esModuleInterop": true,
"forceConsistentCasingInFileNames": true,
"strict": true,
"outDir": " '/dist",
"skipLibCheck": true
}
4 8 실 무 로 통 하 는 타 입 스 크 립 트
"node", "mocha"
] ,
"rootDirs": [
"test",
"src"
]
}
}
t y p e s 에 n o d e 와 m o c h a 를 추 가 했 다 . t y p e s 프 로 퍼 티 는 어 떤 지 역 정 의 를 사 용 할 수 있 는 지 정
의 하 며 개 발 환 경 에 서 는 두 가 지 형 식 모 두 를 사 용 할 수 있 다 .
추 가 테 스 트 를 실 행 하 려 면 먼 저 코 드 를 컴 파 일 해 야 하 는 데 , 이 는 귀 찮 은 작 업 이 다 . 이 작 업 을
간 소 화 할 수 있 다 . 예 를 들 어 t s - n o d e 는 지 역 에 설 치 된 N o d e . j s 를 실 행 하 며 인 메 모 리 타 입 스
크 립 트 컴 파 일 을 먼 저 수 행 한 다 .
$ npm i n s t a l l --save-dev ts-node
$ npx mocha -r ts-node/register tests/*.ts
개 발 환 경 을 설 정 했 으 니 이 제 빌 드 환 경 을 만 들 차 례 다 . t s c o n f i g . b u i l d . j s o n 을 만 든 다 . 이
파 일 은 t s c o n f i g • j s o n 과 비 슷 하 지 만 다 른 점 이 쉽 게 보 일 것 이 다 .
/ / tsconfig.build.json
{
"extends" : "./tsconfig.base.json",
"compilerOptions": {
"types": [
"node"
3
"rootDirs": [
"sre"
]
"exclude": [
"\*\*/*.test.ts",
"**/test/**"
]
}
1 장 프 로 젝 트 설 정 4 9
t y p e s , r o o t D i r s 를 설 정 했 고 그 밖 에 형 식 검 사 , 컴 파 일 에 서 제 외 할 파 일 도 정 의 했 다 . 와 일 드
카 드 패 턴 을 사 용 해 . t e s t . t s 로 끝 나 는 모 든 파 일 과 t e s t 폴 더 의 모 든 파 일 을 제 외 했 다 . 필 요
하 다 면 . s p e c . t s 나 s p e c 폴 더 도 e x c l u d e 에 포 함 할 수 있 다 .
적 절 한 J S O N 파 일 을 이 용 해 프 로 젝 트 를 컴 파 일 한 다 .
$ npx tsc -p tsconfig. build.json
테 스 트 파 일 은 결 과 파 일 ( d i s t 에 저 장 됨 ) 에 포 함 되 지 않 음 을 알 수 있 다 . 소 스 파 일 을 편 집 하
면 서 d e s c r i b e 와 i t 를 이 용 할 수 있 지 만 , 컴 파 일 하 면 오 류 가 발 생 한 다 .
$ npx tsc -p tsconfig. build.json
s r c / i n d e x . t s : 5 : 1 - ' d e s c r i b e ' 이 름 을 찾 을 수 없 습 니 다 . 테 스 트 실 행 기 의 형 식 정 의 를
설 치 하 려 는 경 우 ' n p i - - s a v e - d e v e t y p e s / j e s t ' 또 는 ' n p m i - - s a v e - d e v e t y p e s / m o c h a ' 를
시 도 합 니 다 . t s ( 2 5 8 2 )
5 describe("this does not work", () → > (})
N A N N A N A N
Found 1 error i n src/index.ts:5
개 발 모 드 의 전 역 설 정 을 깔 끔 하 게 유 지 하 고 싶 다 면 1 . 6 절 처 럼 설 정 할 수 있 지 만 , 소 스 파 일
근 처 에 테 스 트 파 일 을 구 현 할 수 없 다 는 단 점 이 있 다 .
마 지 막 으 로 언 제 든 모 듈 시 스 템 을 선 호 하 는 테 스 트 러 너 를 선 택 할 수 있 다 .
5 0 실 무 로 통 하 는 타 입 스 크 립 트
1 . 8 U R L 로 E C M A S c r i p t 모 듈 형 식 화 하 기
문 제 번 들 러 를 사 용 하 지 않 고 브 라 우 저 의 모 듈 로 딩 기 능 을 앱 에 활 용 하 면 서 모 든 형 식 정 보 를 사 용 하 고 싶 다 .
해 결 t s c o n f i g . j s o n 의 t a r g e t , m o d u l e 컴 파 일 러 옵 션 을 e s n e x t 로 설 정 하 고 • j s 확 장 자 로
모 듈 을 가 리 킨 다 . 또 한 N P M 으 로 형 식 을 의 존 성 에 설 치 한 다 음 p a t h 프 로 퍼 티 로 타 입 스 크 립
트 가 어 디 에 서 형 식 을 찾 을 수 있 는 지 알 려 준 다 .
/ / tsconfig.json
{
"compilerOptions": {
"target": "esnext",
"module": "esnext",
"paths": {
"https://esm.sh/lodash@4.17.21": [
"node_modules/@types/lodash/index.d.ts"
]
}
}
}
논 의 최 신 브 라 우 저 는 모 듈 로 딩 을 자 체 적 으 로 지 원 한 다 . 앱 을 여 러 작 은 파 일 로 묶 지 않 고
자 바 스 크 립 트 파 일 을 직 접 그 대 로 사 용 할 수 있 다 . e s m . s h ( h t t p s : / / e s m . s h ) , u n p k g ( h t t p s : / /
u n p k g . c o m ) 같 은 콘 텐 츠 전 송 네 트 워 크 c o n i e n t d e l v e r y n e t w o r k ( C D N ) 는 E C M A S c r i p t 모 듈 로 딩 시
읽 을 수 있 도 록 노 드 모 듈 과 자 바 스 크 립 트 의 존 성 을 U R L 로 배 포 한 다 .
적 절 한 캐 싱 과 최 신 H T T P , E C M A S c r i p t 모 듈 을 이 용 해 이 문 제 를 해 결 할 수 있 다 .
타 입 스 크 립 트 는 최 신 번 들 러 를 포 함 하 지 않 으 므 로 어 쨌 든 추 가 도 구 를 설 치 해 야 한 다 . 하 지 만
모 듈 을 먼 저 만 들 어 야 하 는 상 황 이 라 면 타 입 스 크 립 트 로 작 업 할 때 몇 가 지 사 항 을 고 려 해 야 한 다 .
타 입 스 크 립 트 로 i m p o r t , e x p o r t 구 문 을 구 현 하 면 서 동 시 에 모 듈 로 딩 문 법 을 보 존 해 야 하 고
브 라 우 저 는 모 듈 을 해 석 할 수 있 어 야 한 다 .
1 / m o d u l e . t s 파 일
export const obj = {
name: "Stefan",
1 장 프 로 젝 트 설 정 5 1
/ / i n d e x . t s 파 일
import {obj } from "./module";
console. log(obj.name);
그 러 려 면 타 입 스 크 립 트 에 다 음 을 지 시 해 야 한 다 .
1 모 듈 을 이 해 하 는 E C M A S c r i p t 버 전 으 로 컴 파 일 하 기
2 이 E C M A S C r i p t 버 전 문 법 으 로 모 듈 코 드 생 성 하 기
t s c o n f i g . j s o n 의 두 프 로 퍼 티 를 다 음 처 럼 바 꾼 다 .
/ / tsconfig.json
{
"compilerOptions": {
"target": "esnext",
"module": "esnext"
}
}
m o d u l e 은 타 입 스 크 립 트 가 i m p o r t , e x p o r t 구 문 을 어 떻 게 변 환 할 지 지 정 한 다 . 1 . 2 절 에 서 소
개 했 듯 이 C o m m o n j S 모 듈 로 딩 으 로 변 환 하 는 것 이 기 본 값 이 다 . m o d u l e 을 e s n e x t 로 설 정 하
면 E C M A S c r i p t 모 듈 로 딩 을 사 용 하 므 로 문 법 이 유 지 된 다 .
t a r g e t 은 타 입 스 크 립 트 가 코 드 를 변 환 할 E C M A S c r i p t 버 전 을 지 정 한 다 . 일 년 에 한 번 씩 새
로 운 기 능 을 포 함 하 는 새 E C M A S c r i p t 버 전 이 릴 리 스 된 다 . e s n e x t 는 최 신 E C M A S c r i p t 버 전
을 사 용 한 다 는 의 미 다 .
이 프 로 퍼 티 를 지 원 하 려 는 브 라 우 저 와 호 환 되 는 E C M A S c r i p t 버 전 으 로 설 정 하 므 로 원 하
는 호 환 성 을 얻 을 수 있 다 . 보 통 은 e s 2 0 1 5 , e s 2 0 1 6 , e s 2 0 1 7 처 럼 연 도 를 버 전 으 로 사 용 한 다 .
E C M A S c r i p t 모 듈 은 e s 2 0 1 5 부 터 모 든 버 전 에 적 용 된 다 . 이 보 다 이 전 버 전 이 라 면 브 라 우 저 에
서 자 체 적 으 로 E C M A S c r i p t 모 듈 을 불 러 올 수 없 다 .
이 들 컴 파 일 러 옵 션 을 바 꿔 서 문 법 유 지 라 는 중 요 한 이 점 을 얻 었 다 . 코 드 를 실 행 해 보 면 오 류
가 발 생 한 다 .
5 2 실 무 로 통 하 는 타 입 스 크 립 트
타 입 스 크 립 트 의 i m p o r t 구 문 으 로 파 일 을 가 리 킬 때 는 보 통 확 장 자 를 표 시 하 지 않 는 다 . 예 를
들 어 i m p o r t { o b j } f r o m " . / m o d u l e " 처 럼 확 장 자 인 . t s 가 빠 진 다 . 컴 파 일 한 이 후 에 도 여
전 히 확 장 자 는 돌 아 오 지 않 는 다 . 하 지 만 브 라 우 저 에 서 해 당 자 바 스 크 립 트 파 일 을 찾 으 려 면 확
장 자 가 필 요 하 다 .
• t s 파 일 을 가 리 키 는 상 황 이 지 만 , 개 발 시 j s 확 장 자 를 추 가 하 는 방 법 으 로 이 문 제 를 해 결 할
수 있 다 . 타 입 스 크 립 트 는 이 를 영 리 하 게 인 식 한 다 .
/ / index.ts
1 / ' m o d u l e . t s ' 에 서 형 식 을 불 러 오 면 서
1 / 컴 파 일 시 확 장 자 를 그 대 로 유 지 한 다 .
import { obj } from './module.js';
console. log(obj.name);
이 렇 게 프 로 젝 트 모 듈 과 관 련 된 문 제 를 해 결 했 다 !
의 존 성 을 사 용 할 때 더 다 양 한 일 이 일 어 난 다 . 네 이 티 브 를 이 용 한 다 면 e s m . s h ( h t t p s : / / e s m .
s h ) 같 은 C D N 에 서 모 듈 을 불 러 오 길 원 할 것 이 다 .
import _ from "https://esm.sh/lodash@4.17.21"
^ - 오 류 2 3 0 7
const r e s u l t = \_.flattenDeep([1, [2, [3, [4]], 51]);
console. log(result);
타 입 스 크 립 트 는 " h t t p s : / / e s m . s h / l o d a s h e 4 . 1 7 . 2 1 ' 모 듈 또 는 해 당 형 식 선 언 을 찾 을 수 없
습 니 다 . t s ( 2 3 0 7 ) " 라 는 오 류 를 일 으 킨 다 .
타 입 스 크 립 트 의 디 스 크 상 파 일 로 모 듈 을 해 석 하 며 H T T P 를 통 해 서 버 에 서 모 듈 을 해 석 하 지
않 는 다 . 따 라 서 필 요 한 정 보 를 얻 으 려 면 타 입 스 크 립 트 에 직 접 해 석 결 과 를 제 공 해 야 한 다 .
U R L 에 서 의 존 성 을 불 러 오 지 만 이 들 의 존 성 의 형 식 정 보 는 N P M 에 있 다 . L o d a s h 의 형 식 정 보
는 D e f i n i t e l y T y p e d 로 설 치 할 수 있 다 .
1 장 프 로 젝 트 설 정 5 3
// tsconfig.json
{
"compilerOptions": {
1 1 . . .
"paths": {
"https://esm.sh/lodash@4.17.21"; [
"node_modules/@types/lodash/index.d.ts"
]
}
}
$ npm install -D @types/lodash
직 접 형 식 을 제 공 하 는 의 존 성 이 라 면 직 접 의 존 성 을 설 치 할 수 있 다 .
$ npm install -D preact
형 식 을 설 치 했 으 면 컴 파 일 러 옵 션 의 p a t h 프 로 퍼 티 로 타 입 스 크 립 트 가 U R L 을 어 떻 게 해 석 할
지 알 려 준 다 .
}
올 바 른 파 일 을 가 리 켰 는 지 확 인 하 자 !
형 식 을 사 용 하 지 않 거 나 형 식 을 찾 을 수 없 을 때 선 택 할 방 법 도 있 다 . 타 입 스 크 립 트 에 서 는 a n y
를 이 용 해 형 식 확 인 을 무 력 화 할 수 있 다 . 모 듈 에 서 도 이 와 비 슷 한 방 식 으 로 타 입 스 크 립 트 오
류 를 무 시 할 수 있 다 .
/ / @ts-ignore
import \_from "https://esm.sh/lodash@4.17.21"
t s - i g n o r e 는 다 음 행 에 서 형 식 확 인 을 수 행 하 지 말 라 는 의 미 다 ( 1 . 4 절 참 고 ) . 따 라 서 의 존 성
에 서 어 떤 형 식 정 보 도 얻 지 못 하 며 결 국 오 류 를 초 래 할 수 있 다 . 하 지 만 유 지 보 수 가 중 단 된
옛 의 존 성 을 사 용 하 려 면 이 방 법 을 선 택 해 야 할 때 도 있 다 .
5 4 실 무 로 통 하 는 타 입 스 크 립 트
1 . 9 노 드 에 서 다 른 모 듈 형 식 불 러 오 기
문 제 N o d e j s 에 서 E C M A S c r i p t 모 듈 을 사 용 하 고 라 이 브 러 리 의 상 호 운 용 성 기 능 에 C o m m o n J S
를 사 용 해 야 한 다 .
해 결 타 입 스 크 립 트 의 모 듈 해 석 을 " n o d e N e x t " 로 설 정 하 고 파 일 이 름 은 . m t s 나 . c t s 로 설 정
한 다 .
논 의 N o d e . j s 가 발 전 하 면 서 C o m m o n j s 모 듈 시 스 템 은 자 바 스 크 립 트 생 태 계 에 서 매 우 인
기 있 는 모 듈 시 스 템 이 되 었 다 .
이 모 듈 시 스 템 의 아 이 디 어 는 간 단 하 고 효 과 적 이 다 . 한 모 듈 에 서 e x p o r t 를 선 언 하 고 다 른 모
듈 에 서 r e q u i r e 로 이 를 소 비 한 다 .
/ / person.js
function printPerson(person) {
console. log (person.name);
}
exports = {
printPerson,
3;
/ / index.js
const person = require("•/person");
person.printPerson({ name: "Stefan", age: 40 3);
이 모 듈 시 스 템 은 E C M A S c r i p t 모 듈 에 큰 영 향 을 미 쳤 으 며 현 재 는 타 입 스 크 립 트 모 듈 해 석 ,
트 랜 스 파 일 러 에 서 기 본 기 능 으 로 사 용 한 다 . [ 예 제 1 - 1 ] 의 E C M A S c r i p t 모 듈 문 법 에 서 키 워 드
들 이 다 양 한 트 랜 스 파 일 러 를 지 원 함 을 알 수 있 다 . 따 라 서 c o m m o n j s 모 듈 을 사 용 하 도 록 설 정
하 면 i m p o r t , e x p o r t 문 이 r e q u i r e , e x p o r t s 로 변 환 된 다 .
예 제 1 - 1 E C M A S c r i p t 모 듈 시 스 템 사 용
/ / person.ts
type Person = {
name: string;
1 장 프 로 젝 트 설 정 5 5
age: number;
! !
export function printPerson(person) {
console. log(person.name);
}
/ / index.ts
import _ as person from "./person";
person.printPerson({ name: "Stefan", age: 40 });
E C M A S c r i p t 모 듈 이 안 정 화 되 면 서 N o d e . j s 또 한 이 들 을 적 용 하 기 시 작 했 다 . 두 모 듈 시
스 템 의 기 본 적 인 부 분 은 비 슷 하 지 만 세 부 적 으 로 다 른 점 들 ( 예 : 디 폴 트 익 스 포 트 처 리 ,
E C M A S c r i p t 모 듈 비 동 기 로 딩 ) 이 있 다 .
두 모 듈 시 스 템 의 문 법 이 다 르 므 로 N o d e . j s 유 지 보 수 자 들 은 두 시 스 템 이 서 로 다 른 부 분 을
수 용 할 수 있 도 록 했 으 며 서 로 구 분 되 는 파 일 확 장 자 를 할 당 해 선 호 하 는 모 듈 형 식 이 무 엇 인 지
나 타 낼 수 있 게 했 다 . [ 표 1 - 1 ] 은 파 일 확 장 자 에 따 라 타 입 스 크 립 트 가 이 들 을 어 떻 게 컴 파 일 하
며 무 엇 을 임 포 트 하 는 지 보 여 준 다 . C o m m o n j S 의 상 호 운 용 성 덕 분 에 E C M A S c r i p t 모 듈 에 서
C o m m o n j S 를 임 포 트 할 수 있 지 만 , 반 대 로 는 불 가 능 하 다 .
표 1 - 1 모 듈 확 장 자 와 관 련 임 포 트
확 장 자 타 입 스 크 립 트 컴 파 일 대 상 임 포 트 할 수 있 는 확 장 자
•js -ts CommonJS •jS, .CjS
.cjs .cts CommonJS • j s , .cjs
-mjs mts E S 모 듈 •js, .cjs, .mjs
N P M 에 라 이 브 러 리 를 배 포 하 는 개 발 자 들 은 p a c k a g e . j s o n 을 이 용 해 주 요 패 키 지 형 식
( m o d u l e 또 는 c o m m o n j s ) 을 지 정 할 수 있 으 며 모 듈 파 일 로 더 가 올 바 른 파 일 을 선 택 할 수 있
도 록 기 본 파 일 이 나 폴 백 ( l b x c k 파 일 목 록 도 설 정 할 수 있 다 .
/ / package.json
{
"name": "dependency",
"type" : "module",
5 6 실 무 로 통 하 는 타 입 스 크 립 트
"exports": {
".": {
1 / E S 모 듈 의 i m p o r t d e p e n d e n c y " " 진 입 점
"import": "./esm/index.js",
1 / C o m m o n J S 의 r e q u i r e ( " d e p e n d e n c y " ) 진 입 점
"require": "./commonjs/index.cjs",
ふ
} ,
1 / C o m m o n J S 폴 백
"main" : "./commonjs/index.cjs"
}
타 입 스 크 립 트 에 서 는 주 로 E C M A S c r i p t 모 듈 문 법 을 사 용 한 다 음 컴 파 일 러 가 마 지 막 에 생 성 할
모 듈 포 맷 을 결 정 하 도 록 한 다 . 현 재 는 C o m m o n J S , E C M A S c r i p t 모 듈 두 가 지 옵 션 이 있 다 .
둘 다 지 원 하 려 면 t s c o n f i g . j s o n 에 서 m o d u l e 을 N o d e N e x t 로 설 정 한 다 .
"compilerOptions": {
"module": "NodeNext"
1 1 . . .
}
}
이 플 래 그 를 이 용 하 면 p a c k a g e . j s o n 에 서 지 정 한 의 존 성 에 필 요 한 올 바 른 모 듈 을 선 택 하 며
[ 표 1 - 1 ] 에 서 설 명 했 듯 이 . m t s , . c t s 확 장 자 를 인 식 해 모 듈 을 임 포 트 한 다 .
파 일 을 임 포 트 할 때 다 른 부 분 이 있 다 . C o m m o n J S 는 임 포 트 할 때 확 장 자 를 사 용 하 지 않 으 므
로 타 입 스 크 립 트 는 확 장 자 가 없 는 임 포 트 도 지 원 해 야 한 다 . C o m m o n I S 에 서 는 [ 예 제 1 - 1 ] 이
문 제 없 이 동 작 한 다 .
1 . 8 절 의 예 제 처 럼 파 일 확 장 자 를 포 함 한 임 포 트 는 E C M A S c r i p t 모 듈 과 C o m m o n j S 모 듈 을
임 포 트 하 도 록 허 용 한 다 .
/ / index.mts
i m p o r t _ a s p e r s o n f r o m " • / p e r s o n . j s " ; 1 / 두 모 듈 모 두 에 서 동 작
person.printPerson({ name: "Stefan", age: 40});
1 장 프 로 젝 트 설 정 5 7
C o m m o n j S 를 상 호 운 용 할 수 없 는 상 황 을 대 비 해 r e q u i r e 구 문 을 폴 백 으 로 설 정 할 수 있 다 .
다 음 처 럼 " n o d e " 를 컴 파 일 옵 션 에 서 전 역 으 로 추 가 한 다 .
/ / tsconfig. json
{
"compilerOptions": {
"module" : "NodeNext",
"types": [
"node"
}
}
그 리 고 타 입 스 크 립 트 전 용 문 법 으 로 이 를 임 포 트 한 다 .
/ / index.mts
import person = require("./person.cjs");
person.printPerson({ name: "Stefan", age: 40 });
C o m m o n j s 모 듈 에 서 는 r e q u i r e 호 출 로 모 듈 을 임 포 트 한 다 . E C M A S c r i p t 모 듈 에 서 는
N o d e . j s 헬 퍼 함 수 를 이 용 한 다 .
1 / 컴 파 일 된 i n d e x . m t s
import { createRequire as \_createRequire } from "module";
const **require = \_createRequire(import.meta.url);
const person = **require("./person.cjs");
person.printPerson({ name: "Stefan", age: 40 });
이 기 법 은 브 라 우 저 같 은 N o d e . j s 가 아 닌 환 경 과 의 호 환 성 을 떨 어 뜨 릴 수 있 다 . 하 지 만 상 호
운 영 문 제 가 앞 으 로 점 차 해 결 될 것 으 로 기 대 할 수 있 다 .
5 8 실 무 로 통 하 는 타 입 스 크 립 트
1 . 1 0 디 노 와 의 존 성 이 용 하 기
문 제 브 라 우 저 밖 에 서 동 작 하 는 애 플 리 케 이 션 자 바 스 크 립 트 런 타 임 인 디 노 D e n o 를 타 입 스 크 립 트 에 이 용 하
고 싶 다 .
해 결 타 입 스 크 립 트 는 디 노 의 내 장 기 능 이 므 로 쉽 게 문 제 를 해 결 할 수 있 다 .
논 의 디 노 는 N o d e . j s 를 개 발 한 사 람 들 이 만 든 최 신 자 바 스 크 립 트 런 타 임 이 다 . 디 노 는 여 러
면 에 서 N o d e . j s 와 비 슷 하 지 만 몇 가 지 중 요 한 차 이 점 이 있 다 .
• 디 노 는 주 요 A P I 에 웹 플 랫 폼 표 준 을 사 용 한 다 . 즉 브 라 우 저 코 드 를 쉽 게 서 버 로 이 식 할 수 있 다 .
• 파 일 시 스 템 이 나 네 트 워 크 에 접 근 하 려 면 명 시 적 으 로 이 를 활 성 화 해 야 한 다 .
• 디 노 는 중 앙 화 된 레 지 스 트 리 로 의 존 성 을 처 리 하 지 않 지 만 U R L 을 통 해 브 라 우 저 기 능 을 이 용 한 다 .
또 한 디 노 는 내 장 개 발 도 구 와 타 입 스 크 립 트 를 이 미 포 함 한 다 !
따 라 서 디 노 는 타 입 스 크 립 트 에 서 매 우 쉽 게 접 근 할 수 있 는 도 구 다 . t s c 컴 파 일 러 를 내 장 하 므
로 별 다 른 도 구 를 내 려 받 을 필 요 가 없 으 며 특 별 한 타 입 스 크 립 트 설 정 도 필 요 없 다 . . t s 파 일 을
구 현 하 면 디 노 가 알 아 서 이 를 처 리 한 다 .
/ / main.ts
function sayHello (name: string) {
console. log (Hello ${name}*);
}
sayHello("Stefan");
$ deno run main.ts
디 노 의 타 입 스 크 립 트 t s c 로 할 수 있 는 모 든 기 능 을 수 행 할 수 있 으 며 디 노 가 업 데 이 트 되 면
t s c 도 업 데 이 트 된 다 . 하 지 만 설 정 과 관 련 해 서 는 몇 가 지 다 른 점 이 있 다 .
먼 저 t s c - - i n i t 으 로 만 든 설 정 과 디 노 의 기 본 설 정 은 서 로 다 르 다 . 특 히 엄 격 모 드 설 정 이
다 르 며 디 노 는 리 액 트 ( 서 버 용 ) 지 원 을 포 함 한 다 .
1 장 프 로 젝 트 설 정 5 9
설 정 을 바 꾸 려 면 루 트 폴 더 에 d e n o . j s o n 파 일 을 만 들 어 야 한 다 . 따 로 설 정 하 지 않 으 면 디 노 는
자 동 으 로 이 파 일 을 읽 는 다 . d e n o . j s o n 은 디 노 런 타 임 에 필 요 한 몇 가 지 설 정 ( 타 입 스 크 립 트
컴 파 일 러 옵 션 포 함 ) 을 포 함 한 다 .
{
"compilerOptions": {
1 / T S C 컴 파 일 러 옵 션
} ,
"fimt" : {
1 / 자 동 포 맷 옵 션
} ,
"lint": {
1 / 린 터 옵 션
}
더 자 세 한 기 능 은 디 노 웹 사 이 트 ( h t t p s : / / d o c s . d e n o . c o m / r u n t i m e / m a n u a l ) 에 서 확 인 할 수 있 다 .
기 본 라 이 브 러 리 도 서 로 다 르 다 . 디 노 는 웹 플 랫 폼 표 준 을 지 원 하 며 브 라 우 저 호 환 A P I 도 포 함
하 지 만 그 래 픽 사 용 자 인 터 페 이 스 가 없 으 므 로 기 능 이 축 소 된 버 전 이 다 . D O M 라 이 브 러 리 등
이 디 노 와 호 환 되 지 않 는 이 유 가 바 로 이 때 문 이 다 .
다 음 은 몇 가 지 흥 미 로 운 라 이 브 러 리 다 .
• d e n o . n s : 디 폴 트 디 노 네 임 스 페 이 스
• d e n o . w i n d o w : 디 노 용 전 역 객 체
• d e n o . w o r k e r : 디 노 런 타 임 의 웹 워 커 w e b w o r k e r
디 노 는 D O M 과 하 위 집 합 을 포 함 하 지 만 기 본 값 으 로 이 들 은 비 활 성 화 되 어 있 다 . 브 라 우 저 와
디 노 둘 다 대 상 으 로 삼 는 애 플 리 케 이 션 이 라 면 모 든 브 라 우 저 와 디 노 라 이 브 러 리 를 포 함 하 도
록 디 노 를 설 정 한 다 .
/ / deno. json
{
"compilerOptions": {
"target": "esnext",
"lib": [ "dom",
60 실 무 로 통 하 는 타 입 스 크 립 트
"dom. iterable",
"dom-asynciterable",
"deno.ns"
]
}
}
A l e p h . j s ( h t t p s : / / a l e p h j s . o r g ) 는 디 노 와 브 라 우 저 를 모 두 대 상 으 로 삼 는 프 레 임 워 크 의 예 다 .
의 존 성 의 형 식 정 보 를 배 포 하 는 방 법 도 다 르 다 . 디 노 에 서 외 부 의 존 성 을 U R L 을 통 해 C D N 에
서 불 러 온 다 . 디 노 자 신 의 표 준 라 이 브 러 리 는 h t t p s : / / d e n o . l a n d / s t d 로 호 스 팅 한 다 .
하 지 만 1 . 8 절 에 서 설 명 했 듯 이 e s m . s h ( h t t p s : / / e s m . s h ) 나 u n p k g ( h t t p s : / / u n p k g . c o m ) 같 은
C D N 을 사 용 할 수 도 있 다 . 이 들 C D N 은 H T T P 요 청 헤 더 에 X - T y p e s c r i p t - T y p e s 를 보 내 형
식 을 배 포 하 며 이 는 디 노 가 형 식 정 의 를 가 져 올 것 임 을 암 시 한 다 . 퍼 스 트 파 티 형 식 정 의 를 포
함 하 지 않 는 D e f i n i t e l y T y p e d 를 사 용 하 는 의 존 성 에 도 동 일 한 방 식 을 사 용 할 수 있 다 .
따 라 서 의 존 성 을 설 치 하 면 디 노 가 소 스 파 일 과 형 식 정 보 를 모 두 가 져 온 다 .
C D N 대 신 로 컬 에 서 의 존 성 을 불 러 온 다 면 의 존 성 을 임 포 트 할 때 형 식 정 의 파 일 을 지 정 할 수
있 다 .
/ / @deno-types="./charting.d.ts"
import \* as charting from "./charting.js";
또 는 라 이 브 러 리 자 체 의 형 식 레 퍼 런 스 를 포 함 하 는 방 법 도 있 다 .
/ / charting.js
/// ‹reference types="./charting.d.ts" /›
이 레 퍼 런 스 는 삼 중 슬 래 시 지 시 어 라 고 도 부 르 는 타 입 스 크 립 트 기 능 으 로 , 디 노 에 서 제 공
하 는 기 능 이 아 니 다 . 이 외 에 도 다 양 한 삼 중 슬 래 시 지 시 어 가 있 는 데 이 는 대 부 분 기 존 의
E C M A S c r i p t 모 듈 의 존 성 시 스 템 에 서 사 용 하 던 지 시 다 . 자 세 한 사 항 은 관 련 문 서 ( h t t p s : / /
o r e i l . L y / E v n m ) 를 참 고 하 자 . E C M A S C r i p t 모 듈 을 사 용 한 다 면 이 런 삼 중 슬 래 시 지 시 어 를
사 용 할 필 요 가 없 다 .
1 장 프 로 젝 트 설 정 6 1
1 . 1 1 미 리 정 의 된 설 정 사 용 하 기
문 제 어 떤 설 정 으 로 시 작 해 야 할 지 잘 모 르 는 상 태 로 특 정 프 레 임 워 크 나 플 랫 폼 에 타 입 스 크 립 트 를 사 용
하 려 한 다 .
해 결 t s c o n f i g / b a s e s ( h t t p s : / / o r e i l . L y / L j s V T ) 에 서 제 공 하 는 미 리 정 의 된 설 정 을 선 택 하
고 이 를 확 장 한 다 .
논 의 D e f i n i t e l y T y p e d 에 서 커 뮤 니 티 가 관 리 하 는 유 명 한 라 이 브 러 리 형 식 정 의 를 호 스 팅 하
듯 , t s c o n f i g / b a s e s 는 커 뮤 니 티 가 관 리 하 는 타 입 스 크 립 트 권 장 설 정 을 호 스 팅 한 다 . 이 들 권
장 설 정 을 이 용 해 프 로 젝 트 를 시 작 할 수 있 다 . m b e r . j s , S v e l t e , N e x t . j s 뿐 아 니 라 N o d e . j s ,
디 노 등 자 바 스 크 립 트 런 타 임 용 설 정 도 제 공 한 다 .
이 들 설 정 파 일 은 가 장 권 장 되 는 라 이 브 러 리 , 모 듈 , 대 상 설 정 , 관 련 환 경 에 가 장 적 합 한 엄 격
모 드 플 래 그 만 을 사 용 하 도 록 최 적 화 되 어 있 다 .
예 를 들 어 다 음 은 엄 격 모 드 설 정 과 E C M A S c r i p t 모 듈 을 포 함 하 는 N o d e . j s 1 8 의 권 장 설 정 이 다 .
{
"$schema" : "https://json.schemastore.org/tsconfig",
"display": "Node 18 + ESM + Strictest",
"compilerOptions": {
"lib": [
"es2022"
"module" : "es2022",
"target" : "es2022",
" s t r i c t " : true,
"esModuleInterop": true,
"skipLibCheck": true,
"forceConsistentCasingInFileNames": true,
"moduleResolution": "node",
"allowUnusedLabels": false,
"allowUnreachableCode": false,
"exactOptionalPropertyTypes": true,
"noFallthroughCasesInSwitch": true,
"noImplicitoverride": true,
"noImplicitReturns": true,
"noPropertyAccessFromIndexSignature": true,
6 2 실 무 로 통 하 는 타 입 스 크 립 트
"noUncheckedIndexedAccess" : true,
" n o U n u s e d L o c a l s " : t r u e ,
"noUnusedParameters": true,
"importsNotUsedAsValues: "error",
"check]s": true
}
}
N P M 으 로 이 설 정 을 사 용 할 수 있 다 .
$ npm install --save-dev @tsconfig/node18-strictest-esm
다 음 처 럼 타 입 스 크 립 트 설 정 에 이 를 연 결 한 다 .
"extends": "@tsconfig/node18-strictest-esm/tsconfig.json",
"compilerOptions": {
1 1 . . .
}
}
이 로 써 미 리 정 의 된 설 정 의 모 든 정 의 를 가 져 온 다 . 옷 디 렉 터 리 등 의 설 정 을 시 작 할 수 있 다 .
이 제 자 신 만 의 프 로 젝 트 와 관 련 된 루 트 , 아
1 장 프 로 젝 트 설 정 6 3
