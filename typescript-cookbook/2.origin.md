CHAPTER 2
기 본 형
이 제 설 정 을 모 두 마 쳤 으 니 타 입 스 크 립 트 코 드 를 구 현 해 보 자 ! 처 음 에 는 쉽 게 코 딩 을 시 작 할 수
있 지 만 , 시 간 이 지 나 면 서 작 업 이 제 대 로 진 행 되 고 있 는 지 확 신 이 들 지 않 을 수 있 다 . 인 터 페 이
스 를 사 용 해 야 할 까 아 니 면 형 식 별 칭 w p e a i a s 을 사 용 해 야 할 까 ? 형 식 을 지 정 해 야 할 까 아 니 면
자 동 으 로 형 식 을 추 론 하 도 록 놔 둘 까 ? a n y , u n k n o w n 을 사 용 해 도 괜 찮 을 까 ? 어 떤 사 람 들 은 이
들 을 절 대 사 용 하 면 안 된 다 고 하 던 데 그 러 면 왜 타 입 스 크 립 트 에 남 아 있 는 걸 까 ?
이 장 에 서 이 모 든 질 문 의 답 을 제 시 한 다 . 타 입 스 크 립 트 에 서 제 공 하 는 기 본 형 을 살 펴 본 다 음
경 험 이 풍 부 한 타 입 스 크 립 트 개 발 자 가 이 를 어 떻 게 활 용 하 는 지 배 운 다 . 이 렇 게 갈 고 닦 은 기 본
형 관 련 지 식 을 이 후 장 들 에 서 활 용 해 타 입 스 크 립 트 컴 파 일 러 가 형 식 을 어 떻 게 얻 고 , 여 러 분 의
애 너 테 이 션 a m i t o n 을 어 떻 게 해 석 하 는 지 이 해 할 수 있 다 .
이 장 에 서 는 본 격 적 으 로 코 드 , 편 집 기 , 컴 파 일 러 를 사 용 하 며 형 식 계 층 을 이 리 저 리 이 동 하 기
시 작 한 다 . 숙 련 된 타 입 스 크 립 트 개 발 자 와 초 심 자 모 두 이 장 에 서 유 용 한 정 보 를 얻 을 수 있 을
것 이 다 .
2 장 기 본 형 6 5
2 . 1 애 너 테 이 션 효 과 적 으 로 사 용 하 기
문 제 형 식 애 너 테 이 션 을 추 가 하 는 일 은 귀 찮 고 지 루 하 다 .
해 결 형 식 확 인 이 필 요 할 때 만 형 식 을 지 정 한 다 .
논 의 형 식 애 너 테 이 션 으 로 어 떤 형 식 을 기 대 하 는 지 명 시 할 수 있 다 . S t r i n g B u i l d e r s t r i n g B u i l d e r
= n e w S t r i n g B u i l d e r ( ) 처 럼 장 황 한 문 법 을 사 용 하 는 다 른 프 로 그 래 밍 언 어 에 서 는 확 실 하 게
S t r i n g B u i l d e r 형 식 을 처 리 한 다 는 사 실 을 명 확 히 밝 힌 다 . 이 와 반 대 로 타 입 스 크 립 트 는 여 러
분 이 사 용 하 려 는 형 식 이 무 엇 인 지 추 론 하 는 기 능 을 추 가 제 공 한 다 .
1 / 형 식 추 론
let aNumber = 2;
/ / aNumber: number
/ / 형 식 애 너 테 이 션
l e t anotherNumber: number = 3;
/ / anotherNumber: number
타 입 스 크 립 트 와 자 바 스 크 립 트 간 의 큰 문 법 적 차 이 하 나 가 바 로 형 식 애 너 테 이 션 지 원 여 부 다 .
타 입 스 크 립 트 를 처 음 배 울 때 는 명 시 적 으 로 기 대 하 는 모 든 형 식 을 지 정 할 수 있 다 . 어 떤 사 람
들 은 이 를 당 연 하 게 여 기 기 도 한 다 . 하 지 만 따 로 형 식 을 지 정 하 지 않 고 타 입 스 크 립 트 가 형 식 을
추 론 하 도 록 하 는 방 법 도 있 다 .
형 식 애 너 테 이 션 으 로 계 약 사 항 을 어 떻 게 확 인 해 야 하 는 지 표 현 한 다 . 변 수 선 언 에 형 식 애 너 테
이 션 을 추 가 하 면 컴 파 일 러 는 변 수 에 값 을 할 당 할 때 형 식 에 맞 는 지 확 인 한 다 .
type Person = {
name: string;
age: number;
const me: Person = createPerson;
c r e a t e P e r s o n 이 P e r s o n 과 호 환 되 지 않 는 값 을 반 환 하 면 타 입 스 크 립 트 는 오 류 를 일 으 킨 다 .
66 실 무 로 통 하 는 타 입 스 크 립 트
올 바 른 형 식 을 사 용 하 는 지 확 인 하 고 싶 다 면 이 방 법 을 사 용 한 다 .
이 시 점 부 터 m e 는 P e r s o n 형 식 이 며 타 입 스 크 립 트 는 m e 를 P e r s o n 처 럼 취 급 한 다 . m e 에 다 른
프 로 퍼 티 ( 예 : p r o f e s s i o n ) 가 있 어 도 타 입 스 크 립 트 는 이 프 로 퍼 티 에 접 근 을 불 허 한 다 . 이 를
P e r s o n 에 정 의 하 지 않 았 기 때 문 이 다 .
함 수 시 그 니 처 의 반 환 값 에 형 식 애 너 테 이 션 을 추 가 하 면 컴 파 일 러 는 반 환 값 이 형 식 에 맞 는 지
확 인 한 다 .
function createPerson(): Person {
return { name: "Stefan", age: 39 };
}
P e r s o n 과 일 치 하 지 않 는 값 을 반 환 하 면 타 입 스 크 립 트 가 오 류 를 일 으 킨 다 . 반 환 하 는 형 식 이 정
확 하 게 정 해 져 있 을 때 이 방 법 을 활 용 한 다 . 특 히 다 양 한 소 스 를 이 용 해 큰 객 체 를 만 드 는 함 수
에 서 이 를 유 용 하 게 사 용 한 다 .
함 수 의 시 그 니 처 매 개 변 수 에 형 식 애 너 테 이 션 을 추 가 하 면 컴 파 일 러 가 함 수 를 호 출 할 때 인 수
의 형 식 을 검 사 한 다 .
function printPerson(person: Person) {
console. log person.name, person.age);
printPerson (me);
필 자 는 이 것 이 가 장 중 요 하 며 반 드 시 형 식 애 너 테 이 션 을 사 용 해 야 하 는 가 장 중 요 한 부 분 이 라
생 각 한 다 . 그 밖 의 형 식 은 추 론 할 수 있 다 .
type Person = {
name: string;
age: number;
1 / 추 론 됨 !
1 / 반 환 형 식 은 { n a m e : s t r i n g , a g e : n u m b e r }
function createPerson {
return { name: "Stefan", age: 39 };
2 장 기 본 형 6 7
}
1 / 추 론 됨 !
// me: { name: string, age: number}
const me = createPerson);
1 / 애 너 테 이 션 사 용 ! 형 식 이 호 환 되 는 지 검 사 해 야 함
function printPerson(person: Person) 1
console. log(person.name, person.age);
}
1 / 모 두 동 작 함
printPerson(me);
타 입 스 크 립 트 는 구 조 적 형 식 시 스 템 _ n u c u r a l t p e s y s t e m 을 적 용 하 므 로 애 너 테 이 션 을 기 대 하 는 상 황
에 서 추 론 된 객 체 형 식 을 사 용 할 수 있 다 . 구 조 적 형 식 시 스 템 에 서 컴 파 일 러 는 형 식 의 멤 버 ( 프
로 퍼 티 ) 만 따 지 며 실 제 이 름 은 고 려 하 지 않 는 다 .
모 든 멤 버 에 대 응 하 는 값 의 형 식 이 서 로 일 치 하 면 이 를 형 식 이 호 환 되 는 것 으 로 간 주 한 다 . ' 형
식 의 모 양 i a p e 이 나 구 조 e u r e 가 일 치 해 야 한 다 ' 라 고 표 현 하 기 도 한 다 .
type Person = {
name: string;
age: number;
type User = {
name: string;
age: number;
id: number;
function printPerson(person: Person) {
console. log(person.name, person.age);
}
const user: User = {
name: "Stefan",
age: 40,
id: 815,
68 실 무 로 통 하 는 타 입 스 크 립 트
p r i n t P e r s o n ( u s e r ) ; / / 동 작 함 !
U s e r 는 P e r s o n 보 다 프 로 퍼 티 가 많 지 만 P e r s o n 의 모 든 프 로 퍼 티 를 U s e r 가 포 함 하 므 로 이
둘 에 는 같 은 형 식 이 존 재 한 다 . 따 라 서 U s e r 와 P e r s o n 을 명 시 적 으 로 연 결 하 지 않 았 지 만
p r i n t p e r s o n 에 P e r s o n 대 신 U s e r 객 체 를 전 달 할 수 있 다 .
리 터 럴 을 전 달 할 때 는 추 가 프 로 퍼 티 가 허 용 되 지 않 으 므 로 컴 파 일 오 류 가 발 생 한 다 .
printPerson({
name: "Stefan",
age: 40,
id: 1000,
1 / ^ - 객 체 리 터 럴 은 알 려 진 속 성 만 지 정 할 수 있 으 며
1 / ' P e r s o n ' 형 식 에 ' i d ' 이 ( 가 ) 없 습 니 다 . t s ( 2 3 5 3 )
} ) ;
이 는 의 도 하 지 않 은 프 로 퍼 티 가 형 식 에 포 함 되 어 예 상 하 지 못 한 상 황 이 일 어 나 는 일 을 방 지 한 다 .
구 조 적 형 식 시 스 템 에 서 는 형 식 이 추 론 된 캐 리 어 c a r i e r 변 수 라 는 재 미 있 는 패 턴 을 만 들 수 있 으
며 해 당 변 수 를 아 무 연 관 성 이 없 는 소 프 트 웨 어 의 다 른 부 분 에 서 재 사 용 할 수 있 다 .
type Person = 1
name: string;
age: number;
type Studying = {
semester: number;
type Student = {
id: string;
age: number;
semester: number;
function c r e a t e P e r s o n {
return { name: "Stefan", age: 39, semester: 25, id: "XP" };
2 장 기 본 형 6 9
function printPerson(person: Person) {
console. log(person.name, person.age);
}
function studyForAnotherSemester(student: Studying) {
student.semester++;
}
function isLongTimeStudent(student: Student) {
return student.age - student.semester / 2 › 30 && student.semester › 20;
}
const me = createPerson();
1 / 모 두 동 작 함 !
printPerson (me) ;
studyForAnotherSemester (me);
isLongTimeStudent (me);
S t u d e n t , P e r s o n , S t u d y i n g 은 일 부 프 로 퍼 티 를 공 유 하 지 만 서 로 직 접 적 인 연 관 성 은 없 다 .
c r e a t e p e r s o n 은 이 세 가 지 형 식 과 호 환 되 는 형 식 을 반 환 한 다 . 애 너 테 이 션 을 너 무 많 이 사 용
하 면 더 많 은 형 식 을 만 들 어 야 하 고 필 요 이 상 으 로 형 식 을 검 사 해 야 하 는 불 필 요 한 오 버 헤 드 가
발 생 한 다 .
따 라 서 형 식 검 사 가 필 요 한 곳 ( 특 히 함 수 매 개 변 수 ) 에 애 너 테 이 션 을 추 가 하 면 좋 다 .
2 . 2 a n y 와 u n k n o w n 활 용 하 기
문 제 a n y , u n k n o w n 형 식 중 무 엇 을 사 용 해 야 할 까 ?
해 결 형 식 기 능 을 끄 고 싶 은 상 황 에 서 a n y 를 사 용 하 며 주 의 가 필 요 할 때 u n k n o w n 을 사 용 한 다 .
논 의 a n y 와 u n k n o w n 모 두 최 상 위 형 식 이 므 로 모 든 값 은 a n y 나 u n k n o w n 과 호 환 된 다 .
const name: any = "Stefan";
const person: any/= { name: "Stefan", age: 40 };
7 0 실 무 로 통 하 는 타 입 스 크 립 트
const notAvailable: any = undefined;
a n y 는 모 든 값 과 호 환 되 므 로 모 든 프 로 퍼 티 에 마 음 대 로 접 근 할 수 있 다 .
const name: any = "Stefan";
1 / 타 입 스 크 립 트 에 서 는 괜 찮 지 만 자 바 스 크 립 트 에 서 는 충 돌 발 생
console. log(name.profession.experience[0].level);
a n y 는 n e v e r 를 제 외 한 다 른 모 든 하 위 형 식 과 호 환 된 다 . 즉 a n y 에 새 로 운 형 식 을 할 당 하 는 방
식 으 로 가 능 한 값 의 범 위 를 좁 힐 수 있 다 .
const me: any = "Stefan";
/ / 좋 음 !
const name: string = me;
1 / 나 쁨 . 하 지 만 형 식 시 스 템 상 으 로 는 문 제 가 없 음 .
const age: number = me;
a n y 는 허 용 성 이 너 무 좋 아 형 식 검 사 를 무 력 화 하 므 로 잠 재 적 으 로 오 류 와 문 제 를 일 으 킬 수 있 다 .
대 다 수 의 사 람 은 a n y 를 코 드 에 사 용 하 지 않 아 야 한 다 는 사 실 에 동 의 하 지 만 , 다 음 과 같 이 a n y
를 유 용 하 게 활 용 할 수 있 는 상 황 도 있 다 .
마 이 그 레 이 션
자 바 스 크 립 트 에 서 타 입 스 크 립 트 로 프 로 젝 트 를 마 이 그 레 이 션 하 는 상 황 이 라 면 자 료 구 조 와
객 체 의 동 작 과 관 련 해 많 은 암 묵 적 인 정 보 를 이 미 포 함 할 것 이 다 . 이 런 상 황 에 서 는 마 이 그
레 이 션 과 정 에 서 발 생 하 는 모 든 문 제 를 한 번 에 해 결 하 기 가 어 렵 다 . 이 럴 때 a n y 를 이 용 해
안 전 하 게 점 진 적 으 로 코 드 를 마 이 그 레 이 션 할 수 있 다 .
형 식 이 없 는 서 드 파 티 의 존 성
하 지 만 여 전 히 타 입 스 크 립 트 ( 또 는 이 와 유 사 한 기 능 ) 를 사 용 하 지 못 하 게 방 해 하 는 자 바
스 크 립 트 의 존 성 이 존 재 할 수 있 다 . 심 지 어 최 악 의 상 황 에 는 최 신 형 식 정 보 를 아 예 구 할
수 없 을 수 도 있 다 . D e f i n i t e l y T y p e d 는 유 용 한 저 장 소 이 지 만 자 발 적 으 로 유 지 보 수 된
다 . 자 바 스 크 립 트 에 존 재 하 는 기 능 의 형 식 을 제 공 하 지 만 공 식 적 인 방 법 은 아 니 다 . 따 라 서
2 장 기 본 형 7 1
D e f i n i t e l y T y p e d 에 는 ( 리 액 트 같 은 유 명 한 형 식 정 의 에 도 ) 오 류 가 있 을 수 있 으 며 , 최 신 자
료 가 없 을 수 도 있 다 !
이 런 상 황 에 a n y 가 도 움 이 된 다 . 라 이 브 러 리 가 어 떻 게 동 작 하 는 지 알 고 , 문 서 가 잘 작 성 되
었 고 , 자 주 사 용 하 지 않 는 상 황 이 라 면 정 확 한 형 식 을 결 정 하 는 데 구 애 받 지 말 고 a n y 를 활
용 하 는 것 도 좋 은 선 택 이 다 .
자 바 스 크 립 트 프 로 토 타 이 핑
타 입 스 크 립 트 는 자 바 스 크 립 트 와 동 작 방 식 이 다 르 므 로 몇 가 지 작 업 을 해 주 어 야 만 다 양 한
문 제 를 피 할 수 있 다 . 때 로 는 자 바 스 크 립 트 에 서 는 문 제 없 이 동 작 하 는 코 드 라 도 타 입 스 크 립
트 에 서 는 오 류 가 발 생 한 다 .
type Person = {
name: string;
age: number;
function printPerson(person: Person) {
for (let key in person) ‹
console. Log (${key}: ${person[key]}_);
1 / ' s t r i n g ' 형 식 은 ' P e r s o n ' 의
1 / 인 덱 스 형 식 으 로 사 용 할 수 없 으 므 로
1 / k e y 는 암 묵 적 으 로 ' a n y ' 형 식 임 .
1 / ' P e r s o n ' 형 식 에 는 ' s t r i n g ' 형 식 의 매 개 변 수 가
1 / 존 재 하 지 않 음 . ( 7 0 5 3 )
}
}
이 코 드 에 서 오 류 가 발 생 하 는 이 유 는 9 . 1 절 에 서 자 세 히 설 명 한 다 . 여 기 서 a n y 는 형 식 검 사 를
잠 시 중 단 하 고 해 결 해 야 할 일 에 집 중 하 는 데 도 움 을 준 다 . 모 든 형 식 을 a n y 로 변 환 하 거 나 a n y
를 다 시 아 무 형 식 으 로 변 환 할 수 있 으 므 로 a n y 를 사 용 한 블 록 은 안 전 하 지 않 은 코 드 를 포 함 한
다 는 사 실 을 명 시 적 으 로 보 여 준 다 .
function printPerson(person: any) {
for ( l e t key i n person) {
console. log(${key}: ${person[key]}*');
}
}
7 2 실 무 로 통 하 는 타 입 스 크 립 트
이 부 분 의 코 드 가 동 작 한 다 는 사 실 을 확 인 했 으 면 타 입 스 크 립 트 의 제 한 과 형 식 어 서 션 을 이 용
해 올 바 로 형 식 을 추 가 할 수 있 다 .
function printPerson(person: Person) {
for ( l e t key i n person) {
console. log(*${key}: $(person[key as keyof Person]}*);
}
}
a n y 를 사 용 할 때 는 t s c o n f i g . j s o n 에 n o l m p l i c i t A n y 플 래 그 를 활 성 화 해 야 한 다 ( s t r i c t 모
드 에 서 는 기 본 값 으 로 활 성 화 됨 ) . 추 론 이 나 애 너 테 이 션 으 로 형 식 을 지 정 할 수 없 는 상 황 에 서 는
명 시 적 으 로 a n y 로 형 식 을 지 정 해 야 한 다 . 이 렇 게 하 면 나 중 에 잠 재 적 오 류 를 쉽 게 찾 을 수 있 다 .
a n y 대 신 u n k n o w n 을 사 용 할 수 있 다 . a n y 와 u n k n o w n 으 로 같 은 값 을 가 리 킬 수 있 지 만 실 제
사 용 방 법 은 서 로 다 르 다 . a n y 로 는 모 든 것 을 할 수 있 지 만 , u n k n o w n 으 로 는 아 무 것 도 할 수 없
으 며 단 지 값 을 여 기 서 저 기 로 전 달 할 수 있 을 뿐 이 다 . 함 수 를 호 출 하 거 나 형 식 을 구 체 화 하 려
면 먼 저 형 식 을 검 사 해 야 한 다 .
const me: unknown = "Stefan";
const name: string = me;
^ - ' u n k n o w n ' 형 식 은 ' s t r i n g ' 형 식 에 할 당 할 수 없 습 니 다 . t s ( 2 3 2 2 )
const age: number = me;
^ - ' u n k n o w n ' 형 식 은 ' n u m b e r ' 형 식 에 할 당 할 수 없 습 니 다 . t s ( 2 3 2 2 )
형 식 검 사 와 제 어 흐 름 을 이 용 해 u n k n o w n 을 특 정 형 식 으 로 구 체 화 할 수 있 다 .
function doSomething(value: unknown) {
i f (typeof value === "string") {
/ / value: s t r i n g
console. log("It's a string"', value. toUpperCase());
} else i f (typeof value === "number") {
/ / v a l u e : number
console. log("it's a number", value * 2);
}
}
2 장 기 본 형 7 3
다 양 한 형 식 을 사 용 하 는 상 황 에 서 는 u n k n o w n 을 적 절 하 게 활 용 해 문 제 를 일 으 키 지 않 고 코 드
에 서 값 을 전 달 할 수 있 다 . 이 는 a n y 와 비 슷 한 u n k n o w n 의 허 용 성 덕 분 이 다 .
2 . 3 올 바 른 객 체 선 택 하 기
문 제 자 바 스 크 립 트 객 체 를 값 으 로 사 용 하 려 한 다 . 하 지 만 문 제 가 있 다 . 자 바 스 크 립 트 객 체 는 o b j e c t ,
0 b j e c t , { } 라 는 세 가 지 다 른 객 체 형 식 으 로 표 현 할 수 있 기 때 문 이 다 . 어 떤 형 식 을 사 용 해 야 할 까 ?
해 결 객 체 , 함 수 , 배 열 같 은 복 합 형 식 c o m p o u n d t p C 에 는 o b j e c t 를 사 용 한 다 . 그 밖 의 값 은 { } 로
표 현 한 다 .
논 의 타 입 스 크 립 트 는 형 식 을 두 가 지 로 분 류 한 다 . 첫 번 째 는 n u m b e r , b o o l e a n , s t r i n g .
s y m b o l , b i g i n t 와 그 하 위 형 식 을 포 함 하 는 기 본 형 식 ( m i n i n e x 이 다 . 두 번 째 는 객 체 의 하 위 형 식 과
다 른 복 합 형 식 이 나 기 본 형 식 을 합 성 한 복 합 형 식 이 다 . [ 그 림 2 - 1 ] 은 전 체 적 인 형 식 을 보 여 준 다 .
any/unknown
: 기 본 형 식 복 합 형 식 1
Object
n u m b e r
e n u m
string
enum
symbol Array
boolean 마 아 마 다 하
null undefined/void
never
그 림 2 - 1 타 입 스 크 립 트 의 형 식 계 층
7 4 실 무 로 통 하 는 타 입 스 크 립 트
상 황 에 따 라 어 떤 프 로 퍼 티 를 갱 신 하 거 나 안 정 성 을 높 이 거 나 기 본 값 을 전 달 하 지 않 을 때 복 합
형 식 을 사 용 한 다 . 예 를 들 어 새 객 체 를 만 드 는 0 b j e c t . c r e a t e 는 객 체 의 프 로 토 타 입 을 첫 인
수 로 받 는 다 . 이 첫 인 수 는 반 드 시 복 합 형 식 이 어 야 하 며 그 렇 지 않 으 면 자 바 스 크 립 트 코 드 에
서 충 돌 이 발 생 한 다 .
Object. create(2);
1 / T y p e E r r o r 발 생 : O b j e c t 프 로 퍼 티 는 반 드 시 O b j e c t 거 나 n u l L 이 어 야 함
/ / F u n c t i o n . c r e a t e ( ‹ a n o n y m o u s > ° 2
타 입 스 크 립 트 에 서 는 빈 객 체 { } , 0 b j e c t , o b j e c t 라 는 세 가 지 형 식 이 같 은 것 처 럼 보 일 수 있
다 . 복 합 형 식 에 는 무 엇 을 사 용 해 야 할 까 ?
s t r i c t 모 드 나 s t r i c t N u L 1 C h e c k s 가 활 성 화 되 었 다 면 , { } 와 O b j e c t 는 n u L L 이 나 u n d e f i n e d
를 제 외 한 거 의 모 든 값 을 비 슷 하 게 취 급 한 다 .
obj = /.*/;
0 b j e c t 인 터 페 이 스 는 0 b j e c t 프 로 토 타 입 을 갖 는 모 든 값 , 즉 모 든 기 본 형 식 및 복 합 형 식 과
호 환 된 다 .
O b j e c t 는 타 입 스 크 립 트 에 서 정 의 한 인 터 페 이 스 이 며 특 정 기 능 을 수 행 할 수 있 도 록 몇 가 지 요
구 사 항 을 포 함 한 다 . 예 를 들 어 t o s t r i n g ( ) = > s t r i n g 의 시 그 너 처 를 갖 는 t o s t r i n g 메 서 드
와 널 값 이 아 닌 모 든 프 로 퍼 티 는 0 b j e c t 프 로 토 타 입 의 일 부 다 . t o s t r i n g 메 서 드 에 기 존 시 그
너 처 와 호 환 되 지 않 는 메 서 드 를 할 당 하 면 오 류 가 발 생 한 다 .
let okObj: (} = {
toString) {
l e t o b j : { } ; 1 / O b j e c t 와 비 슷 함
obj = 32;
obj = "Hello";
obj = true;
obj = () => { console. log("Hello") };
o b j = u n d e f i n e d ; / / 오 류
o b j = n u l l ; / / 오 류
obj = { name: "Stefan", age: 40 };
obj = [];
2 장 기 본 형 7 5
return false;
}
}; / / 0K
l e t obj: Object = 1
toString() {
return false;
1 / ^ ( ) = > b o o l e a n ' 형 식 은 ' ( ) = > s t r i n g ' 형 식 에 할 당 할 수 없 습 니 다 .
1 / ' b o o l e a n ' 형 식 은 ' s t r i n g ' 형 식 에 할 당 할 수 없 습 니 다 . t s ( 2 3 2 2 )
이 때 문 에 0 b j e c t 는 종 종 혼 동 을 일 으 키 므 로 { } 를 사 용 하 길 추 천 한 다 .
타 입 스 크 립 트 는 소 문 자 로 시 작 하 는 o b j e c t 형 식 도 지 원 한 다 . o b j e c t 는 복 합 형 식 만 지 원 하 며
기 본 형 식 은 지 원 하 지 않 으 므 로 대 부 분 개 발 자 가 원 하 는 객 체 형 식 은 o b j e c t 다 .
let obj: object;
0 b j = 3 2 ; 1 / 오 류
0 b j = " H e l l o " ; / / 오 류
o b j = t r u e ; / / 오 류
obj = () → > { console. log("Hello") };
0 b ] = u n d e t i n e d ; / / 오 류
o b j = n u l l ; / / 오 류
obj = { name: "Stefan" ", age: 40 };
obj = [];
obj = /.*/;
함 수 , 정 규 표 현 식 , 배 열 등 을 포 함 하 지 않 는 형 식 이 필 요 하 다 면 5 장 에 서 설 명 하 는 것 처 럼 이 런
형 식 을 직 접 만 들 면 된 다 .
2 . 4 튜 플 형 식 사 용 하 기
문 제 자 바 스 크 립 트 배 열 에 데 이 터 를 저 장 했 다 . 저 장 된 위 치 에 따 라 데 이 터 형 식 이 정 해 지 므 로 저 장 된 데
순 서 가 바 뀌 면 안 된 다 . 하 지 만 타 입 스 크 립 트 의 형 식 추 론 을 이 용 하 면 원 하 는 작 업 을 쉽 게 구 현
이 터 할 수 없 다 .
7 6 실 무 로 통 하 는 타 입 스 크 립 트
해 결 튜 플 형 식 을 사 용 한 다 .
논 의 복 잡 한 객 체 에 데 이 터 를 저 장 할 때 자 바 스 크 립 트 객 체 와 배 열 을 자 주 사 용 한 다 . 는 P e r s o n 객 체 에 자 료 를 저 장 했 는 데 , 엔 트 리 항 목 과 값 을 저 장 하 는 방 식 도 있 다 .
기 존 에
const person = ["Stefan", 40]; // name age
배 열 에 는 프 로 퍼 티 명 이 필 요 없 는 것 이 장 점 이 다 . 비 구 조 회 ( d e s r c t u r i n g 를 활 용 해 각 요 소 를 변 수
에 저 장 하 면 아 주 쉽 게 고 객 명 을 저 장 할 수 있 다 .
/ / objects. js
1 / 객 체 사 용
const person = {
name: "Stefan",
age: 40,
! !
const { name, age } = person;
console. log(name); / / Stefan
console. log(age); / / 40
const { anotherName = name, anotherAge = age } = person;
console. log(anotherName); / / Stefan
console. log(anotherAge); / / 40
/ / a r r a y s . j s
1 / 배 열 사 용
c o n s t person = ["Stefan", 40]; // namely age
const [name, age] = person;
console. log (name); / / Stefan
console. log(age); / / 40
const [anotherName, anotherAge] = person;
console. log(anotherName); / / Stefan
console. log(anotherAge); / / 40
2 장 기 본 형 7 7
새 로 운 이 름 을 연 속 으 로 할 당 하 는 A P I 가 필 요 할 때 는 배 열 을 이 용 하 면 편 리 하 다 . 이 는 1 0 장 에
서 자 세 히 살 펴 본 다 .
하 지 만 타 입 스 크 립 트 의 형 식 추 론 을 사 용 한 다 면 이 패 턴 을 적 용 하 기 가 조 금 어 렵 다 . 기 본 적 으
로 타 입 스 크 립 트 는 할 당 문 을 통 해 배 열 형 식 을 추 론 한 다 . 배 열 은 보 통 같 은 요 소 를 저 장 하 는
끝 이 정 해 지 지 않 은 컬 렉 션 이 다 .
const person = ["Stefan", 40];
/ / person: (string / number)[]
타 입 스 크 립 트 는 p e r s o n 의 각 요 소 는 문 자 열 이 나 숫 자 이 며 두 요 소 외 에 추 가 로 원 하 는 만 큼
요 소 를 저 장 할 수 있 는 배 열 이 라 판 단 한 다 . 즉 이 를 비 구 조 화 하 면 각 요 소 의 형 식 은 s t r i n g 이
나 n u m b e r 가 된 다 .
const [name, age] = person;
/ / name: string | number
/ / age: s t r i n g | number
이 패 턴 은 자 바 스 크 립 트 에 서 는 아 주 유 용 하 지 만 타 입 스 크 립 트 에 서 는 성 가 신 문 제 를 일 으 킨 다 .
타 입 스 크 립 트 에 서 는 흐 름 제 어 를 이 용 해 실 제 형 식 을 알 수 있 게 도 와 야 하 는 데 , 어 차 피 형 식
은 할 당 시 결 정 되 므 로 이 는 불 필 요 한 과 정 이 기 때 문 이 다 .
타 입 스 크 립 트 를 만 족 시 킬 목 적 으 로 자 바 스 크 립 트 에 추 가 작 업 을 해 야 하 는 상 황 이 라 면 일 반 적
으 로 더 좋 은 방 법 이 있 다 . 튜 플 형 식 을 이 용 하 면 타 입 스 크 립 트 가 배 열 의 형 식 을 더 잘 특 정 할
수 있 다 .
튜 플 은 배 열 에 서 파 생 된 형 식 으 로 동 작 방 법 이 조 금 다 르 다 . 배 열 은 무 제 한 의 요 소 를 저 장 할
수 있 으 며 각 요 소 는 같 은 형 식 ( 물 론 형 식 이 넓 을 수 는 있 음 ) 으 로 이 루 어 지 지 만 , 튜 플 형 식 의
크 기 는 고 정 이 며 각 요 소 에 는 고 유 의 형 식 이 있 다 .
튜 플 형 식 을 얻 으 려 면 애 너 테 이 션 을 추 가 해 야 한 다 .
const person: [string, number] = ["Stefan", 40];
c o n s t n a m e , age] = person;
7 8 실 무 로 통 하 는 타 입 스 크 립 트
/ / name: s t r i n g
/ / age: number
이 렇 게 튜 플 을 만 들 었 다 ! 튜 플 형 식 의 길 이 는 유 한 하 다 . 진 길 이 를 넘 어 서 요 소 를 할 당 하 면 타 입 스 크 립 트 가 즉 길 이 도 형 식 의 일 부 다 . 따 라 서 정 해
오 류 를 일 으 킨 다 .
p e r s o n [ 1 ] = 4 1 ; / / 정 상 !
p e r s o n [ 2 ] = f a l s e ; / / 오 류
1 / ^ - ' f a l s e ' 형 식 은 u n d e f i n e d ' 형 식 에 할 당 할 수 없 습 니 다 . t s ( 2 3 2 2 )
타 입 스 크 립 트 는 또 한 레 이 블 을 튜 플 형 식 에 추 가 할 수 있 게 허 용 한 다 . 편 집 기 와 컴 파 일 러 는 이
메 타 정 보 를 사 용 해 피 드 백 을 제 공 하 므 로 개 발 자 는 각 요 소 의 기 대 형 식 이 무 엇 인 지 명 확 하 게
알 수 있 다 .
type Person = [name: string, age: number];
이 처 럼 튜 플 은 ( 마 치 객 체 가 그 러 하 듯 ) 여 러 분 과 여 러 분 의 동 료 가 코 드 를 이 해 하 는 데 도 움 을
준 다 .
함 수 인 수 의 형 식 애 너 테 이 션 에 도 튜 플 형 식 이 사 용 된 다 . 다 음 함 수 를 살 펴 보 자 .
function hello(name: string, msg: string): void {
1 . . .
}
튜 플 형 식 으 로 다 음 처 럼 구 현 할 수 있 다 .
function hello(...args: [name: string, msg: string]): {
1 . . .
}
원 하 는 방 식 으 로 유 연 하 게 튜 플 을 사 용 할 수 있 다 .
function ha: string, b: string, c: string): void f
/ ...
2 장 기 본 형 7 9
}
1 / 다 음 과 같 음
function ha: string, b: string, ...r: [string]): void {
/ / . . .
}
/ / 다 음 과 같 음
function ha: string, ...r: [string, string]): void {
1 / . . .
}
1 / 다 음 과 같 음
function h(...r: [string, string, string]): void f
.١١.
٠
}
이 를 나 머 지 요 소 『 e s c l e m e n 라 부 르 며 , 함 수 가 거 의 무 한 대 의 인 수 목 록 을 가 질 수 있 음 을 의 미 한
다 . 나 머 지 요 소 를 인 수 의 가 장 마 지 막 요 소 로 사 용 하 면 나 머 지 요 소 가 나 머 지 모 든 인 수 를 흡
수 한 다 . 튜 플 을 이 용 해 함 수 에 적 용 할 요 소 를 모 을 수 있 다 .
const person: [string, number] = ["Stefan", 40];
function hello(...args: [name: string, msg: stringl): {
1 1 . . .
}
hello(...person);
다 양 한 상 황 에 서 튜 플 형 식 을 사 용 할 수 있 다 . 튜 플 을 더 자 세 히 알 고 싶 다 면 7 장 과 1 0 잔 을 참
고 하 자 .
2 . 5 인 터 페 이 스 와 형 식 별 칭 의 차 이 이 해 하 기
문 제 타 입 스 크 립 트 에 서 는 객 체 형 식 을 인 터 페 이 스 와 형 식 별 칭 두 가 지 방 식 중 하 나 로 선 언 한 다 . 어 떤 방
식 을 사 용 해 야 할 까 ?
8 0 실 무 로 통 하 는 타 입 스 크 립 트
해 결 프 로 젝 트 의 경 계 내 에 서 는 형 식 별 칭 을 사 용 하 고 다 른 누 군 가 가 소 비 해 야 할 형 식 에 는
인 터 페 이 스 를 사 용 한 다 .
논 의 지 금 까 지 수 년 간 두 가 지 방 식 중 무 엇 을 사 용 해 야 하 는 지 를 두 고 다 양 한 의 견 이 존 재 했
다 . 하 지 만 이 런 다 양 한 논 의 의 대 부 분 은 시 간 이 지 나 면 서 더 이 상 유 효 하 지 않 게 되 었 다 . 기
존 에 달 랐 던 많 은 부 분 이 점 차 일 치 되 면 서 현 재 는 형 식 별 칭 과 인 터 페 이 스 의 차 이 가 거 의 없 는
수 준 이 기 때 문 이 다 .
다 음 코 드 는 인 터 페 이 스 와 형 식 별 칭 의 표 기 법 이 어 떻 게 다 른 지 보 여 준 다 .
type PersonAsType = {
name: string;
age: number;
address: string[l;
greet): string;
interface PersonAsInterface {
name: string;
age: number;
address: string[];
greet (): string;
}
다 양 한 상 황 에 서 같 은 객 체 를 인 터 페 이 스 와 형 식 별 칭 으 로 모 두 표 현 할 수 있 다 .
• 클 래 스 선 언 구 현
• 객 체 리 터 럴 의 형 식 애 너 테 이 션
• 재 귀 형 식 구 조
하 지 만 둘 사 이 에 중 요 한 차 이 가 존 재 하 는 데 이 때 문 에 예 기 치 않 은 부 작 용 이 발 생 할 수 있 다 .
인 터 페 이 스 는 선 언 합 치 기 t e c d a r a t i o n m e r y i n g 를 지 원 하 지 만 형 식 별 칭 은 이 를 지 원 하 지 않 는 다 . 선
언 합 치 기 를 이 용 하 면 인 터 페 이 스 를 선 언 한 이 후 에 도 프 로 퍼 티 를 추 가 할 수 있 다 .
interface Person {
name: string;
}
2 장 기 본 형 8 1
interface Person {
age: number;
}
// Person { name: string; age: number; }
타 입 스 크 립 트 에 서 는 1 1 b . d . t s 파 일 에 서 이 기 법 을 자 주 사 용 하 는 데 , 덕 분 에 E C M A S c r i p t 버
전 에 기 반 한 새 자 바 스 크 립 트 A P I 에 서 바 뀐 기 능 을 손 쉽 게 추 가 할 수 있 다 . 어 떤 기 능 을 확 장
하 는 상 황 ( 예 를 들 어 W i n d o w ) 에 서 는 더 없 이 유 용 한 기 능 이 다 . 하 지 만 이 외 의 상 황 에 서 는 문
제 를 일 으 킬 가 능 성 이 있 다 .
1 / 웹 폼 에 서 수 집 한 데 이 터
interface FormData {
name: string;
age: number;
address: string[];
}
1 / 이 데 이 터 를 백 엔 드 로 전 송 하 는 함 수
function send(data: FormData) {
c o n s o l e . 1 o g ( d a t a . e n t r i e s ( ) ) 1 / 컴 파 일 됨 !
1 / 하 지 만 런 타 임 에 예 상 치 못 한 충 돌 발 생
}
e n t r i e s ( ) 메 서 드 는 어 디 서 온 걸 까 ? 이 는 D O M A P I 의 일 부 다 ! F o r m D a t a 는 브 라 우 저 A P I
가 제 공 하 는 여 러 인 터 페 이 스 중 하 나 다 . 이 런 인 터 페 이 스 는 전 역 으 로 이 용 할 수 있 으 며 , 자 유
롭 게 확 장 할 수 있 다 . 하 지 만 누 구 도 이 런 일 이 일 어 났 음 을 알 려 주 지 않 는 다 .
물 론 적 당 한 이 름 을 선 택 해 이 문 제 를 어 느 정 도 해 결 할 수 있 겠 지 만 , 여 전 히 전 역 으 로 만 든 모
든 인 터 페 이 스 에 서 문 제 가 발 생 할 가 능 성 이 있 다 . 일 부 의 존 성 은 여 러 분 도 모 르 는 사 이 에 전 역
공 간 에 인 터 페 이 스 를 추 가 할 수 있 기 때 문 이 다 .
인 터 페 이 스 대 신 형 식 별 칭 을 사 용 하 면 이 런 문 제 를 사 전 에 파 악 할 수 있 다 .
type FormData = {
1 / ^ - - ' F o r m D a t a ' 식 별 자 가 중 복 되 었 습 니 다 . t s ( 2 3 0 0 )
name: string;
a g e :
number;
8 2 실 무 로 통 하 는 타 입 스 크 립 트
address: string[];
여 러 분 의 프 로 젝 트 일 부 나 다 른 팀 에 서 개 발 한 프 로 젝 트 를 다 른 사 람 들 이 소 비 할 수 있 도 록 라
이 브 러 리 를 만 드 는 상 황 이 라 면 선 언 합 치 기 를 유 용 하 게 사 용 할 수 있 다 . 인 터 페 이 스 를 정 의 해
애 플 리 케 이 션 을 서 술 할 수 있 으 며 동 시 에 사 용 자 는 현 실 에 이 를 적 용 하 기 때 문 이 다 . 새 모 듈 을
불 러 와 기 능 을 추 가 하 는 플 러 그 인 시 스 템 을 생 각 해 보 자 . 이 런 시 스 템 에 서 선 언 합 치 기 는 놓 치
고 싶 지 않 은 기 능 이 다 .
하 지 만 여 러 분 의 모 듈 경 계 안 에 서 형 식 별 칭 을 사 용 하 면 이 미 정 의 된 형 식 을 우 발 적 으 로 재 사
용 하 거 나 확 장 하 는 일 을 방 지 할 수 있 다 . 다 른 누 군 가 가 이 기 능 을 소 비 하 지 않 을 때 는 형 식 별
칭 을 사 용 한 다 .
성 능
인 터 페 이 스 는 보 통 형 식 별 칭 보 다 평 가 성 능 이 뛰 어 나 므 로 형 식 별 칭 을 사 용 해 야 하 는 지 와 관
련 한 논 쟁 이 존 재 한 다 . 이 는 공 식 타 입 스 크 립 트 위 키 ( h t t p s : / / o r e i l . l y / 8 Y o h p ) 에 서 도 권 장 한
부 분 이 다 . 하 지 만 이 권 고 를 맹 목 적 으 로 받 아 들 일 필 요 는 없 다 .
인 터 페 이 스 는 절 대 종 료 되 지 않 고 다 른 선 언 과 합 쳐 질 가 능 성 이 있 으 므 로 간 단 한 형 식 별 칭 이
인 터 페 이 스 보 다 더 빠 를 수 있 다 . 하 지 만 인 터 페 이 스 는 객 체 형 식 을 미 리 알 수 있 으 므 로 인 터
페 이 스 의 성 능 이 더 좋 을 때 도 있 다 . 타 입 스 크 립 트 팀 의 라 이 언 카 바 나 ( W a n C a n a v a n g h 는 엄 청 난 수
의 인 터 페 이 스 나 형 식 별 칭 을 선 언 한 상 황 ( 카 바 나 의 트 윗 ( h t t p s : / / o r e i l . l y / Y _ 2 0 5 ) 에 따 르 면
약 5 천 개 ) 이 어 야 인 식 할 만 한 성 능 차 이 가 나 타 날 것 으 로 기 대 한 다 .
인 터 페 이 스 나 형 식 별 칭 을 많 이 선 언 했 다 고 해 서 여 러 분 의 타 입 스 크 립 트 코 드 성 능 이 저 하 할
가 능 성 은 거 의 없 다 .
2 장 기 본 형 8 3
2 . 6 함 수 오 버 로 드 정 의 하 기
문 제 여 러 분 의 함 수 A P I 는 매 우 유 연 하 며 문 맥 에 따 라 다 양 한 형 식 을 갖 는 인 수 를 허 용 한 다 . 이 를 한 함
수 시 그 니 처 로 정 의 하 기 는 매 우 어 렵 다 .
해 결 함 수 오 버 로 드 를 사 용 한 다 .
논 의 자 바 스 크 립 트 에 서 는 아 주 유 연 하 게 함 수 인 수 를 취 급 할 수 있 으 며 , 기 본 적 으 로 모 든 종
류 의 매 개 변 수 를 원 하 는 수 만 큼 전 달 할 수 있 다 . 함 수 바 디 에 서 입 력 을 잘 처 리 한 다 면 아 무 문
제 가 발 생 하 지 않 는 다 . 덕 분 에 인 간 공 학 적 인 A P I 를 만 들 수 있 지 만 형 식 을 도 입 하 기 어 려 워 진 다 .
태 스 크 러 너 가 있 다 고 생 각 해 보 자 . t a s k 함 수 에 이 름 , 콜 백 이 나 실 행 할 다 른 태 스 크 목 록 ( 또
는 콜 백 과 목 록 둘 다 ) 을 전 달 해 새 태 스 크 를 만 든 다 . 콜 백 을 실 행 하 기 전 에 태 스 크 목 록 을 실
행 해 야 한 다 .
task("default", ["scripts", "styles"]);
task("scripts", ["lint"], () → > {
1 / . . .
} ) ;
task("styles", () → > {
/ . . .
} ) ;
' 마 치 6 년 전 의 걸 프 G u p 를 보 는 것 같 군 ' 이 라 고 생 각 한 독 자 도 있 을 것 이 다 . 이 A P I 는 아 주 유
연 해 서 문 제 가 발 생 할 여 지 가 거 의 없 다 . 걸 프 가 유 행 한 이 유 도 바 로 이 때 문 이 다 .
이 같 은 함 수 를 형 식 화 하 는 것 은 악 몽 같 은 일 이 다 . 선 택 형 인 수 , 같 은 위 치 에 다 른 형 식 , 유 니
'
언 형 식 이 등 장 하 면 상 황 이 더 복 잡 해 진 다 .
type CallbackFn = () => void;
function task(
name: string, param2: string[] | CallbackFn, param3?: CallbackFn
1 유 니 언 형 식 ( u n i o n t y p e ) 은 다 른 두 형 식 을 하 나 로 합 친 형 식 이 다 ( 자 세 한 내 용 은 3 장 참 조 ) .
8 4 실 무 로 통 하 는 타 입 스 크 립 트
): void {
11..
}
이 코 드 로 기 존 예 제 의 모 든 변 형 함 수 를 대 표 할 수 있 다 . 하 지 만 엄 밀 히 말 해 이 코 드 는 기 존
예 제 에 서 허 용 하 지 않 았 던 조 합 까 지 도 허 용 하 는 문 제 가 있 다 .
task(
"what",
( ) = > {
console. 1og("Two callbacks?");
} ,
( ) = > {
console. log("That's not supported, but the types say yes!");
}
다 행 히 타 입 스 크 립 트 의 함 수 오 버 로 드 f u n c t o n o v e n o a d 를 이 용 해 이 문 제 를 해 결 할 수 있 다 . 오 버 로
드 란 이 름 에 서 알 수 있 듯 이 , 이 는 다 른 프 로 그 래 밍 언 어 에 서 제 공 하 는 기 능 과 비 슷 한 개 념 ( 같
은 정 의 , 다 른 동 작 ) 이 다 . 다 만 타 입 스 크 립 트 는 다 른 프 로 그 래 밍 언 어 와 달 리 함 수 오 버 로 드 가
형 식 시 스 템 수 준 에 서 만 동 작 하 며 실 제 구 현 에 는 아 무 효 과 가 없 다 는 점 이 다 르 다 .
모 든 가 능 한 시 나 리 오 를 각 각 의 함 수 시 그 니 처 로 정 의 한 다 . 마 지 막 함 수 시 그 니 처 는 실 제 구 현
으 로 대 신 한 다 .
/ / 형 식 시 스 템 의 형 식
function task(name: string, dependencies: string[]): void;
function task(name: string, callback: CallbackFn): void
function task(name: string, dependencies: string[], callback: CallbackFn): void
1 / 실 제 구 현
function task(
) : void {
name: string, param2: string[] | CallbackFn, param3?: CallbackFn
/ . . .
}
2 장 기 본 형 8 5
몇 가 지 눈 여 겨 봐 야 할 부 분 이 있 다 .
첫 째 , 타 입 스 크 립 트 는 실 제 구 현 이 전 의 선 언 을 가 능 한 형 식 으 로 만 인 식 한 다 는 점 이 다 . 실 제
구 현 시 그 니 처 가 관 련 이 있 으 면 이 를 복 제 한 다 .
또 한 실 제 구 현 함 수 시 그 니 처 는 아 무 의 미 가 없 을 수 있 다 . 타 입 스 크 립 트 는 오 버 로 드 를 구 현
시 그 니 처 로 구 현 할 수 있 는 지 검 사 한 다 .
두 가 지 반 환 형 식 이 존 재 한 다 면 어 떻 게 든 구 현 함 수 의 입 력 과 출 력 이 기 존 시 그 니 처 와 일 치 하
도 록 해 야 한 다 .
function fn(input: number): number
function fn(input: string): string
function fn(input: number | string): number | string {
if(typeof input === "number") {
r e t u r n " t h i s also works";
} else 1
return 1337;
}
}
const typeSaysNumberButItsAString = fn(12);
const typeSaysStringButItsANumber = fn("Hello world");
구 현 시 그 니 처 는 보 통 아 주 넓 은 형 식 을 가 진 다 . 이 는 어 차 피 자 바 스 크 립 트 에 서 도 수 많 은 검 사
를 해 야 하 기 때 문 이 다 . 이 런 상 황 에 서 는 특 별 히 주 의 를 기 울 여 야 함 을 환 기 한 다 는 점 에 서 유
용 하 다 .
현 을 할 당 한 다 . 오 버 로 드 된 함 수 를 자 체 형 식 으 로 만 들 어 야 한 다 면 이 들 을 애 너 테 이 션 에 사 용 한 다 음 여 러 구
다 음 처 럼 형 식 별 칭 을 만 들 수 있 다 .
type TaskFn = {
(name: string, dependencies: s t r i n g [ ] ) : void;
(name: string, callback: CallbackFn): void;
(name: string, dependencies: string[], callback: CallbackFn): void;
}
즉 실 제 구 현 정 의 는 필 요 없 으 며 형 식 시 스 템 오 버 로 드 만 있 으 면 된 다 .
8 6 실 무 로 통 하 는 타 입 스 크 립 트
2 . 7 t h i s 매 개 변 수 의 형 식 정 의 하 기
문 제 t h i s 의 형 식 을 가 정 하 는 콜 백 함 수 를 구 현 해 야 하 는 데 함 수 를 구 현 하 는 시 점 에 서 는 t h i s 를 어 떻 게
정 의 해 야 할 지 모 르 겠 다 .
해 결 t h i s 매 개 변 수 를 함 수 시 그 니 처 의 시 작 부 분 에 정 의 한 다 .
논 의 자 바 스 크 립 트 에 익 숙 하 지 않 은 개 발 자 라 면 끊 임 없 이 변 하 는 t h i s 객 체 포 인 터 속 성 때
문 에 혼 란 스 러 울 때 가 많 을 것 이 다 .
자 바 스 크 립 트 코 드 를 구 현 하 다 보 면 ' 이 런 말 도 안 되 는 일 이 ! 라 고 소 리 치 고 싶 을 때 가 있 다 . 언 제 나
그 렇 듯 t h i s 가 무 엇 을 가 리 키 는 지 알 수 가 없 다 .
익 명 의 자 바 스 크 립 트 개 발 자
여 러 분 의 배 경 이 클 래 스 기 반 객 체 지 행 언 어 라 면 해 당 언 어 에 서 t h i s 는 항 상 클 래 스 의 인 스
턴 스 를 가 리 킨 다 . 자 바 스 크 립 트 에 서 는 상 황 이 완 전 다 르 지 만 그 렇 다 고 이 해 하 기 가 아 주 어 렵
지 는 않 다 . 타 입 스 크 립 트 를 이 용 하 면 t h i s 의 활 용 범 위 를 확 실 하 게 할 수 있 다 .
함 수 영 역 내 에 서 t h i s 는 함 수 에 연 결 된 객 체 나 값 을 가 리 킨 다 . 일 반 객 체 에 서 t h i s 는 아 주 단
순 하 다 .
const author = {
name: "Stefan",
1 / 단 축 함 수
hi() {
console. log(this.name);
} ,
3;
a u t h o r . h i ( ) ; 1 / ' S t e f a n ' 출 력
하 지 만 자 바 스 크 립 트 에 서 함 수 는 값 이 므 로 다 른 문 맥 으 로 연 결 될 수 있 는 데 , 이 때 t h i s 의 값
이 바 뀐 다 .
2 장 기 본 형 8 7
const author = 1
name: "Stefan",
function h i ) {
console. log(this.name);
}
const p e t = {
name: "Finni",
kind: "Cat",
hi. apply(pet); / / " F i n n i "
hi.call(author); // "Stefan" A*
const boundHi = hi.bind (author);
b o u n d H i ( ) ; 1 / " S t e f a n " 출 력
일 반 함 수 대 신 화 살 표 함 수 를 사 용 해 도 t h i s 의 의 미 가 달 라 진 다 .
class Person {
constructor (name) {
this. name = name;
}
h i ) {
console. log(this.name);
}
hi_ timeout) {
setTimeout (function() {
console. log(this.name);
3, 0);
}
hi_timeout_arrow() {
setTimeout (() => {
console. log(this.name);
3, 0);
}
88 실 무 로 통 하 는 타 입 스 크 립 트
}
const person = new Person ("Stefan")
p e r s o n . h i ( ) ; 1 / " S t e f a n " 출 력
person.hi.
_ t i m e o u t ( ) ; 1 / " u n d e f i n e d " 출 력
person.hi_timeout_arrow(); // "Stefan" A≥
타 입 스 크 립 트 에 서 는 t h i s 와 관 련 한 정 보 를 더 얻 을 수 있 으 며 t h i s 매 개 변 수 형 식 으 로 t h i s
를 파 악 할 수 있 다 .
다 음 예 제 를 살 펴 보 자 . D O M A P I 로 버 튼 요 소 에 접 근 했 고 이 벤 트 리 스 너 를 요 소 에 추 가 했 다 .
콜 백 함 수 에 서 t h i s 는 H T M L B u t t o n E l e m e n t 형 식 이 다 ( 따 라 서 c L a s s L i s t 프 로 퍼 티 에 접 근 할
수 있 다 ) .
const button = document.querySelector ("button");
button? .addEventListener("click" ', function) i
this.classList.toggle("clicked");
} ) ;
여 기 서 a d d E v e n t L i s t e n e r 함 수 가 t h i s 정 보 를 제 공 한 다 . 리 팩 토 링 단 계 에 서 함 수 를 추 출 한
다 면 기 능 은 유 지 되 겠 지 만 t h i s 의 컨 텍 스 트 가 없 어 지 므 로 오 류 가 발 생 한 다 .
const button = document. querySelector ("button");
button.addEventListener("click", handleToggle);
function handleToggle() {
this.classList.toggle("clicked");
1 / ^ 형 식 애 너 테 이 션 이 없 으 므 로 ' t h i s ' 의 형 식 을
1 / ' a n y ' 로 추 론 함
}
타 입 스 크 립 트 에 t h i s 가 어 떤 형 식 인 지 알 려 주 면 문 제 가 해 결 된 다 . 다 음 처 럼 t h i s 라 는 첫 번
째 매 개 변 수 를 함 수 시 그 니 처 에 추 가 한 다 .
const button = document. querySelector ("button");
button? .addEventListener("click"', handleToggle);
2 장 기 본 형 8 9
function handleToggle(this: HTMLButtonElement) {
this.classList.toggle("clicked");
}
컴 파 일 이 진 행 되 면 t h i s 인 수 는 제 거 된 다 . 타 입 스 크 립 트 는 t h i s 가 H T M L B u t t o n E L e m e n t 라 는
사 실 을 알 수 있 다 . 이 제 다 른 컨 텍 스 트 에 서 h a n d L e T o g g L e 을 사 용 하 면 오 류 가 발 생 한 다 .
handleToggle();
1 / ^ ' v o i d ' 형 식 의 ' t h i s ' 컨 텍 스 트 를 메 서 드 의 ' H T M L B u t t o n E l e m e n t '
1 / 형 식 ' t h i s ' 에 할 당 할 수 없 습 니 다 . t s ( 2 6 8 4 )
t h i s 를 H T L M B u t t o n E l e m e n t 의 상 위 형 식 u p e r y p e 인 H T L M E l e m e n t 로 정 의 하 면 h a n d l e T o g g l e
함 수 의 유 용 성 이 개 선 된 다 .
const button = document. querySelector ("button");
button?.addEventListener("click", handleToggle);
const input = document.querySelector("input");
input?.addEventListener ("click", handleToggle);
function handleToggle(this: HTMLElement) {
this.classList.toggle("clicked");
}
t h i s 매 개 변 수 형 식 을 사 용 할 때 함 수 형 식 에 서 t h i s 매 개 변 수 를 추 출 하 거 나 제 거 하 는 두 개
의 헬 퍼 형 식 이 필 요 할 것 이 다 .
function handleToggle(this: HTMLElement) {
this.classList.toggle("clicked");
}
type ToggleFn = typeof handleToggle;
/ / ( t h i s : HTMLElement) => void
type WithoutThis = OmitThisParameter<ToggleFn>
/ @ = > void
type ToggleFnThis = ThisParameterType<ToggleFn>
/ / HTMLElement
9 0 실 무 로 통 하 는 타 입 스 크 립 트
클 래 스 와 객 체 는 더 다 양 한 t h i s 헬 퍼 형 식 을 포 함 한 다 . 자 세 한 내 용 은 4 . 8 절 과 1 1 . 8 절 을 참
고 하 자 .
2 . 8 심 볼 사 용 하 기
문 제 s y m b o 1 형 식 에 서 오 류 메 시 지 가 발 생 했 는 데 s y m b o 1 이 란 무 엇 이 며 어 떻 게 사 용 하 는 걸 까 ? .
해 결 고 유 하 며 반 복 할 수 없 는 객 체 프 로 퍼 티 에 s y m b o l 을 사 용 한 다 . S y m b o l 은 민 감 한 정 보
를 저 장 하 고 접 근 할 때 유 용 하 다 .
논 의 S y m b o l 은 자 바 스 크 립 트 와 타 입 스 크 립 트 의 기 본 형 이 므 로 객 체 프 로 퍼 티 에 사 용 할 수 있
다 . s y m b o l 에 는 n u m b e r , s t r i n g 등 과 는 다 른 독 특 한 특 징 들 이 있 다 .
S y m b o l ( ) 팩 토 리 함 수 로 심 볼 을 만 든 다 .
const TITLE = Symbol('title')
S y m b o l 은 생 성 자 함 수 가 없 다 . 매 개 변 수 는 선 택 적 서 술 자 다 . 팩 토 리 함 수 를 호 출 할 때 새 로 만
든 심 볼 의 고 윳 값 이 T I T L E 에 할 당 된 다 . 이 렇 게 만 들 어 진 심 볼 은 다 른 모 든 심 볼 과 구 별 되 는 고
유 의 값 이 며 심 지 어 서 술 자 가 같 은 심 볼 과 도 겹 치 지 않 는 다 .
const ACADEMIC_TITLE = Symbol('title')
const ARTICLE_TITLE = Symbol('title')
if(ACADEMIC_TITLE === ARTICLE_TITLE) {
1 / 이 조 건 은 절 대 참 이 성 립 하 지 않 는 다 .
d e s c r i p t i o n 은 개 발 시 심 볼 정 보 를 제 공 하 는 데 도 움 을 준 다 .
console. log(ACADEMIC_TITLE.description) / / title
console. 1og(ACADEMIC_TITLE.toString()) // Symbol(title)
2 장 기 본 형 9 1
상 호 배 타 적 이 고 고 유 한 값 을 비 교 할 때 심 볼 을 유 용 하 게 활 용 한 다 . 런 타 임 스 위 치 나 모 드 비
교 코 드 를 살 펴 보 자 .
/ / 아 주 나 쁜 로 깅 프 레 임 워 크
const LEVEL_INFO = Symbol(' INFO')
const LEVEL_DEBUG = Symbol ('DEBUG')
const LEVEL_WARN = Symbol ('WARN ')
const LEVEL_ERROR = Symbol ('ERROR')
function log(msg, level) {
switch(level) {
case LEVEL_WARN:
console.warn(msg); break
case LEVEL_ERROR:
console.error(msg); break;
case LEVEL_DEBUG:
console. log(msg);
debugger; break;
case LEVEL_INFO:
console. 1og(msg);
}
}
반 복 할 수 없 는 프 로 퍼 티 , 즉 직 렬 화 할 수 있 는 프 로 퍼 티 에 도 심 볼 을 사 용 한 다 .
const print = Symbol('print')
const user = {
name: 'Stefan',
age: 40,
[print]: function) &
console. log(${this.name} i s ${this.age} years old*)
}
}
JSON.stringify(user) / / { name: 'Stefan',
, age: 40 }
user [print]() / / Stefan is 40 years old
전 역 심 볼 레 지 스 트 리 를 이 용 해 전 체 애 플 리 케 이 션 에 서 토 큰 을 접 근 한 다 .
9 2 실 무 로 통 하 는 타 입 스 크 립 트
S y m b o l . f o r ( ' p r i n t ' ) 1 / 전 역 심 볼 만 들 기
const user = 1
name: 'Stefan',
age: 37,
/ / 전 역 심 볼 사 용
[Symbol. for('print')]: function) {
console.log('${this.name} is ${this.age} years old\*)
}
}
첫 번 째 S y m b o L . f o r 호 출 코 드 로 심 볼 을 만 들 고 두 번 째 호 출 은 같 은 심 볼 을 사 용 한 다 . 변 수
에 저 장 된 심 볼 값 의 키 를 알 고 싶 으 면 S y m b o L . k e y F o r ( ) 를 사 용 한 다 . •
const usedSymbolKeys = []
function extendObject(obj, symbol, value) {
/ / 대 체 무 슨 심 볼 일 까 ?
const key = Symbol. keyFor (symbol)
1 / 심 볼 을 저 장 하 는 것 이 좋 겠 군 .
if(lusedSymbolKeys.includes(key)) {
usedSymbolKeys.push(key)
}
obj [symbol] = value
}
1 / 모 두 가 져 오 자 .
function printAllValues (obj) {
usedSymbolKeys. forEach(key → > {
console. log(obj[Symbol. for(key)])
} )
}
작 업 완 료 !
타 입 스 크 립 트 는 심 볼 을 완 벽 지 원 하 며 형 식 시 스 템 의 주 요 시 민 으 로 대 우 한 다 . s y m b o l 은 모 든
가 능 한 심 볼 의 형 식 애 너 테 이 션 이 다 . 다 음 코 드 블 록 에 서 e x t e n d o b j e c t 함 수 를 살 펴 보 자 . 어
떤 객 체 를 모 든 심 볼 로 확 장 할 수 있 도 록 하 는 코 드 에 s y m b o l 형 식 을 사 용 한 다 .
2 장 기 본 형 9 3
const sym = Symbol('foo')
function extendObject(obj: any, sym: symbol, value: any) {
obj [sym] = value
}
e x t e n d o b j e c t ( { } , s y m , 4 2 ) 1 / 모 든 심 볼 과 동 작 함
u n i q u e s y m b o l 이 라 는 서 브 형 식 도 있 다 . u n i q u e s y m b o l 은 c o n s t 선 언 에 서 만 사 용 할 수 있
으 며 오 직 해 당 심 볼 만 을 참 조 한 다 .
u n i q u e S y m b o l L 은 타 입 스 크 립 트 의 명 목 상 형 식 이 며 , 자 바 스 크 립 트 의 명 목 상 값 과 같 다 .
t y p e o f 연 산 자 로 u n i q u e S y m b o l 의 형 식 을 확 인 한 다 .
const PROD: unique symbol = Symbol('Production mode')
const DEV: unique symbol = Symbol('Development mode")
function showWarning(msg: string, mode: typeof DEV | typeof PROD) {
I . . .
}
집 필 시 점 에 는 u n i q u e s y m b o l 이 타 입 스 크 립 트 의 구 조 적 형 식 시 스 템 의 유 일 한 명 목 적 형 식
이 다 .
심 볼 은 타 입 스 크 립 트 와 자 바 스 크 립 트 의 명 목 상 형 식 과 불 투 명 형 식 의 교 차 점 에 위 치 한 다 . 심
볼 은 런 타 임 시 명 목 상 형 식 검 사 를 하 는 데 필 요 한 형 식 이 다 .
2 . 9 값 과 형 식 네 임 스 페 이 스 이 해 하 기
문 제 어 떤 이 름 은 형 식 애 너 테 이 션 으 로 사 용 할 수 있 지 만 , 어 떤 이 름 은 사 용 할 수 없 어 서 혼 란 스 럽 다 .
해 결 형 식 과 값 의 네 임 스 페 이 스 를 배 우 고 어 떤 이 름 이 어 떤 네 임 스 페 이 스 에 있 는 지 이 해 한 다 .
9 4 실 무 로 통 하 는 타 입 스 크 립 트
논 의 타 입 스 크 립 트 는 자 바 스 크 립 트 의 상 위 집 합 , 즉 기 존 에 존 재 하 는 언 어 에 기 능 을 추 가 한
다 . 앞 으 로 여 러 분 은 어 떤 부 분 이 자 바 스 크 립 트 고 어 떤 부 분 이 타 입 스 크 립 트 인 지 배 운 다 .
일 반 자 바 스 크 립 트 에 형 식 이 라 는 계 층 을 추 가 한 것 이 타 입 스 크 립 트 라 고 생 각 하 면 좋 다 . 이 형
식 계 층 이 포 함 하 는 메 타 정 보 는 자 바 스 크 립 트 런 타 임 이 자 바 스 크 립 트 코 드 를 실 행 하 기 전 에
제 거 된 다 . 일 부 사 람 은 타 입 스 크 립 트 코 드 컴 파 일 과 정 을 ' 자 바 스 크 립 트 코 드 로 회 귀 ' 라 고 표 현
한 다 .
자 바 스 크 립 트 위 에 계 층 을 추 가 했 다 는 의 미 는 다 른 문 법 으 로 다 른 계 층 에 기 여 한 다 는 의 미
기 도 하 다 . f u n c t i o n 이 나 c o n s t 가 자 바 스 크 립 트 파 트 에 서 는 이 름 을 만 들 지 만 , t y p e 정 의 나
i n t e r f a c e 는 타 입 스 크 립 트 계 층 의 이 름 에 기 여 한 다 .
1 / C o l l e c t i o n 은 타 입 스 크 립 트 영 역 에 있 다 ! - - > 형 식
type Collection = Person[]
1 / p r i n t C o l l e c t i o n 는 자 바 스 크 립 트 영 역 에 있 다 ! - - > 값
function printCollection(coll: Collection) {
console. log(...coll.entries)
}
선 언 은 형 식 네 임 스 페 이 스 y p e n a n e s p i c 나 값 네 임 스 페 이 스 w a l u e n a m e s p a c 에 기 여 한 다 고 도 말 한 다 . 형
식 계 층 이 값 계 층 위 에 존 재 하 므 로 형 식 계 층 에 서 는 값 을 소 비 할 수 있 지 만 반 대 는 불 가 능 하
다 . 이 를 표 현 하 는 키 워 드 가 따 로 있 다 .
1 / 값
const person = 1
name: "Stefan",
1 / 형 식
type Person = typeof person;
t y p e o f 는 아 래 의 값 계 층 을 이 용 해 형 식 계 층 에 서 사 용 할 수 있 는 이 름 을 만 든 다 .
형 식 과 값 을 동 시 에 만 드 는 형 식 정 의 가 등 장 하 면 조 금 당 황 스 러 울 것 이 다 . 예 를 들 어 클 래 스
는 타 입 스 크 립 트 에 서 는 형 식 으 로 , 자 바 스 크 립 트 에 서 는 값 으 로 동 시 에 사 용 할 수 있 다 .
2 장 기 본 형 9 5
1 / 선 언
class Person {
name: string;
constructor(n: string) {
this. name = n;
}
}
1 / 값 으 로 사 용
const person = new Person ("Stefan");
1 / 형 식 으 로 사 용
type Collection = Person[];
function printPersons(coll: Collection) {
//...
}
이 름 규 칙 을 알 면 코 드 를 조 금 더 쉽 게 이 해 할 수 있 다 . 보 통 클 래 스 , 형 식 , 인 터 페 이 스 , 이 넘 어 n u m
등 은 첫 글 자 를 대 문 자 로 표 기 한 다 . 이 들 은 값 을 만 드 는 상 황 에 서 동 시 에 형 식 에 도 기 여 한 다 .
규 칙 을 그 대 로 따 르 자 면 리 액 트 앱 의 함 수 명 을 대 문 자 로 구 현 하 는 상 황 이 발 생 한 다 .
이 름 을 형 식 과 값 으 로 사 용 하 는 데 익 숙 한 독 자 라 면 ' 여 러 분 의 형 식 은 ( 는 ) 값 을 참 조 하 지 만 , 여
기 서 는 형 식 으 로 사 용 되 고 있 습 니 다 . t s ( 2 7 4 9 ) ' 라 는 비 교 적 유 명 한 오 류 가 발 생 했 을 때 무 슨
일 이 일 어 나 는 지 당 황 할 수 있 다 .
type PersonProps = {
name: string;
3;
}
function Person({ name }: PersonProps) {
/ . . .
type PrintComponentProps = {
collection: Person[]; ^ - ' P e r s o n ' 은 ( 는 ) 값 을 참 조 하 지 만 , 여 기 서 는
형 식 으 로 사 용 되 고 있 습 니 다 . ' t y p e o f P e r s o n ' 을 ( 를 )
사 용 하 시 겠 습 니 까 ? t s ( 2 7 4 9 )
}
96 실 무 로 통 하 는 타 입 스 크 립 트
이 부 분 에 서 타 입 스 크 립 트 가 잘 이 해 되 지 않 을 수 있 다 . 형 식 이 란 무 엇 이 며 , 값 은 무 엇 이 고 왜
이 둘 을 분 리 해 야 하 는 가 ? 왜 이 들 은 다 른 프 로 그 래 밍 언 어 에 서 처 럼 자 연 스 럽 게 동 작 하 지 않
는 가 ? 문 득 여 러 분 은 t y p e o f 호 출 과 I n s t a n c e T y p e 헬 퍼 형 식 을 맞 닥 뜨 린 다 . 이 시 점 에 여 러
분 은 클 래 스 가 실 제 로 는 두 형 식 에 기 여 하 고 있 음 을 깨 닫 는 다 ( 1 1 참 고 ) .
클 래 스 는 형 식 네 임 스 페 이 스 의 이 름 에 기 여 하 는 데 , 타 입 스 크 립 트 는 구 조 적 형 식 시 스 템 이 므 로
모 양 이 같 은 값 은 해 당 클 래 스 의 인 스 턴 스 로 간 주 한 다 . 따 라 서 다 음 은 유 효 한 코 드 다 .
class Person {
name: s t r i n g ;
constructor(n: string) {
this. name = n;
}
}
}
function printPerson(person: Person) {
console. log (person.name);
printPerson(new P e r s o n ( " S t e f a n ) ;
p r i n t P e r s o n ( { n a m e : " S t e f a n " } ) ; 1 / 이 코 드 도 정 상
하 지 만 값 네 임 스 페 이 스 에 서 동 작 하 는 i n s t a n c e o f 검 사 를 이 용 하 면 객 체 의 모 양 과 같 은 프 로
퍼 티 를 가 졌 을 지 몰 라 도 클 래 스 의 실 제 인 스 턴 스 가 아 니 므 로 동 작 하 지 않 는 다 .
function checkPerson(person: Person) {
return person instanceof Person;
}
checkPerson (new Person("Stefan")); / / true
checkPerson({ name: "Stefan" }); // false
따 라 서 무 엇 이 형 식 에 기 여 하 고 무 엇 이 값 에 기 여 하 는 지 이 해 하 는 것 이 중 요 하 다 . [ 표 2 - 1 ] 은
타 입 스 크 립 트 문 서 에 서 제 공 하 는 내 용 으 로 , 형 식 과 값 의 기 여 를 한 눈 에 잘 보 여 준 다 .
2 장 기 본 형 9 7
선 언 형 식 형 식 값
클 래 스 X
이 넘
인 터 페 이 스 X
형 식 별 칭 X
함 수 X
변 수 X
표 2 - 1 형 식 네 임 스 페 이 스 와 값 네 임 스 페 이 스
함 수 , 인 터 페 이 스 ( 또 는 형 식 별 칭 . 2 . 5 절 참 고 ) , 변 수 를 처 음 부 터 이 용 한 다 면 무 엇 을 어 디 에
사 용 해 야 할 지 감 을 잡 을 수 있 다 . 클 래 스 를 이 용 한 다 면 이 에 따 르 는 암 묵 적 의 미 를 조 금 더 길
게 생 각 해 보 자 .
9 8 실 무 로 통 하 는 타 입 스 크 립 트
