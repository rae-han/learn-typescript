# 5장 조건부 형식

## 5.1 복잡한 함수 시그니처 관리하기
**문제** 인수 조합이 많은 함수를 오버로드만으로 관리하려니 유지보수가 힘들다.

**해결** 조건부 타입을 활용하여 입력에 따라 반환 타입이 달라지도록 정의하고, 구현부는 단일 함수로 유지한다.

```ts
type ElementList = {
  addClass(className: string): ElementList;
  removeClass(className: string): ElementList;
  on(event: string, callback: (ev: Event) => void): ElementList;
  length: number;
  [index: number]: HTMLElement;
};

type MethodName = keyof Pick<ElementList, "addClass" | "removeClass" | "on">;

type MethodSignature<M extends MethodName> = ElementList[M];

function invoke<M extends MethodName>(
  list: ElementList,
  method: M,
  ...args: Parameters<MethodSignature<M>>
): ReturnType<MethodSignature<M>> {
  const fn = list[method];
  return fn.apply(list, args);
}
```

이 구조는 조건부 타입과 내장 유틸리티 타입이 어떻게 맞물리는지 보여 준다.

- `MethodName`은 메서드 이름만 뽑아낸 유니온이다. `Pick`으로 필요한 메서드만 남기고 `keyof`로 키 이름을 추출했다.
- `MethodSignature<M>`는 `ElementList[M]`을 통해 특정 메서드의 시그니처(파라미터/반환 타입)를 그대로 가져온다. 타입스크립트는 인덱스 접근을 타입 위치에서도 허용한다.
- `Parameters<...>`와 `ReturnType<...>`은 조건부 타입으로 구현된 대표적인 내장 유틸리티다. 덕분에 제네릭 함수를 선언하면서도 기존 메서드 시그니처를 정확히 재사용할 수 있다.
- 호출부에서는 `invoke(list, "addClass", "active")`처럼 메서드 이름과 인수가 자연스럽게 연결된다. 존재하지 않는 메서드나 잘못된 인수를 전달하면 타입 오류가 발생한다.

이 패턴을 활용하면 “대상 객체에서 메서드 이름과 인수를 추론해 호출하는” API를 깔끔하게 설계할 수 있다.


## 5.2 never로 거르기
**문제** 유니온에서 특정 멤버만 선택하거나 제외하고 싶다.

**해결** 조건부 타입과 `never`를 활용해 원하는 멤버만 남긴다. `Extract`, `Exclude` 같은 내장 유틸리티가 동일한 원리로 동작한다.

```ts
type ElementList = {
  addClass: (className: string) => ElementList;
  removeClass: (className: string) => ElementList;
  on: (event: string, callback: (ev: Event) => void) => ElementList;
  length: number;
  [index: number]: HTMLElement;
};

type MethodNames = keyof ElementList;
type OnlyMethods = Exclude<MethodNames, number | "length">; // 문자열 메서드만 남김
```

`never`는 조건부 타입에서 필터 역할을 한다. `Exclude` 구현을 살펴보면 구조를 쉽게 이해할 수 있다.

```ts
type Exclude<T, U> = T extends U ? never : T;
```

`T`가 유니온이라면 조건부 타입이 분배되어 각 멤버가 `U`에 할당 가능한지 검사한다. 조건을 만족하는 멤버는 `never`로 바뀌고, 최종 유니온에서는 제거된다. 반대로 `Extract<T, U>`는 조건을 만족하는 멤버만 남긴다.

이 원리를 알면 필요한 필터를 직접 만들 수도 있다. 예를 들어 숫자 인덱스를 제외한 메서드만 남기고 싶다면 `Exclude<keyof ElementList, number>`로 충분하다. 더 복잡한 조건이 필요하면 `T[K] extends (...args: any) => any ? K : never` 같은 매핑 타입을 결합하면 된다.

## 5.3 kind로 요소 그룹화하기
**문제** 구별된 유니온을 키로 갖는 레코드를 만들면 값 타입이 지나치게 넓어진다.

**해결** `Extract`와 매핑 타입을 조합해 구별자에 대응하는 정확한 타입을 찾는다.

```ts
type ToyBase = {
  name: string;
  minimumAge: number;
};

type BoardGame = ToyBase & { kind: "boardgame"; players: number };
type Puzzle = ToyBase & { kind: "puzzle"; pieces: number };
type Doll = ToyBase & { kind: "doll"; material: "plush" | "plastic" };

type Toy = BoardGame | Puzzle | Doll;

type GroupedToys = {
  [K in Toy["kind"]]?: Extract<Toy, { kind: K }>[];
};

function groupToys(toys: Toy[]): GroupedToys {
  const groups: GroupedToys = {};
  for (const toy of toys) {
    const list = (groups[toy.kind] ??= []);
    list.push(toy);
  }
  return groups;
}
```

여기서는 세 가지 테크닉이 결합되어 있다.

- `Toy["kind"]`는 유니온 멤버의 `kind` 값을 모은 문자열 리터럴 유니온이다. 매핑 타입의 키로 사용하면 가능한 케이스를 모두 다룰 수 있다.
- `Extract<Toy, { kind: K }>`는 `Toy` 유니온에서 `kind`가 특정 값인 멤버만 걸러낸다. 조건부 타입이 내부적으로 `never`를 사용해 불필요한 멤버를 제거한다.
- 매핑 타입에서 `?`를 붙여 선택 속성으로 만든 덕분에 실제로 등장하지 않은 그룹은 `undefined` 대신 아예 속성이 없는 상태로 남는다.

이 방식은 상태별로 데이터를 모으거나, REST 응답을 타입 안전하게 분류할 때도 동일하게 적용할 수 있다.


## 5.4 특정 객체 프로퍼티 삭제하기
**문제** 프로퍼티 이름이 아니라 타입을 기준으로 속성을 제거하고 싶다.

**해결** 매핑 타입에서 `as` 절과 조건부 타입을 사용해 원하는 타입만 유지한다.

```ts
type Remove<T, U> = {
  [K in keyof T as T[K] extends U | undefined ? never : K]: T[K];
};

type Person = {
  name: string;
  age: number;
  profession?: string;
  greeting(): string;
};

type SerializablePerson = Remove<Person, Function>;
// { name: string; age: number; profession?: string | undefined }
```

`Remove` 타입의 핵심은 매핑 타입에서 키 재매핑(`as`)과 조건부 타입을 결합했다는 점이다.

- `T[K] extends U | undefined` 조건이 참이면 해당 키를 `never`로 매핑한다. 매핑 타입에서 `never` 키는 제거된다.
- `U`에 `undefined`를 포함시킨 이유는 선택 속성(`profession?`)을 제거할 때 `undefined`까지 함께 비교하기 위함이다. 필요에 따라 조건식을 조정해 다른 기준을 적용할 수 있다.
- 반대로 특정 타입만 추출하고 싶다면 `Pick<T, { [K in keyof T]: T[K] extends U ? K : never }[keyof T]>` 같은 패턴을 사용한다. 내장 유틸리티 `PickByValue`가 없는 이유를 직접 구현해 볼 수 있는 구조다.

조건부 타입과 매핑 타입을 조합하면 “형식 기반 리팩터링”을 손쉽게 자동화할 수 있다.

## 5.5 조건식에서 형식 추론하기
**문제** 중첩 객체를 직렬화하면서 함수는 제거하고, 중첩 객체 안의 함수도 재귀적으로 제거하고 싶다.

**해결** 재귀 조건부 타입과 `infer`를 이용해 직렬화 결과 타입을 정의하고, 구현은 이 타입을 만족하도록 작성한다.

```ts
type RemoveFunctions<T> = {
  [K in keyof T as T[K] extends Function ? never : K]: T[K];
};

type Serialize<T> = {
  [K in keyof RemoveFunctions<T>]: RemoveFunctions<T>[K] extends object
    ? Serialize<RemoveFunctions<T>[K]>
    : RemoveFunctions<T>[K];
};

class Serializer {
  serialize<T>(obj: T): Serialize<T> {
    const result: Record<string, unknown> = {};
    for (const key in obj) {
      const value = (obj as any)[key];
      if (typeof value === "function") continue;
      result[key] = typeof value === "object" && value
        ? this.serialize(value)
        : value;
    }
    return result as Serialize<T>;
  }
}
```

이 예제에서는 조건부 타입의 세부 기술을 모두 활용한다.

- `RemoveFunctions<T>`는 매핑 타입과 조건부 타입을 이용해 함수형 프로퍼티를 제거한다. `T[K] extends Function`이 참이면 키가 `never`가 되어 제외된다.
- `Serialize<T>`는 재귀적으로 동작한다. 속성 값이 객체(`object`)라면 다시 `Serialize`를 호출하고, 그렇지 않으면 그대로 유지한다. 이때 `RemoveFunctions<T>[K]`가 다시 평가되므로 중첩된 함수도 자동으로 제거된다.
- 런타임 구현에서는 타입 정보를 잃지 않도록 `value` 검사 순서를 타입 정의와 맞춘다. `typeof value === "object" && value` 체크가 있어서 `null`을 재귀 호출하지 않는 점에 주의한다.
- 반환 시 `as Serialize<T>` 어서션이 필요한 이유는 타입스크립트가 런타임 분기를 충분히 이해하지 못하기 때문이다. 구현과 타입 정의가 동기화되어 있다면 안전한 어서션으로 볼 수 있다.

조건부 타입과 재귀 매핑 타입을 조합하면 직렬화·검증 같은 반복 패턴을 타입 수준에서 선제적으로 모델링할 수 있다.
