# **5. 조건부 형식**

- 조건부 형식은 **하위 형식 검사를 통해 타입을 선택**하므로, 오버로드 없이도 API 계약을 정밀하게 표현한다.
- 분배(distribution)와 `never`를 조합하면 **유니온 멤버를 필터링**하는 강력한 도구가 된다.
- `Extract`, `Select`, `Remove`, `infer` 같은 패턴을 알면 **자료구조를 원하는 모습으로 재구성**하거나 **런타임 전략(직렬화 등)**과 일치시키기 쉽다.
- 과도한 추상화는 구현을 어렵게 만들 수 있으니, **필요한 범위만큼 조건부 형식을 사용하고 목표를 주기적으로 점검**한다.

---

# **5.1 복잡한 함수 시그니처 관리하기**

## **상황**
- `createLabel`처럼 입력이 숫자·문자열·기존 라벨 객체까지 섞여 있는 함수는 오버로드가 기하급수적으로 늘어난다.
- 오버로드는 호출부에서는 편하지만, 구현부에서는 **가장 넓은 타입**만 허용돼 재사용이 어렵다.

## **핵심 아이디어**
- 입력 제약은 제네릭 매개변수 `T extends number | string | StringLabel | NumberLabel`로 묶고,
- 조건부 형식 `GetLabel<T>`로 **입력에 맞춰 반환 타입을 매핑**한다.

```ts
type GetLabel<T> = T extends string | StringLabel
  ? StringLabel
  : T extends number | NumberLabel
  ? NumberLabel
  : never;

function createLabel<T extends number | string | StringLabel | NumberLabel>(
  input: T,
): GetLabel<T> {
  if (typeof input === 'number') {
    return { id: input } as GetLabel<T>;
  }
  if (typeof input === 'string') {
    return { name: input } as GetLabel<T>;
  }
  if ('id' in input) {
    return { id: input.id } as GetLabel<T>;
  }
  return { name: input.name } as GetLabel<T>;
}
```

## **비교 포인트**
- **기존**: 세부 시그니처 + 구현 시그니처까지 최소 네 번 선언.
- **조건부 형식**: 호출부는 `T`로 정확한 타입을 얻고, 구현부는 단일 지점에서 모든 케이스 처리.
- 필요하면 외부 API용 오버로드에 위 제네릭 시그니처를 추가해 **호출 가독성**과 **구현 단순성**을 모두 챙길 수 있다.

---

# **5.2 `never`로 유니온 걸러내기**

## **상황**
- `ElementList`는 숫자 인덱스와 문자열 메서드를 모두 노출한다. 프록시로 숫자 접근을 막고 싶지만, 타입은 여전히 `[index: number]`를 허용한다.

## **핵심 아이디어**
- 분배 조건부 형식을 활용한 `JustStrings<T>`로 **문자열 키만 남기고 나머지를 `never`로 제거**한다.

```ts
type JustStrings<T> = T extends string ? T : never;

type SafeAccess = Pick<ElementList, JustStrings<keyof ElementList>>;
```

## **결과**
- `SafeAccess`에는 `addClass | removeClass | on | length`만 남아 숫자 인덱스가 사라진다.
- 프록시 반환 타입을 `SafeAccess`로 선언하면 `safeAccessCollection[0]`이 즉시 컴파일 오류가 된다.
- 핵심은 **분배 + `never`**: `never`가 유니온에서 사라지므로 필터링 효과를 낸다.

---

# **5.3 `kind`로 요소 그룹화하기**

## **문제**
- `Toy['kind']`를 키로 사용하는 `Group` 매핑 타입은 모든 그룹 값을 `Toy[]`로만 추론한다.

## **조건부 추출 패턴**
- `Extract<T, U>`는 조건부 형식의 분배를 이용해 **유니온에서 특정 멤버만 추출**한다.
- 이를 매핑 타입에 넣어 키별로 알맞은 하위 타입 배열을 돌려준다.

```ts
type Group<Collection extends Record<string, any>, Selector extends keyof Collection> = {
  [K in Collection[Selector]]: Extract<
    Collection,
    { [P in Selector]: K }
  >[];
};

type GroupedToys = Partial<Group<Toy, 'kind'>>;
```

## **효과 & 구현 팁**
- `GroupedToys.boardgame`은 `BoardGame[]`으로 좁혀져 분기 없이도 올바른 속성에 접근 가능.
- 런타임에서는
  1. `switch` 분기로 그룹 배열을 직접 초기화하거나,
  2. 타입 어서션으로 공용 경로를 유지하거나,
  3. 제네릭 헬퍼 `assign(groups, toy.kind, toy)`로 타입 관계를 캡슐화할 수 있다.
- 추상화 수준을 상황에 맞춰 선택하되, **타입·구현 동기화**가 최우선이다.

---

# **5.4 특정 프로퍼티 제거·선택하기**

## **목표**
- 프로퍼티 이름이 아니라 **프로퍼티 타입**을 기준으로 객체를 부분 선택(혹은 제거)하고 싶다.

## **패턴**
- 매핑된 타입에서 `as` 절과 조건부 형식을 결합하면 키를 동적으로 필터링할 수 있다.

```ts
type Select<O, T> = {
  [K in keyof O as O[K] extends T | undefined ? K : never]: O[K];
};

type Remove<O, T> = {
  [K in keyof O as O[K] extends T | undefined ? never : K]: O[K];
};
```

## **활용 예시**
- `Select<Person, string>` → 문자열(선택형 포함) 속성만 남긴다.
- `Remove<User, Function>` → 직렬화 가능한 속성만 선택해 네트워크 전송에 사용.
- `String` 내장 객체에도 적용하면 **숫자를 반환하는 메서드 목록** 등을 추론할 수 있다.

---

# **5.5 조건식에서 형식 추론하기**

## **문제**
- 복합 객체를 직렬화할 때 **함수는 제거**하고, 대신 `serialize()` 메서드가 있으면 그 결과를 사용하고 싶다.
- 타입 정의와 런타임 구현이 어긋나면 안전하지 않다.

## **재귀 조건부 형식 + `infer`**

```ts
type Serialize<T> = T extends { serialize(): infer R }
  ? R
  : NestSerialization<Remove<T, Function>>;

type NestSerialization<T> = {
  [K in keyof T]: T[K] extends object ? Serialize<T[K]> : T[K];
};
```

- 먼저 `Remove<T, Function>`으로 함수 프로퍼티를 제거하고, `NestSerialization`으로 중첩 객체에 재귀 적용.
- `T`가 `serialize(): ...`를 구현했다면 `infer R`로 반환 타입을 잡아 그대로 사용한다.

## **구현 스케치**
```ts
class Serializer {
  serialize<T>(obj: T): Serialize<T> {
    if (
      typeof obj === 'object' &&
      obj &&
      'serialize' in obj &&
      typeof obj.serialize === 'function'
    ) {
      return obj.serialize();
    }
    const ret: Record<string, any> = {};
    for (const key in obj) {
      const value = obj[key];
      if (typeof value === 'object') ret[key] = this.serialize(value);
      else if (typeof value !== 'function') ret[key] = value;
    }
    return ret as Serialize<T>;
  }
}
```

## **핵심 비교**
- 런타임 로직과 타입 정의가 서로를 뒷받침하므로, **직렬화 결과가 자동으로 정확한 타입**으로 추론된다.
- `serialize()` 메서드가 있는 모델은 결과 타입을 스스로 제공해, 재귀 직렬화보다 더 구체적인 타입을 노출할 수 있다.

---

> 조건부 형식을 익히면 “값 세계”의 분기 로직을 “타입 세계”에 그대로 투영할 수 있다. 하지만 필요한 범위를 넘어 추상화하면 오히려 유지보수가 어려워지니, **명확한 목표와 테스트로 균형을 맞추자.**
