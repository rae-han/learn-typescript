4 장 제 네 릭 1 5 5
4 . 1 함 수 시 그 니 처 일 반 화 하 기
문 제 같 은 기 능 을 수 행 하 지 만 서 로 다 른 형 식 ( 호 환 되 지 않 음 ) 을 취 급 하 는 두 함 수 가 있 다 .
해 결 제 네 릭 으 로 이 들 의 동 작 을 일 반 화 한 다 .
논 의 다 양 한 언 어 파 일 ( 예 : 자 막 ) 을 객 체 로 저 장 하 는 애 플 리 케 이 션 을 구 현 한 다 고 가 정 하 자 .
객 체 의 키 는 언 어 코 드 이 고 U R L 은 값 이 다 . A P I 나 사 용 자 인 터 페 이 스 에 서 s t r i n g 형 식 으 로
넘 어 온 언 어 코 드 를 이 용 해 언 어 파 일 을 불 러 온 다 . 언 어 코 드 가 올 바 르 고 유 효 한 지 검 사 하 는
i s L a n g u a g e A v a i l a b l e 이 라 는 함 수 를 추 가 했 다 . 이 함 수 는 i n 검 사 를 수 행 하 며 형 식 찬 반 형 으
로 올 바 른 형 식 을 설 정 한 다 .
type Languages = {
de: URL;
en: URL;
pt: URL;
es: URL;
fr: URL;
ja: URL;
function isLanguageAvailable(
collection: Languages,
lang: string
): lang is keyof Languages {
return lang in collection;
}
function loadLanguage(collection: Languages, lang: string) {
i f (isLanguageAvailable(collection, lang)) {
/ / l a n g e keyof Languages
c o l l e c t i o n [ l a n g ] ; 1 / 접 근 가 능 !
}
}
이 번 에 는 같 은 애 플 리 케 이 션 에 다 른 시 나 리 오 를 적 용 해 완 전 히 다 른 파 일 을 불 러 온 다 . 오 디
오 , 비 디 오 , c a n v a s 에 포 함 된 여 러 요 소 등 메 타 데 이 터 를 H T M L 요 소 로 불 러 온 다 . 모 든 요 소
1 5 6 실 무 로 통 하 는 타 입 스 크 립 트
는 애 플 리 케 이 션 에 이 미 존 재 하 지 만 , A P I 입 력 에 따 라 알 맞 은 요 소 를 선 택 해 야 한 다 . 이 번 에
도 선 택 결 과 는 s t r i n g 으 로 전 달 되 며 i s E L e m e n t A L L o w e d 라 는 함 수 를 추 가 해 입 력 이 실 제 로
A l L o w e d E l e m e n t s 컬 렉 션 의 유 효 한 키 인 지 검 사 한 다 .
type AllowedElements = {
video: HTMLVideoElement;
audio: HTMLAudioElement;
canvas: HTMLCanvasElement;
};
function isElementAllowed (
collection: AllowedElements,
elem: string
): elem i s keyof AllowedElements {
return elem in collection;
}
function selectElement(collection: AllowedElements, elem: string) {
if (isElementAllowed (collection, elem)) {
/ / eleme keyof AllowedElements
c o l L e c t i o n [ e l e m ] ; 1 / 접 근 가 능
}
자 세 히 살 펴 보 지 않 아 도 두 시 나 리 오 가 아 주 비 슷 함 을 알 수 있 다 . 형 식 보 호 함 수 가 특 히 눈 에
띈 다 . 모 든 형 식 정 보 를 없 애 고 이 름 을 비 슷 하 게 바 꾸 면 이 둘 은 사 실 같 은 기 능 을 수 행 하 는 함
수 임 을 알 수 있 다 .
function isAvailable(obj, key) {
return key in obj;
}
두 함 수 가 존 재 하 는 이 유 는 형 식 정 보 때 문 이 다 . 즉 , 입 력 매 개 변 수 가 아 니 라 형 식 찬 반 형 때 문
에 이 두 함 수 가 존 재 한 다 . 두 가 지 시 나 리 오 에 서 특 정 한 K e y o f 형 식 으 로 어 서 션 을 수 행 해 입
력 매 개 변 수 정 보 를 구 체 화 할 수 있 다 .
두 입 력 형 식 은 완 전 히 다 르 며 겹 치 는 부 분 이 없 다 는 점 이 문 제 다 . 빈 객 체 를 제 외 하 면 k e y o f
형 식 으 로 얻 을 수 있 는 정 보 가 없 다 . K e y o f { } 는 실 제 로 n e v e r 다 .
4 장 제 네 릭 1 5 7
하 지 만 여 기 서 일 부 형 식 정 보 를 일 반 화 할 수 있 다 . 우 리 는 객 체 의 첫 입 력 매 개 변 수 는 객 체 임
을 안 다 . 그 리 고 두 번 째 매 개 변 수 는 프 로 퍼 티 키 다 . 이 가 정 이 t r u e 라 면 첫 번 째 매 개 변 수 는
두 번 째 매 개 변 수 의 키 를 포 함 하 는 객 체 임 을 알 수 있 다 .
0 b j 라 불 리 는 제 네 릭 형 식 매 개 변 수 & e n e r i e t y p e p a r a m e t e r 를 i s A v a i L a b L e 에 꺾 쇠 괄 호 로 추 가 해 함 수
를 일 반 화 한 다 . 이 0 b j 는 i s A V a i l a b l e 을 사 용 할 때 실 제 형 식 으 로 대 체 될 플 레 이 스 홀 더 다 .
( A l L o w e d E L e m e n t s 나 L a n g u a g e s 를 사 용 할 때 처 럼 ) 이 제 네 릭 형 식 매 개 변 수 를 사 용 하 고 형
식 찬 반 형 을 추 가 한 다 . 0 b j 는 모 든 형 식 으 로 치 환 할 수 있 으 므 로 k e y 는 모 든 가 능 한 프 로 퍼 티
키 ( s t r i n g , S y m b o l , n u m b e r ) 를 포 함 해 야 한 다 .
function isAvailable<Obj>
o b j : Obj,
key: string | number | symbol
): key is keyof obj {
return key in obj;
}
function loadLanguage(collection: Languages, lang: string) 1
if (isAvailable(collection, lang)) 1
/ / lange keyof Languages
c o l l e c t i o n [ l a n g ] ; 1 / 접 근 가 능 !
}
}
function selectElement(collection: AllowedElements, elem: string) {
i f (isAvailable(collection, elem)) 1
/ / e l e m ® keyof AllowedElements
c o l l e c t i o n [ e l e m ] ; 1 / 접 근 가 능
}
}
0 b j 를 어 떤 형 식 으 로 바 꾸 든 문 제 없 이 동 작 하 는 함 수 를 만 들 었 다 . 이 함 수 는 자 바 스 크 립 트 처
럼 동 작 한 다 ! 이 함 수 하 나 만 으 로 도 같 은 기 능 을 제 공 하 면 서 올 바 른 형 식 정 보 를 얻 는 다 . 유 연
성 을 희 생 하 지 않 고 도 인 덱 스 접 근 이 안 전 해 졌 다 .
가 장 좋 은 점 은 뭘 까 ? i s A v a i l a b l e 을 마 치 형 식 이 없 는 자 바 스 크 립 트 함 수 처 럼 사 용 할 수 있
다 는 부 분 이 다 . 타 입 스 크 립 트 는 사 용 처 에 따 라 제 네 릭 형 식 매 개 변 수 를 추 론 하 기 때 문 이 다 . 하
지 만 여 기 에 는 약 간 의 부 작 용 이 따 른 다 . 4 . 3 절 에 서 이 를 자 세 히 살 펴 본 다 .
1 5 8 실 무 로 통 하 는 타 입 스 크 립 트
4 . 2 관 련 된 함 수 인 수 만 들 기
문 제 첫 번 째 매 개 변 수 에 의 존 하 는 두 번 째 함 수 매 개 변 수 를 구 현 한 다 .
해 결 각 매 개 변 수 를 제 네 릭 형 식 으 로 만 들 고 제 네 릭 제 약 s e n e n i c c o n s t r a i l 을 이 용 해 둘 간 의 관 계 를
만 든 다 .
논 의 4 . 1 절 과 비 슷 하 게 , 이 애 플 리 케 이 션 은 L a n g u a g e s 라 는 형 식 의 객 체 에 자 막 목 록 을 저 장
한 다 . L a n g u a g e s 는 언 어 코 드 를 가 리 키 는 키 와 U R L 을 포 함 하 는 값 의 집 합 이 다 .
type Languages = {
de: URL;
en: URL;
pt: URL;
es: URL;
fr: URL;
ja: URL;
const languages: Languages = { /_ ... _/ };
애 플 리 케 이 션 에 이 런 목 록 이 여 럿 존 재 하 는 데 , 이 를 U R L L i s t 라 는 형 식 으 로 추 상 화 할 수 있 다 .
다 음 처 럼 인 덱 스 시 그 니 처 는 아 무 s t r i n g 키 를 가 질 수 있 게 허 용 한 다 .
type URLList = {
[x: string]: URL;
U R L L i s t 는 L a n g u a g e s 의 상 위 형 식 이 다 . L a n g u a g e s 의 모 든 값 은 U R L L i s t 이 지 만 , U R L L i s t
의 모 든 값 은 L a n g u a g e s 가 아 니 다 . U R L L i s t 를 이 용 해 목 록 에 서 특 정 항 목 을 불 러 오 는
f e t c h F i l e 함 수 를 구 현 할 수 있 다 .
function fetchFile(urls: URLList, key: string) {
return fetch(urls[key]). then((res) → > res.json());
}
4 장 제 네 릭 1 5 9
const de = fetchFile(languages, "de");
const i t = fetchFile(languages, "it");
k e y 의 형 식 이 s t r i n g 이 라 서 너 무 많 은 항 목 을 허 용 한 다 는 점 이 문 제 다 . 예 를 들 어 이 탈 리 아
자 막 이 정 의 되 지 않 은 상 황 임 에 도 f e t c h F i l e 은 " i t " 라 는 이 탈 리 아 언 어 코 드 로 항 목 을 불 러
올 수 있 게 허 용 한 다 . U R L L i s t 에 서 특 정 항 목 을 불 러 올 때 어 떤 키 에 접 근 할 수 있 는 지 알 면
정 말 좋 을 것 이 다 .
넓 은 형 식 의 제 네 릭 을 정 의 하 고 제 네 릭 제 약 을 설 정 해 U R L L i s t 의 하 위 형 식 만 을 전 달 하 게 할
수 있 다 . 이 덕 분 에 함 수 시 그 니 처 는 기 존 과 아 주 비 슷 하 게 유 지 하 면 서 도 대 치 된 형 식 을 더
쉽 게 처 리 할 수 있 다 . U R L L i s t 의 하 위 형 식 인 제 네 릭 형 식 매 개 변 수 L i s t 를 정 의 하 고 k e y 를
k e y o f L i s t 로 설 정 한 다 .
function fetchFile‹List extends URLList>(urls: List, key: keyof List) {
return fetch(urls[key]). then((res) → res.json());
}
const de = fetchFile (languages, "de");
const it = fetchFile(languages, "it");
1 / ' " i t " ' 형 식 의 인 수 는 ' k e y o f L a n g u a g e s ' 형 식 의 매 개 변 수 에 할 당 될 수
1 / 없 습 니 다 . t s ( 2 3 4 5 )
이 제 f e t c h F i l e 을 호 출 하 면 L i s t 가 실 제 형 식 으 로 치 환 되 므 로 " i t " 는 L a n g u a g e s 의 일 부 가
아 님 이 밝 혀 진 다 . 이 런 식 으 로 타 입 스 크 립 트 는 오 타 가 있 거 나 선 택 한 요 소 가 데 이 터 형 식 의 일
부 가 아 니 면 바 로 알 려 준 다 .
많 은 키 를 불 러 오 는 상 황 에 서 도 잘 동 작 한 다 . 같 은 제 약 조 건 으 로 같 은 효 과 를 거 둔 다 .
function fetchFiles‹List extends URLList>(urls: List, keys: (keyof List)[]) {
const els = keys.map((el) =>
fetch(urls[el])
•then((res) → > res.json())
•then ((data) => [el, data])
);
return els;
}
1 6 0 실 무 로 통 하 는 타 입 스 크 립 트
const de*and_fr = fetchFiles(languages, ["de", "fr"]); / / Promise<any[]≥[]
const de_and_it = fetchFiles(languages, ["de"' , " i t " ] ) ;
/ /
1 / ' " i t " ' 형 식 은 ' k e y o f L a n g u a g e s ' 형 식 에 할 당 할 수 없 습 니 다 . t s ( 2 3 2 2 )
키 를 첫 번 째 요 소 로 , 데 이 터 를 두 번 째 요 소 로 하 는 튜 플 에 결 과 를 저 장 한 다 . 하 지 만 결 과 를
가 져 올 땐 a n y [ ] 로 해 석 되 는 P r o m i s e 의 배 열 형 식 이 다 . f e t c h 는 불 러 온 데 이 터 가 무 엇 인 지
알 려 주 지 않 으 므 로 d a t a 는 넓 은 a n y 형 식 이 되 어 k e y o f L i s t 인 e l 을 삼 켜 버 린 다 .
하 지 만 현 재 시 점 에 서 더 많 은 정 보 를 알 게 되 었 다 . 예 를 들 어 [ e l , d a t a ] 는 배 열 이 아 니 라
튜 플 이 라 는 사 실 을 알 았 다 . 2 . 4 절 에 서 살 펴 봤 듯 이 배 열 과 튜 플 간 에 작 지 만 중 요 한 차 이 가 있
다 . 결 과 를 튜 플 형 식 으 로 설 정 하 면 결 값 에 서 더 많 은 정 보 를 얻 는 다 .
function fetchFiles‹List extends URLList>(urls: List, keys: (keyof List)[]) {
const e l s = keys.map ( ( e l ) =>
fetch(urls[el])
.then((res) → > res.json())
•then ((data) → {
const entry: [keyof List, any] = [el, datal;
r e t u r n entry;
) ;
} )
return els;
}
const de_and_fr = fetchFiles(Languages, ["de", "fr"]);
f e t c h F i l e s 는 [ k e y o f L i s t , a n y ] 의 P r o m i s e 배 열 을 반 환 한 다 . 따 라 서 L a n g u a g e s 를 L i s t
로 대 체 하 는 순 간 가 능 한 키 는 언 어 코 드 뿐 임 을 안 다 .
하 지 만 한 가 지 문 제 가 있 다 . 앞 선 예 제 코 드 의 d e * a n d \_ f r 에 서 사 용 할 수 있 는 언 어 는 오 직 독
일 어 와 프 랑 스 어 뿐 이 었 지 만 , 영 어 를 확 인 하 려 하 더 라 도 컴 파 일 러 는 이 를 경 고 하 지 않 는 다 . 이
조 건 은 항 상 거 짓 을 반 환 하 므 로 컴 파 일 러 는 이 를 경 고 해 주 어 야 한 다 .
for (const result of de_and_fr) {
i f (result[0] === "en") {
1 / 영 어 ?
4 장 제 네 릭 1 6 1
}
}
이 번 에 도 형 식 이 너 무 넓 다 는 문 제 가 있 다 . K e y o f L i s t 가 s t r i n g 보 다 좁 기 는 하 지 만 , 모 든
키 를 더 작 은 집 합 으 로 대 치 할 수 있 다 .
다 음 처 럼 같 은 과 정 을 반 복 해 야 한 다 .
1 제 네 릭 형 식 매 개 변 수 를 만 든 다 .
2 새 로 만 든 제 네 릭 형 식 매 개 변 수 에 넓 은 형 식 을 제 약 으 로 설 정 한 다 .
3 함 수 시 그 니 처 에 서 실 제 형 식 을 대 체 하 는 형 식 으 로 이 매 개 변 수 를 사 용 한 다 .
마 찬 가 지 로 k e y o f L i s t 도 하 위 형 식 " d e " i " f r " 로 바 꿀 수 있 다 .
function fetchFiles<List extends URLList, Keys extends keyof List>(
urls: List,
keys: Keys[]
) {
const els = keys.map ((el) =>
fetch(urls[el])
•then (res) => res. json())
•then ((data) → {
const entry: [Keys, any] = [el, data];
return entry;
} )
return els;
}
const de_and_fr = fetchFiles(Languages, ["de", "fr"]);
제 네 릭 형 식 매 개 변 수 간 의 관 계 를 설 정 할 수 있 다 는 점 에 주 목 하 자 . 두 번 째 형 식 매 개 변 수 는
첫 번 째 제 네 릭 형 식 매 개 변 수 에 제 약 을 받 을 수 있 다 . 이 를 이 용 하 면 실 젯 값 으 로 치 환 하 기 전
까 지 매 우 구 체 적 으 로 형 식 을 좁 힐 수 있 다 . 결 과 는 어 떨 까 ? 코 드 어 디 서 든 형 식 에 가 능 한 값
을 알 수 있 다 . 따 라 서 영 어 를 불 러 오 라 고 요 청 하 지 않 았 다 면 영 어 언 어 를 검 사 할 필 요 가 전 혀
없 음 을 알 수 있 다 .
1 6 2 실 무 로 통 하 는 타 입 스 크 립 트
for (const entry of de_and_fr) {
const result = await entry;
if (result[0] === "en") {
1 / ' " d e " : " f r " ' 이 ( 가 ) ' " e n " ' 과 ( 와 ) 겹 치 지 않 으 므 로
1 / 이 비 교 는 의 도 하 지 않 은 것 같 습 니 다 . t s ( 2 3 6 7 )
}
}
0 번 째 위 치 에 어 떤 언 어 가 있 는 지 확 인 하 는 이 전 코 드 만 그 대 로 유 지 했 다 .
지 금 까 지 제 네 릭 인 스 턴 스 화 & o n e r i e i n s t a n t a t o n 는 살 펴 보 지 않 았 다 . 지 금 까 지 는 형 식 매 개 변 수 가 사
용 처 에 따 라 실 젯 값 으 로 치 환 되 도 록 했 다 ( 형 식 추 론 과 비 슷 한 방 식 ) . 하 지 만 애 너 테 이 션 으 로
직 접 형 식 매 개 변 수 를 치 환 할 수 있 어 야 한 다 .
const de \_and_ja = fetchFiles<Languages, "ja" | "de"> (Languages, ["de"]);
이 형 식 은 독 일 어 자 막 만 불 러 오 겠 지 만 , 일 본 어 자 막 도 포 함 될 수 있 음 을 알 려 준 다 . 4 . 4 절 에 서
이 를 더 자 세 히 설 명 한 다 .
4 . 3 a n y 와 u n k n o w n 제 거 하 기
문 제 제 네 릭 형 식 매 개 변 수 , a n y 와 u n k n o w n 모 두 아 주 넓 은 값 의 집 합 을 가 리 킨 다 . 언 제 , 무 엇 을 사 용 해
야 할 까 ?
해 결 결 과 적 으 로 실 제 형 식 을 얻 을 때 는 제 네 릭 형 식 매 개 변 수 를 사 용 한 다 . a n y 와 u n k n o w n
중 무 엇 을 사 용 할 지 는 2 . 2 절 을 참 고 하 자 .
논 의 제 네 릭 을 사 용 할 때 , 마 치 제 네 릭 이 a n y , u n k n o w n 을 대 체 하 는 듯 이 보 일 수 있 다 .
i d e n t i t y 라 는 함 수 를 예 로 살 펴 보 자 . 이 함 수 는 입 력 매 개 변 수 로 전 달 된 값 을 반 환 하 는 동 작
을 수 행 한 다 .
function identity(value: any): any {
return value;
}
4 장 제 네 릭 1 6 3
let a = identity("Hello!");
l e t b = identity(false);
let c = identity(2);
모 든 형 식 의 값 을 인 수 로 받 으 며 반 환 값 도 모 든 형 식 이 될 수 있 다 . 안 전 하 게 프 로 퍼 티 에 접 근
하 도 록 u n k n o w n 을 이 용 해 함 수 를 재 구 현 할 수 있 다 .
function identity(value: unknown): unknown {
return value;
}
let a = identity("Hello!");
let b = identity(false);
let c = identity(2);
a n y 와 u n k n o w n 을 혼 합 해 서 사 용 할 수 있 는 데 , 결 과 는 항 상 같 다 . 즉 , 형 식 정 보 가 사 라 진 다 .
우 리 가 정 의 한 대 로 반 환 값 의 형 식 이 결 정 된 다 .
이 번 에 는 a n y 나 u n k n o w n 대 신 제 네 릭 으 로 함 수 를 구 현 해 보 자 . 이 제 네 릭 형 식 은 동 시 에 반 환
형 식 이 기 도 하 다 .
function identity<T>(t: T): T {
return t ;
}
이 제 실 제 로 값 을 전 달 하 면 서 타 입 스 크 립 트 가 어 떻 게 형 식 을 추 론 하 는 지 살 펴 보 자 .
let a = identity("Hello!"); / / a z string
let b = identity(2000); / / bE number
let c = identity({ a: 2 }); / / c z { a: number }
l e t 대 신 c o n s t 를 사 용 하 면 결 과 가 조 금 달 라 진 다 .
const a = identity("Hello!"); // a "Hello!"
const b = identity(2000); / bE 2000
const c = identity({ a: 2 }); / / c z { a: number }
1 6 4 실 무 로 통 하 는 타 입 스 크 립 트
타 입 스 크 립 트 는 기 본 형 식 이 있 을 때 제 네 릭 형 식 매 개 변 수 를 실 제 형 식 으 로 치 환 한 다 . 조 금
더 복 잡 한 시 나 리 오 에 서 이 기 능 을 제 대 로 활 용 할 수 있 다 .
제 네 릭 으 로 제 네 릭 형 식 매 개 변 수 에 애 너 테 이 션 을 추 가 할 수 있 다 .
const a = identity<string>("Hello!"); // a string
const b = identity<number >(2000); / / b e number
const c = identity<{ a: 2 }(La: 2 }); / / c E La: 2 }
3 . 4 절 에 서 배 운 내 용 이 떠 오 르 는 독 자 도 있 을 것 이 다 . 매 우 유 사 하 지 만 제 네 릭 형 식 매 개 변 수
가 함 수 에 포 함 된 다 는 점 이 다 르 다
제 약 이 없 는 제 네 릭 을 사 용 한 다 면 모 든 형 식 과 호 환 되 는 값 을 처 리 하 는 함 수 를 구 현 할 수 있
다 . 함 수 내 부 에 서 이 들 은 u n k n o w n 처 럼 동 작 하 므 로 형 식 을 좁 히 도 록 보 호 할 수 있 다 . 가 장 큰
차 이 점 은 함 수 를 일 단 사 용 하 면 제 네 릭 이 실 제 형 식 으 로 치 환 되 는 데 , 이 때 형 식 관 련 정 보 를
잃 지 않 고 유 지 한 다 는 사 실 이 다 .
따 라 서 모 든 것 을 허 용 하 는 상 황 보 다 더 깔 끔 하 게 형 식 을 활 용 할 수 있 다 . p a i r s 함 수 는 두 개
의 인 수 를 받 아 튜 플 을 만 든 다 .
function pairs(a: unknown, b: unknown): [unknown, unknown] {
return [a, b];
}
const a = pairs(1, "1"); // [unknown, unknown]
제 네 릭 형 식 매 개 변 수 를 이 용 하 면 멋 진 튜 플 형 식 을 얻 을 수 있 다 .
function pairs<T, U>(a: T, b: U): [T, U] {
return [a, b];
}
const b = pairs(1, "1"); // [number, string]
이 제 네 릭 형 식 매 개 변 수 를 이 용 해 튜 플 의 모 든 요 소 가 같 은 형 식 이 되 도 록 강 제 할 수 있 다 .
4 장 제 네 릭 1 6 5
function pairs<T>(a: T, b: T): [T, T] €
return [a, b];
}
const c = pairs(1, "1");
/
1 / ' s t r i n g ' 형 식 의 인 수 는 ' n u m b e r ' 형 식 의 매 개 변 수 에 할 당 될 수
1 / 없 습 니 다 . t s ( 2 3 4 5 )
그 러 면 제 네 릭 을 모 든 곳 에 서 사 용 해 야 할 까 ? 그 럴 필 요 는 없 다 . 이 장 의 예 제 는 올 바 른 때 적
절 한 형 식 을 얻 는 상 황 을 가 정 했 을 뿐 이 다 . 더 넓 은 값 의 집 합 으 로 만 족 하 고 이 와 호 환 되 는 하
위 형 식 을 사 용 할 수 있 다 면 굳 이 제 네 릭 을 사 용 할 필 요 가 없 다 . 코 드 에 a n y 와 u n k n o w n 이 있
다 면 어 떤 시 점 에 실 제 형 식 이 필 요 한 지 생 각 해 보 자 . 이 들 대 신 제 네 릭 형 식 매 개 변 수 를 사 용
하 면 도 움 이 될 수 있 다 .
4 . 4 제 네 릭 인 스 턴 스 화 이 해 하 기
문 제 제 네 릭 형 식 이 어 떻 게 실 제 형 식 으 로 치 환 되 는 지 는 이 해 했 다 . 하 지 만 때 로 는 " F o o 를 제 약 사 항 B a r
형 식 에 할 당 할 수 있 지 만 다 른 하 위 형 식 의 제 약 B a z 로 인 스 턴 스 화 할 수 없 습 니 다 같 은 이 해 하 기
힘 든 오 류 가 발 생 할 수 있 다 .
해 결 제 네 릭 형 식 의 값 은 명 시 적 또 는 암 묵 적 으 로 다 양 한 하 위 형 식 으 로 치 환 될 수 있 음 을 기
억 하 자 . 따 라 서 하 위 형 식 도 포 용 할 수 있 는 코 드 를 구 현 한 다 .
논 의 애 플 리 케 이 션 에 필 터 로 직 을 만 들 었 다 . " a n d " i " o r " 등 의 콤 비 네 이 터 를 이 용 해 다 양
한 필 터 규 칙 을 조 합 할 수 있 다 . 콤 비 네 이 터 필 터 c o m i b i n a t o r i a l f i l e r 의 결 과 를 이 용 해 일 반 필 터 규 칙
을 연 결 할 수 도 있 다 .
type FilterRule = {
field: string; operator: string;
value: any;
3;
1 6 6 실 무 로 통 하 는 타 입 스 크 립 트
type CombinatorialFilter = {
combinator: "and" | "or";
rules: FilterRule[];
};
type ChainedFilter = {
rules: (CombinatorialFilter | FilterRule)l;
type Filter = CombinatorialFilter | ChainedFilter;
이 제 제 공 된 필 터 를 받 아 모 든 규 칙 을 재 설 정 하 는 r e s e t 이 라 는 함 수 를 구 현 한 다 . 형 식 가 드 를
이 용 해 C o m b i n a t o r i a l F i l t e r 와 C h a i n e d F i l t e r 를 구 분 한 다 .
function reset(filter: Filter): Filter {
if ("combinator" in filter) {
/ / fi l t e r CombinatorialFilter
return { combinator: "and", rules: [] };
}
/ / fi l t e r ChainedFilter
return { rules: [] };
}
const filter: CombinatorialFilter = { rules: [], combinator: "or" };
const resetFilter = reset(filter); / / resetFilter& Filter
기 능 은 제 대 로 동 작 하 지 만 r e s e t 의 반 환 형 식 이 너 무 넓 다 . C o m b i n a t o r i a L F i l t e r 를 전 달 하
면 r e s e t 은 C o m b i n a t o r i a L F i L t e r 를 반 환 해 야 한 다 . 함 수 시 그 니 처 에 서 확 인 할 수 있 듯 이 반
환 되 는 F i l t e r ( C o m b i n a t o r i a l F i l t e r i C h a i n e d F i l t e r ) 는 유 니 온 형 식 이 다 . 하 지 만 특 정
형 식 의 필 터 를 전 달 했 을 때 같 은 형 식 을 반 환 받 아 야 한 다 . 따 라 서 넓 은 유 니 온 형 식 을 F i l t e r
로 제 약 된 제 네 릭 형 식 매 개 변 수 로 바 꿨 다 . 반 환 형 식 은 의 도 한 대 로 동 작 하 지 만 , 함 수 코 드 에
서 오 류 가 발 생 한 다 .
function reset<F extends Filter>(filter: F): F {
if ("combinator" in filter) {
return { combinator: "and", rules: []};
1 1 ^ { c o m b i n a t o r : " a n d " ; r u l e s : n e v e r [ ] ; } ' 형 식 은 ' F ' 형 식 에 할 당 할
수 없 습 니 다 .
4 장 제 네 릭 1 6 7
/ 1 { c o m b i n a t o r : " a n d " ; r u l e s : n e v e r [ ] ; } ' 은 ( 는 ) ' F ' 형 식 의 제 약
1 1 조 건 에 할 당 할 수 있 지 만 , ' F ' 은 ( 는 ) F i l t e r ' 제 약 조 건 의 다 른 하 위
형 식 으 로 인 스 턴 스 화 할 수 있 습 니 다 . t s ( 2 3 2 2 )
}
return { rules: [] };
1 1 ^ ' { r u l e s : n e v e r [ ] ; } ' 형 식 은 ' F ' 형 식 에 할 당 할 수 없 습 니 다 .
1 / { r u l e s : n e v e r [ ] ; } ' 은 ( 는 ) ' F ' 형 식 의 제 약 조 건 에 할 당 할 수 있 지 만 ,
1 1 / ' F ' 은 ( 는 ) ' F i l t e r ' 제 약 조 건 의 다 른 하 위 형 식 으 로 인 스 턴 스 화 할
/ / 수 있 습 니 다 . t s ( 2 3 2 2 )
}
const resetFilter = reset(filter); / / resetFilter= CombinatorialFilter
유 니 온 의 두 부 분 을 구 분 하 고 싶 지 만 , 타 입 스 크 립 트 는 조 금 더 넓 게 생 각 한 다 . 타 입 스 크 립 트 는
F i l t e r 와 구 조 적 으 로 호 환 되 는 객 체 를 사 용 자 가 전 달 할 것 임 을 알 지 만 F i l t e r 보 다 더 많 은
프 로 퍼 티 를 포 함 하 므 로 이 는 F i l t e r 의 하 위 형 식 이 다 .
즉 , 우 리 는 F 의 하 위 형 식 으 로 인 스 턴 스 화 한 객 체 로 r e s e t 을 호 출 할 수 있 으 며 프 로 그 램 은 아
무 문 제 없 이 모 든 추 가 프 로 퍼 티 를 오 버 라 이 드 한 다 . 하 지 만 이 는 올 바 른 동 작 이 아 니 며 타 입 스
크 립 트 도 이 를 알 려 준 다 .
const onDemandFilter = r e s e t ( {
combinator: "and",
rules: [],
evaluated: true,
result: false,
} ) ;
/ * f i l t e r 는 {
combinator: "and";
rules: never[];
evaluated: boolean;
result: boolean;
3; *1
하 위 형 식 을 포 용 하 는 코 드 를 구 현 해 이 문 제 를 해 결 한 다 . 고 적 절 하 게 바 뀔 프 로 퍼 티 를 설 정 한 다 음 F 형 식 을 반 환 한 다 .
입 력 객 체 ( 여 전 히 F 형 식 ) 를 복 제 하
function reset<F extends Filter>(filter: F): F {
const result = { ...filter }; / / resultE F
1 6 8 실 무 로 통 하 는 타 입 스 크 립 트
r e s u l t . r u l e s = [ ] ;
if ("combinator" in result) {
result.combinator = "and";
}
return result;
}
const resetFilter = reset(filter); / / resetFilter= CombinatorialFilter
제 네 릭 형 식 은 많 은 유 니 온 중 하 나 일 수 있 지 만 , 실 제 로 제 네 릭 형 식 은 더 다 양 한 모 습 으 로 변
신 할 수 있 다 . 타 입 스 크 립 트 의 구 조 적 형 식 시 스 템 은 다 양 한 하 위 형 식 의 사 용 을 허 용 하 므 로
우 리 코 드 도 이 를 반 영 해 야 한 다 .
결 과 는 비 슷 하 지 만 조 금 다 른 시 나 리 오 를 살 펴 보 자 . 트 리 자 료 구 조 를 만 들 고 모 든 트 리 항 목
을 저 장 하 는 재 귀 형 식 을 구 현 한 다 . 이 형 식 은 하 위 형 식 이 될 수 있 으 므 로 올 바 른 하 위 형 식 으
로 이 를 인 스 턴 스 화 하 도 록 제 네 릭 형 식 매 개 변 수 를 이 용 해 c r e a t e R o o t I t e m 함 수 를 구 현 한 다 .
type Treeltem = {
id: string;
children: TreeItem[];
collapsed?: boolean;
function createRootItem<T extends TreeItem>(): T {
return {
id: "root",
c h i l d r e n ： ［ ］ ，
};
1 1 ' { i d : s t r i n g ; c h i l d r e n : n e v e r [ ] ; } ' 형 식 은 ' T ' 형 식 에 할 당 할 수
1 / 없 습 니 다 .
1 1 { i d : s t r i n g ; c h i l d r e n : n e v e r [ ] ; } ' 은 ( 는 ) ' T ' 형 식 의 제 약 조 건 에
1 / 할 당 할 수 있 지 만 , ' T ' 은 ( 는 ) T r e e I t e m ' 제 약 조 건 의 다 른 하 위 형 식 으 로
1 / 인 스 턴 스 화 할 수 있 습 니 다 . t s ( 2 3 2 2 )
}
const root = createRootItem(); // root Treeltem
반 환 값 이 모 든 하 위 형 식 과 호 환 될 수 없 으 므 로 이 전 과 비 슷 한 오 류 가 발 생 한 다 . 제 네 릭 을 제
거 해 이 문 제 를 해 결 한 다 ! 그 리 고 반 환 형 식 은 T r e e I t e m 이 라 는 사 실 을 안 다 .
4 장 제 네 릭 1 6 9
function createRootItem): TreeItem {
return {
id: "root",
children: [1,
};
}
때 로 는 가 장 단 순 한 방 법 이 가 장 좋 은 해 결 책 이 다 . 이 제 새 로 만 든 루 트 에 T r e e I t e m 형 식 이 나
T r e e I t e m 의 하 위 형 식 을 추 가 할 수 있 게 소 프 트 웨 어 를 확 장 해 야 한 다 . 제 네 릭 이 없 으 니 만 족
할 만 한 결 과 를 얻 을 수 없 다 .
function attachToRoot(children: Treeltem[]): Treeltem {
return {
id: "root",
children,
}
const root = attachToRoot([]); / / TreeItem
r o o t 는 T r e e I t e m 형 식 이 지 만 하 위 형 식 을 갖 는 자 식 들 의 정 보 를 잃 어 버 렸 다 . 자 식 들 에 제 네 릭
형 식 매 개 변 수 를 추 가 하 고 T r e e I t e m 으 로 제 약 을 둔 다 해 도 여 전 히 이 정 보 를 유 지 할 수 없 다 .
function attachToRoot<T extends Treeltem>(children: T[]): Treeltem {
return {
id: "root",
children,
3;
}
const root = attachToRoot([
{
id: "child",
children: [], collapsed: false,
marked: true,
]); / / roote Treeltem
1 7 0 실 무 로 통 하 는 타 입 스 크 립 트
제 네 릭 형 식 을 반 환 형 식 으 로 추 가 하 면 이 전 에 겪 은 문 제 가 다 시 발 생 한 다 . 이 를 해 결 하 려 면
루 트 아 이 템 형 식 을 자 식 아 이 템 형 식 과 분 리 해 야 한 다 . 즉 , T r e e I t e m 을 제 네 릭 으 로 만 들 고
C h i l d r e n 을 T r e e I t e m 의 하 위 형 식 으 로 설 정 한 다 .
순 환 참 조 는 피 해 야 하 므 로 C h i l d r e n 을 기 본 B a s e T r e e I t e m 으 로 설 정 한 다 음 T r e e I t e m 을
C h i l d r e n 과 a t t a c h T o R o o t 의 제 약 으 로 사 용 할 수 있 다 .
type BaseTreeItem = 1
id: string;
children: BaseTreeItem[];
3
type Treeltem<Children extends TreeItem = BaseTreeItem> = {
id: string;
children: Children[];
collapsed?: boolean;
};
function attachToRoot<T extends Treeltem>(children: T[]): Treeltem<T> {
return {
id: "root",
children,
3;
}
const root = attachToRoot([
{
id: "child",
children: [1,
collapsed: false,
marked: true,
]);
/\*
r o o t Treeltem<{
id: string;
children: never[];
collapsed: false;
marked: boolean;
4 당 제 네 릭 1 7 1
이 번 에 도 하 위 형 식 을 포 용 하 는 코 드 를 구 현 했 으 며 입 력 매 개 변 수 를 추 측 하 지 않 고 있 는 그 대
로 취 급 했 다 .
4 . 5 새 객 체 형 식 생 성 하 기
문 제 모 델 과 관 련 있 는 형 식 이 애 플 리 케 이 션 에 존 재 한 다 . 모 델 이 바 뀔 때 마 다 형 식 도 바 꿔 야 한 다 .
해 결 제 네 릭 매 핑 된 형 식 을 이 용 해 원 래 형 식 에 기 반 한 새 객 체 형 식 을 만 든 다 .
논 의 3 . 1 절 의 장 난 감 가 게 예 제 로 돌 아 가 자 . 유 니 온 형 식 , 인 터 섹 션 형 식 , 구 별 된 유 니 온 형
식 덕 분 에 멋 진 데 이 터 모 델 을 만 들 수 있 었 다 .
type ToyBase = {
name: string;
description: string;
minimumAge: number;
3;
type BoardGame = ToyBase & {
kind: "boardgame";
players: number;
type Puzzle = ToyBase & {
kind: "puzzle";
pieces: number;
3;
type Doll = ToyBase & {
kind: "doll";
material: "plush" | "plastic";
} ;
type Toy = Doll | Puzzle | BoardGame;
이 제 G r o u p e d T o y s 라 는 형 식 으 로 자 료 구 조 모 델 에 있 는 모 든 장 난 감 을 그 룹 화 해 야 한 다 .
1 7 2 실 무 로 통 하 는 타 입 스 크 립 트
G r o u p e d T o y s 는 각 카 테 고 리 ( 또 는 " k i n d " ) 와 T o y 배 열 을 값 으 로 갖 는 프 로 퍼 티 를 포 함 한 다 .
g r o u p T o y s 함 수 는 정 렬 되 지 않 은 장 난 감 목 록 을 인 수 로 받 아 종 류 별 로 그 룹 화 한 다 .
type GroupedToys = {
boardgame: Toyll;
puzzle: Toyl];
doll: Toy[];
} ;
function groupToys(toys: Toy[]): GroupedToys {
const groups: GroupedToys = {
boardgame: [],
puzzle: [],
doll: [],
for (let toy of toys) {
groups[toy. kind] -push(toy);
}
return groups;
}
이 코 드 에 는 이 미 몇 가 지 좋 은 점 이 있 다 . 우 선 명 시 적 으 로 형 식 애 너 테 이 션 을 이 용 해 g r o u p s
를 선 언 했 다 . 덕 분 에 어 떤 카 테 고 리 도 잊 을 염 려 가 없 다 . 또 한 G r o u p e d T o y s 의 키 는 T o y 의
" k i n d " 유 니 온 형 식 과 같 으 므 로 t o y . k i n d 를 인 덱 스 로 이 용 해 g r o u p s 에 쉽 게 접 근 할 수 있 다 .
몇 개 월 이 지 나 다 시 모 델 을 손 봐 야 할 때 가 되 었 다 . 현 재 장 난 감 가 게 에 서 는 조 립 식 벽 돌 장 난
감 을 판 매 한 다 . B r i c k s 라 는 새 형 식 을 T o y 모 델 에 연 결 한 다 .
type Bricks = ToyBase & {
kind: "bricks"
pieces: number;
brand: string;
}
type Toy = Doll | Puzzle | BoardGame | Bricks;
g r o u p T o y s 는 B r i c k s 도 취 급 해 야 하 는 데 , G r o u p e d T o y s 는 " b r i c k s " 종 류 가 무 엇 인 지 알 지
못 하 므 로 오 류 가 발 생 한 다 .
4 장 제 네 릭 1 7 3
function groupToys(toys: Toy[]): GroupedToys {
const groups: GroupedToys = {
boardgame: 1],
puzzle: [1,
doll: [],
} ;
for (let toy of toys) {
groups[toy.kind].push(toy);
1 / ^ " b o a r d g a m e " i " p u z z l e " i " d o l L " i " b r i c k s " ' 형 식 의
1 / 식 을 ' G r o u p e d T o y s ' 인 덱 스 형 식 에 사 용 할 수 없 으 므 로 요 소 에
/ / 암 시 적 으 로 ' a n y ' 형 식 이 있 습 니 다 .
' G r o u p e d T o y s ' 형 식 에 ' b r i c k s ' 속 성 이 없 습 니 다 . t s ( 7 0 5 3 )
}
return groups;
}
이 번 에 는 G r o u p e d T o y s 와 g r o u p T o y s 를 갱 신 한 다 .
type GroupedToys = {
boardgame: Toy[];
puzzle: Toyl];
doll: Toy[];
bricks: Toy[];
function groupToys(toys: Toy[]): GroupedToys {
const groups: GroupedToys = {
boardgame: [],
puzzle: [],
doll: [],
bricks: [],
};
for (let toy of toys) {
groups[toy.kind].push(toy);
}
return groups;
}
한 가 지 성 가 신 부 분 이 있 는 데 , 장 난 감 그 룹 화 작 업 은 항 상 같 다 는 점 이 다 . 모 델 이 어 떻 게 바 뀌
든 관 계 없 이 종 류 를 선 택 해 서 배 열 에 넣 는 작 업 은 같 다 . 모 델 이 바 뀔 때 마 다 g r o u p s 를 유 지 해
1 7 4 실 무 로 통 하 는 타 입 스 크 립 트
야 하 는 데 , 이 g r o u p s 를 바 라 보 는 시 각 을 조 금 바 꾸 면 변 화 에 따 른 대 응 을 최 적 화 할 수 있 다 .
우 선 G r o u p e d T o y s 가 선 택 형 프 로 퍼 티 를 갖 도 록 만 든 다 . 그 리 고 초 기 화 되 지 않 은 각 그 룹 을 빈
배 열 로 초 기 화 한 다 .
type GroupedToys = {
boardgame?: Toy[];
puzzle?: Toy[];
doll?: Toy[];
bricks?: Toy[];
3;
function groupToys(toys: Toy[]): GroupedToys {
const groups: GroupedToys = 15;
for (let toy of toys) {
/ / 이 용 할 수 없 으 면 초 기 화
groups [toy.kind] = groups[toy.kind] ?? |1;
groups[toy.kind]?.push(toy);
}
return groups;
}
이 제 g r o u p T o y s 를 유 지 할 필 요 가 없 고 G r o u p e d T o y s 형 식 만 유 지 하 면 된 다 . G r o u p e d T o y s
를 자 세 히 살 펴 보 면 T o y 와 암 묵 적 인 관 계 가 존 재 함 을 발 견 할 수 있 다 . 각 프 로 퍼 티 키
는 T o y [ " k i n d " ] 의 일 부 다 . 이 관 계 를 명 시 적 으 로 만 들 어 보 자 . 매 핑 된 형 식 을 이 용 해
T o y [ " k i n d " ] 의 각 형 식 에 기 반 한 새 객 체 형 식 을 만 든 다 .
T o y [ " k i n d " ] 는 문 자 열 리 터 럴 의 유 니 온 " b o a r d g a m e " i " p u z z l e " i " d o L l " i " b r i c k s "
다 . 아 주 제 한 적 인 문 자 열 집 합 만 있 으 므 로 새 로 생 성 된 형 식 의 프 로 퍼 티 키 로 이 형 식 을 사 용 할
수 있 다 .
type GroupedToys = {
[k in Toy["kind"]]?: Toy[];
? !
멋 지 다 ! T o y 를 바 꿀 때 마 다 T o y [ ] 도 즉 시 바 뀐 다 . 코 드 에 서 는 아 무 것 도 바 꿀 필 요 가 없 다 . 기
존 처 럼 k i n d 별 로 그 룹 화 가 이 루 어 진 다 .
4 장 제 네 릭 1 7 5
이 는 일 반 화 로 개 선 할 수 있 는 패 턴 이 다 . 컬 렉 션 을 받 아 특 정 선 택 자 로 그 룹 화 하 는 G r o u p 형 식
을 만 든 다 . 두 개 의 형 식 매 개 변 수 로 제 네 릭 형 식 을 만 들 려 한 다 .
• C o l L e c t i o n 은 무 엇 이 든 포 함 할 수 있 다 .
• C o l l e c t i o n 의 키 는 S e l e c t o r 이 므 로 S e L e c t o r 는 관 련 프 로 퍼 티 를 만 들 수 있 다 .
첫 번 째 시 도 는 G r o u p e d T o y s 에 있 는 것 을 가 져 다 형 식 매 개 변 수 를 이 용 해 구 체 적 형 식 으 로 치
환 하 는 방 법 이 다 . 이 는 필 요 한 기 능 은 수 행 하 지 만 오 류 를 일 으 킨 다 .
1 / 사 용 방 법
type GroupedToys = Group<Toy, "kind">;
type Group<Collection, Selector extends keyof Collection> = {
[x in Collection[Selector]]?: Collection[];
/ /
/ /
/ /
^ ' C o l l e c t i o n [ s e l e c t o r ] ' 형 식 은 ' s t r i n g : n u m b e r I s y m b o l '
형 식 에 할 당 할 수 없 습 니 다 .
'Collection[keyof Collection]' # H & 'string | number | symbol'
형 식 에 할 당 할 수 없 습 니 다 .
1 /
1 /
'Collection[string] | Collection[number] | Collection[symbol]'
형 식 은 ' s t r i n g i n u m b e r : s y m b o l ' 형 식 에 할 당 할 수 없 습 니 다 .
' C o l l e c t i o n [ s t r i n g ] ' 형 식 은 ' s t r i n g : n u m b e r i s y m b o l ' 형 식 에
1 / 할 당 할 수 없 습 니 다 . t s ( 2 3 2 2 )
타 입 스 크 립 트 는 무 엇 이 든 C o l l e c t i o n [ s t r i n g ] : C o l l e c t i o n [ n u m b e r ] : C o l l e c t i o n [ s y m b o L ]
의 결 과 가 될 수 있 으 므 로 키 로 사 용 할 수 없 음 을 경 고 한 다 . 이 는 사 실 이 므 로 이 에 대 비 해 야 한
다 . 두 가 지 방 법 중 하 나 로 이 에 대 비 할 수 있 다 .
첫 째 , R e c o r d s t r i n g , a n y > 을 가 리 키 는 형 식 제 약 을 C o l L e c t i o n 에 사 용 한 다 . R e c o r d 는 새
객 체 를 만 드 는 유 틸 리 티 형 식 인 데 , 이 때 첫 번 째 매 개 변 수 는 모 든 키 를 , 두 번 째 매 개 변 수 는 형
식 을 제 공 한 다 .
1 / 다 음 은 내 장 형 식 이 다 !
type Record<K extends string | number | symbol, T> = { [P in K]: T; };
1 7 6 실 무 로 통 하 는 타 입 스 크 립 트
결 국 C o l L e c t i o n 은 와 일 드 카 드 객 체 가 되 므 로 G r o u p s 의 형 식 확 인 을 사 실 상 무 력 화 한 다 . 프 로
퍼 티 키 에 사 용 할 수 없 는 형 식 이 있 으 면 어 차 피 타 입 스 크 립 트 가 오 류 를 발 생 시 키 므 로 이 는 큰
문 제 가 아 니 다 . 따 라 서 최 종 적 으 로 G r o u p 은 제 약 을 포 함 하 는 두 개 의 형 식 매 개 변 수 를 갖 는 다 .
type Group<
Collection extends Record<string, any>,
Selector extends keyof Collection

> = {
> [x in Collection[Selector]]: Collection[];
> 둘 째 , 각 키 가 유 효 한 문 자 열 키 인 지 검 사 하 는 방 법 이 있 다 . 조 건 부 형 식 o n d i o m i l p e 을 이 용
> 해 C o l l e c t i o n [ S e l e c t o r ] 이 키 에 유 효 한 형 식 인 지 확 인 할 수 있 다 . 유 효 한 형 식 이 아 니 면
> n e v e r 로 설 정 해 해 당 형 식 을 제 거 한 다 . 조 건 부 형 식 은 자 체 적 으 로 복 잡 한 기 능 이 므 로 5 . 4 절 에
> 서 자 세 히 살 펴 본 다 .
> type Group<Collection, Selector extends keyof Collection> = {
> [k in Collection[Selector] extends string
> ? Collection[Selector]
> : never]?: Collection[];
> 선 택 형 형 식 변 경 자 를 제 거 했 다 는 사 실 에 주 목 하 자 . 키 를 선 택 형 으 로 만 드 는 일 은 그 룹
> 화 작 업 과 관 련 이 없 기 때 문 이 다 . 대 신 이 에 사 용 할 수 있 는 P a r t i a l < T > 라 는 형 식 이 있 다 .
> P a r t i a l T 〉 는 매 핑 된 형 식 으 로 객 체 의 모 든 프 로 퍼 티 형 식 을 선 택 형 으 로 만 든 다 .
> 1 / 다 음 은 내 장 형 식 이 다 !
> type Partial<T> = { [P in keyof T]?: T[P] };
> 어 떤 G r o u p 헬 퍼 를 만 들 기 로 했 든 이 제 " k i n d " 별 로 구 분 한 T o y s 의 G r o u p 을 P a r t i a l 로 만 들
> 고 싶 다 고 타 입 스 크 립 트 에 알 려 줄 수 있 다 .
> type GroupedToys = Partial<Group<Toy, "kind"»>;
> 이 렇 게 코 드 로 원 하 는 바 를 구 현 했 다 .
> 4 장 제 네 릭 1 7 7
> 4 . 6 어 서 션 시 그 니 처 로 객 체 변 경 하 기
> 문 제 코 드 에 서 어 떤 함 수 를 실 행 한 이 후 에 값 의 형 식 이 바 뀌 었 다 .
> 해 결 어 서 션 시 그 니 처 를 이 용 해 i f 및 S w i t c h 문 과 별 개 로 형 식 을 변 경 한 다 .
> 논 의 자 바 스 크 립 트 는 아 주 유 연 한 언 어 다 . 자 바 스 크 립 트 의 동 적 형 식 기 능 을 이 용 해 런 타 임
> 에 객 체 를 바 꿀 수 있 으 며 , 새 프 로 퍼 티 를 바 로 추 가 할 수 있 다 . 개 발 자 는 이 런 기 능 을 활 용 한
> 다 . 예 를 들 어 요 소 로 구 성 된 컬 렉 션 을 처 리 하 는 데 특 정 프 로 퍼 티 에 어 서 션 을 적 용 해 야 한 다 .
> 그 결 과 로 c h e c k e d 프 로 퍼 티 를 저 장 한 다 음 t r u e 로 설 정 해 특 정 감 사 를 거 쳤 음 을 기 록 한 다 .
> function check(person: any) {
> person. checked = true;
> }
> const person = {
> name: "Stefan",
> age: 27,
> c h e c k ( p e r s o n ) ; 1 / p e r s o n 은 c h e c k e d 프 로 퍼 티 를 포 함 한 다 .
> p e r s o n . c h e c k e d ; 1 / 참 이 다 !
> 형 식 시 스 템 에 이 를 반 영 하 고 싶 다 . 그 렇 지 않 으 면 객 체 에 특 정 프 로 퍼 티 가 존 재 하 는 지 매 번
> 확 인 해 야 하 기 때 문 이 다 . 특 정 프 로 퍼 티 가 존 재 함 을 알 아 도 이 를 피 할 수 없 다 .
> 형 식 어 서 션 을 이 용 해 특 정 프 로 퍼 티 가 존 재 함 을 증 명 한 다 . 특 정 시 점 에 이 프 로 퍼 티 는 다 른
> 형 식 을 갖 는 다 고 말 할 수 있 다 .
> (person as typeof person & { checked: boolean }).checked = true;
> 괜 찮 은 방 법 이 지 만 p e r s o n 의 원 래 형 식 을 바 꾸 지 는 않 으 므 로 형 식 어 서 션 을 계 속 반 복 해 야 한
> 다 . 3 . 5 절 에 서 설 명 했 듯 이 형 식 찬 반 형 을 만 들 어 특 정 프 로 퍼 티 가 존 재 함 을 증 명 하 는 방 법 도
> 있 다 .
> 1 7 8 실 무 로 통 하 는 타 입 스 크 립 트
> function check<T>(obj: T): obj i s T & { checked: t r u e } {
> (obj as T & { checked: boolean }) .checked = true;
> r e t u r n t r u e ;
> }
> const person = 1
> n a m e : "Stefan",
> age: 27,
> };
> i f (check(person)) ‹
> , person. checked; / hecode true!
> 하 지 만 이 번 에 는 c h e c k 함 수 의 코 드 가 어 설 픈 동 작 을 수 행 하 는 것 처 럼 보 인 다 . 즉 , 찬 반 형 함
> 수 에 서 추 가 조 건 을 설 정 한 다 음 t r u e 를 반 환 한 다 . 뭔 가 잘 못 된 것 같 다 .
> 다 행 히 도 타 입 스 크 립 트 는 이 런 상 황 에 서 활 용 할 수 있 도 록 어 서 시 그 니 처 라 는 기 능 을 제
> 공 한 다 . 어 서 션 시 그 니 처 를 이 용 하 면 조 건 형 을 이 용 하 지 않 고 제 어 흐 름 에 서 값 의 형 식 을 바
> 꿀 수 있 다 . 어 서 시 그 니 처 는 사 실 N o d e . j s 의 a s s e r t 함 수 를 구 현 할 목 적 으 로 만 들 어 졌 다 .
> a s s e r t 함 수 는 조 건 을 받 아 조 건 이 참 이 아 니 면 오 류 를 던 지 는 함 수 다 . 즉 , a s s e r t 를 호 출 하
> 기 전 보 다 후 에 더 많 은 정 보 를 얻 는 다 . 예 를 들 어 a s s e r t 를 호 출 한 다 음 값 의 형 식 이 s t r i n g
> 이 라 면 이 후 는 경 험 적 으 로 a s s e r t 함 수 를 호 출 한 이 후 의 값 이 s t r i n g 이 어 야 한 다 는 사 실 을
> 알 수 있 다 .
> function assert(condition: any, msg?: string): asserts condition {
> if (!condition) {
> throw new Error(msg);
> }
> }
> function yell(str: any) {
> assert(typeof str === "string");
> / / s t r e string
> return str. toUpperCase();
> }
> 4 장 제 네 릭 1 7 9
> 조 건 이 거 짓 이 면 이 함 수 는 즉 시 실 행 을 종 료 s h o n - i c u 한 다 . 오 류 가 발 생 하 면 n e v e r 가 된 다 . 함
> 수 를 통 과 해 야 조 건 을 실 제 로 확 인 할 수 있 다 .
> 어 서 션 시 그 니 처 가 N o d e . j s 의 a s s e r t 함 수 용 으 로 만 들 어 졌 지 만 , 원 하 는 모 든 형 식 에 a s s e r t
> 를 사 용 할 수 있 다 . 예 를 들 어 a n y 형 식 의 값 을 받 는 함 수 가 있 는 데 함 수 가 실 행 을 이 어 가 려 면
> 이 값 은 반 드 시 n u m b e r 여 야 함 을 조 건 으 로 걸 수 있 다 .
> function assertNumber(val: any): asserts val i s number {
> i f (typeof val ! = "number") {
> throw Error("value is not a number");
> }
> }
> function add(x: unknown, y: unknown): number {
> assertNumber (x); / / x = number
> assertNumber (y); / / y E number
> r e t u r n x + y ;
> }
> 어 서 션 시 그 니 처 와 관 련 한 모 든 예 제 는 기 본 어 서 기 능 과 오 류 에 따 른 즉 시 실 행 종 료 에 기
> 반 함 을 알 수 있 다 . 하 지 만 이 기 법 을 이 용 해 타 입 스 크 립 트 에 더 많 은 프 로 퍼 티 가 있 음 을 알 릴
> 수 있 다 . 이 전 에 는 C h e c k 와 아 주 비 슷 한 찬 반 형 함 수 를 구 현 했 지 만 , 이 번 엔 t r u e 를 반 환 할 필
> 요 가 없 다 . 프 로 퍼 티 를 설 정 하 고 자 바 스 크 립 트 에 서 객 체 는 값 으 로 전 달 하 므 로 이 함 수 를 호
> 출 한 다 음 에 는 무 엇 을 이 함 수 로 전 달 했 는 지 와 관 계 없 이 c h e c k e d 프 로 퍼 티 가 존 재 하 며 값 은
> t r u e 일 것 임 을 장 담 할 수 있 다 .
> function check<T>(obj: T): asserts obj is T & { checked: true } f
> (obj as T & { checked: boolean }). checked = true;
> }
> const person = {
> name: "Stefan",
> age: 27,
> 3;
> check(person);
> 이 를 이 용 해 실 시 간 으 로 값 의 형 식 을 바 꿀 수 있 다 . 잘 알 려 지 지 는 않 았 지 만 유 용 한 기 능 이 다 .
> 1 8 0 실 무 로 통 하 는 타 입 스 크 립 트
> 4 . 7 형 식 맵 을 이 용 한 매 핑 형 식 사 용 하 기
> 문 제 문 자 열 식 별 자 에 기 반 한 특 정 하 위 형 식 의 객 체 를 만 드 는 팩 토 리 함 수 를 구 현 하 는 데 , 다 양 한 하 위 형
> 식 이 존 재 할 수 있 는 상 황 이 다 .
> 해 결 모 든 하 위 형 식 을 형 식 맵 에 저 장 하 고 인 덱 스 로 접 근 할 수 있 게 한 다 음 P a r t i a l c T > 같
> 은 매 핑 된 형 식 을 사 용 한 다 .
> 논 의 어 떤 기 본 정 보 에 근 거 한 복 잡 한 객 체 변 형 을 만 들 때 팩 토 리 함 수 를 유 용 하 게 활 용 한
> 다 . 브 라 우 저 자 바 스 크 립 트 의 요 소 생 성 이 좋 은 예 다 . d o c u m e n t . C r e a t e E l e m e n t 함 수 는 요 소
> 태 그 명 을 받 아 객 체 를 만 드 는 데 , 이 때 사 용 자 는 객 체 의 모 든 프 로 퍼 티 를 필 요 한 대 로 바 꿀 수
> 있 다 .
> c r e a t e E L e m e n t 라 는 팩 토 리 함 수 로 이 생 성 과 정 을 조 금 더 개 선 하 려 한 다 . 새 함 수 는 요 소 의
> 태 그 명 뿐 아 니 라 프 로 퍼 티 목 록 도 받 으 므 로 각 프 로 퍼 티 를 따 로 설 정 할 필 요 가 없 다 .
> 1 / c r e a t e E l e m e n t 사 용 하 기
> / / a z HTMLAnchorElement
> const a = createElement("a", { href: "https://fettblog.eu" });
> / / b E HTMLVideoElement
> const b = createElement ("video", { src: "/movie.mp4", autoplay: true });
> / / c - HTMLElement
> const c = createElement ("my-element");
> 이 에 사 용 할 좋 은 형 식 을 만 들 어 야 하 는 데 , 다 음 두 가 지 를 유 념 하 자 .
> • 유 효 한 H T M L 요 소 만 만 든 다 .
> • H T M L 요 소 프 로 퍼 티 의 하 위 집 합 을 받 아 들 이 는 형 식 을 제 공 한 다 .
> 우 선 유 효 한 H T M L 요 소 만 만 드 는 문 제 를 해 결 하 자 . H T M L 은 1 4 0 개 라 는 상 당 히 많 은 요 소 를
> 제 공 한 다 . 각 요 소 는 문 자 열 로 구 성 된 태 그 명 을 포 함 하 며 D O M 에 각 프 로 토 타 입 객 체 를 갖 는
> 다 . t s c o n f i g . j s o n 에 d o m 라 이 브 러 리 를 사 용 하 면 타 입 스 크 립 트 는 형 식 을 이 용 해 이 들 프 로
> 토 타 입 객 체 정 보 를 갖 는 다 . 이 렇 게 1 4 0 개 모 든 요 소 의 이 름 을 알 아 낼 수 있 다 .
> 4 장 제 네 릭 1 8 1
> 형 식 맵 y p e m a p 을 이 용 하 면 요 소 태 그 명 과 프 로 토 타 입 객 체 를 쉽 게 매 핑 할 수 있 다 . 형 식 맵 이 란
> 형 식 별 칭 이 나 인 터 페 이 스 의 키 가 관 련 된 형 식 변 형 을 가 리 키 도 록 하 는 기 법 이 다 . 이 후 에 는 문
> 자 열 리 터 럴 형 식 의 인 덱 스 를 이 용 해 올 바 른 형 식 변 형 을 얻 는 다 .
> type AllElements = 1
> a: HTMLAnchorElement;
> div: HTMLDivElement;
> video: HTMLVideoElement;
> 1 … … ~ 1 4 0 개 요 소 전 부 !
> 3
> / / HTMLAnchorElement
> type A = AllElements["a"];
> 마 치 인 덱 스 로 자 바 스 크 립 트 객 체 에 접 근 하 는 것 처 럼 보 이 지 만 , 이 는 형 식 수 준 의 동 작 이 라 는
> 사 실 을 기 억 하 자 . 즉 , 인 덱 스 접 근 을 확 장 할 수 있 다 .
> type AllElements = 1
> a: HTMLAnchorElement;
> div: HTMLDivElement;
> video: HTMLVideoElement;
> 1 … … ~ 1 4 0 개 요 소 전 부 !
> / / HTMLAnchorElement | HTMLDivELement
> type AandDiv = AllElements["a" | "div"];
> 이 맵 을 이 용 해 c r e a t e E L e m e n t 함 수 에 형 식 을 추 가 하 자 . 제 네 릭 형 식 매 개 변 수 에 A l L E L e m e n t s
> 의 모 든 키 라 는 제 한 을 추 가 해 서 오 직 유 효 한 H T M L 요 소 만 키 로 받 을 수 있 다 .
> function createElement<T extends keyof AllElements>(tag: T): AllElements[T] {
> return document.createElement(tag as string) as AllElements[T];
> }
> / / a z HTMLAnchorElement
> const a = createElement ("a");
> 1 8 2 실 무 로 통 하 는 타 입 스 크 립 트
> 여 기 서 제 네 릭 은 문 자 열 리 터 럴 을 리 터 럴 형 식 으 로 고 정 하 는 역 할 을 하 며 이 를 이 용 해
> H T M L 의 유 효 한 요 소 만 을 형 식 맵 에 서 가 져 와 인 덱 스 로 사 용 하 도 록 한 다 . 또 한 d o c u m e n t .
> c r e a t e E l e m e n t 는 두 개 의 형 식 어 서 션 을 요 구 한 다 . 한 개 는 집 합 을 넓 은 형 식 ( T 를 s t r i n g )
> 으 로 만 들 고 다 른 하 나 는 집 합 을 좁 은 형 식 ( H t m L E l e m e n t 를 A l L E l e m e n t s [ T ] ) 으 로 만 든 다 .
> 두 어 서 션 은 3 . 9 절 에 서 설 명 했 듯 이 우 리 가 제 어 할 수 있 는 범 위 밖 의 A P I 를 처 리 하 고 있 음 을
> 의 미 한 다 . 이 들 어 서 션 은 나 중 에 다 시 살 펴 본 다 .
> H T M L 요 소 와 관 련 한 추 가 프 로 퍼 티 를 전 달 하 는 옵 션 을 제 공 하 려 한 다 . 예 를 들 어
> H T M L A n c h o r E l e m e n t 에 는 h r e f 를 설 정 하 는 식 이 다 . 모 든 프 로 퍼 티 가 H T M L E L e m e n t 변 형 에 포
> 함 되 지 만 , 이 들 은 선 택 형 이 아 니 라 필 수 형 이 다 . 내 장 형 식 P a r t i a L T > 를 이 용 해 이 들 프 로 퍼
> 티 를 선 택 형 으 로 바 꾼 다 . P a r t i a l < T 〉 는 특 정 형 식 의 모 든 프 로 퍼 티 를 가 져 다 형 식 변 경 자 를
> 추 가 하 는 매 핑 된 형 식 이 다 .
> type Partial<T> = { [P in keyof T]?: T[P] };
> A l L E l e m e n t s 요 소 의 P a r t i a l 인 선 택 형 인 수 p r o p s 를 c r e a t e E l e m e n t 함 수 에 추 가 한 다 . 이
> 제 " a " 를 전 달 하 면 H T M L A n c h o r E l e m e n t 에 서 제 공 하 는 프 로 퍼 티 만 설 정 할 수 있 다 .
> function createElement<T extends keyof AllElements>(
> tag: T,
> props?: Partial<AllElements[T]>
> ): AllElements[T] {
> const elem = document.createElement(tag as string) as AllElements [T];
> return Object-assign(elem, props);
> }
> const a = createElement("a", { href: "https://fettblog.eu" });
> const x = createElement("a", { src: "https://fettblog.eu" });
> 1 / ^ ! !
> 1 / 객 체 리 터 럴 은 알 려 진 속 성 만 지 정 할 수 있 으 며 ' P a r t i a l c H T M L A n c h o r E l e m e n t > '
> 1 / 형 식 에 ' S r c ' 이 ( 가 ) 없 습 니 다 . t s ( 2 3 5 3 )
> 멋 지 다 ! 이 제 나 머 지 1 4 0 개 H T M L 요 소 도 처 리 할 수 있 다 . 그 런 데 너 무 많 다 . 다 행 히 누 군 가
> 이 작 업 을 이 미 처 리 해 서 L i b . d o m . t s 의 H T M L E L e m e n t T a g N a m e M a p 으 로 추 가 했 으 니 이 를 이 용
> 하 자 .
> 4 장 제 네 릭 1 8 3
> function createElement<T extends keyof HTMLElementTagNameMap>(
> tag: T,
> props?: Partial<HTMLElementTagNameMap[T]>
> ) : HTMLElementTagNameMap[T] {
> const elem = document.createElement (tag);
> return Object.assign(elem, props);
> }
> d o c u m e n t . c r e a t e E l e m e n t 도 이 인 터 페 이 스 를 사 용 하 므 로 우 리 가 구 현 한 함 수 와 내 장 함 수 는
> 완 벽 호 환 된 다 . 추 가 어 서 션 은 필 요 없 다 .
> 한 가 지 문 제 가 있 다 . H T M L E L e m e n t T a g N a m e M a p 에 서 제 공 하 는 1 4 0 개 요 소 만 사 용 할 수 있 다
> 는 점 이 다 . S V G 요 소 나 커 스 터 마 이 즈 된 요 소 명 이 있 는 웹 컴 포 넌 트 가 필 요 할 때 는 무 엇 을 해
> 야 할 까 ? 현 재 팩 토 리 함 수 의 기 능 은 너 무 제 한 적 이 다 .
> d o c u m e n t . c r e a t e E l e m e n t 의 기 능 을 확 장 하 려 면 모 든 가 능 한 문 자 열 을 다 시 추 가 해 야 한 다 .
> H T M L E l L e m e n t T a g N a m e M a p 은 인 터 페 이 스 이 므 로 남 은 모 든 문 자 열 을 H T M L U n k n o w n E l e m e n t 로
> 매 핑 한 다 음 인 덱 스 된 시 그 니 처 n d e x e d s i g m a u r c 를 이 용 해 선 언 합 치 기 로 인 터 페 이 스 를 확 장 해 야 한 다 .
> interface HTMLElementTagNameMap {
> [x: string]: HTMLUnknownElement;
> } ;
> function createElement<T extends keyof HTMLElementTagNameMap>
> tag: T,
> props?: Partial<HTMLElement TagNameMap[T]>
> ) : HTMLElementTagNameMap[T] {
> const elem = document.createElement(tag);
> return Object.assign(elem, props);
> }
> / / a z HTMLAnchorElement
> const a = createElement"a", { href: "https://fettblog.eu" });
> / / bE HTMLUnknownE lement
> const b = createElement ("my-element");
> 1 8 4 실 무 로 통 하 는 타 입 스 크 립 트
> 이 제 필 요 한 모 든 기 능 을 얻 었 다 .
> • 형 식 을 갖 춘 H T M L 요 소 를 만 드 는 훌 륭 한 팩 토 리 함 수
> • 한 개 의 설 정 객 체 로 모 든 가 능 한 요 소 프 로 퍼 티 를 설 정 할 수 있 는 가 능 성
> • 미 리 정 의 된 요 소 외 에 추 가 요 소 를 만 들 수 있 는 유 연 성
> 마 지 막 작 업 을 훌 륭 하 게 완 성 했 다 . 그 런 데 웹 컴 포 넌 트 는 어 떻 게 지 원 할 까 ? 웹 컴 포 넌 트 는 자
> 체 규 칙 이 있 다 . 이 들 은 태 그 명 에 대 시 ( i s ) 를 포 함 한 다 . 문 자 열 템 플 릿 리 터 럴 형 식 ( h t i n g e m p l a n c e l i c r a l
> t p c 에 매 핑 된 형 식 을 이 용 해 이 를 모 델 링 할 수 있 다 . 문 자 열 템 플 릿 리 터 럴 형 식 은 6 장 에 서 배
> 운 다 .
> 우 선 은 문 자 열 뒤 에 대 시 가 오 고 그 뒤 에 다 시 문 자 열 이 오 는 패 턴 으 로 구 성 된 문 자 열 들 의 집
> 합 을 만 들 어 야 한 다 는 사 실 에 집 중 하 자 . 이 패 턴 을 이 용 해 올 바 른 요 소 명 을 전 달 한 다 .
> 매 핑 된 형 식 은 형 식 별 칭 에 만 적 용 할 수 있 으 며 인 터 페 이 스 선 언 에 는 적 용 되 지 않 으 므 로
> A L L E l e m e n t s 형 식 을 다 시 정 의 한 다 .
> type AllElements = HTMLElementTagNameMap &
> {
> [x in '${string}-${string}']: HTMLElement;
> function createElement<T extends keyof AllElements>(
> tag: T,
> props?: Partial<AllElements[T]>
> ): AllElements[T] {
> const elem = document.createElement(tag as string) as AllElements[T];
> return Object.assign(elem, props);
> }
> const a = createElement("a", { href: " h t t p s : / / f e t t b l o g e "
> c o n s t b = c r e a t e E L e m e n t ( " m y - e L e m e n t " ) ; 1 / 동 작 함
> const c = createElement ("thisWillError");
> 1 / t h i s w i l l E r r o r " ' 형 식 의 인 수 는 ' $ { s t r i n g } - $ { s t r i n g } ’ ! k e y o f
> 1 / H T M L E l e m e n t T a g N a m e N a p ' 형 식 의 매 개 변 수 에 할 당 될 수 없 습 니 다 . t s ( 2 3 4 5 )
> 4 장 제 네 릭 1 8 5
> 훌 륭 하 다 ! A L L E L e m e n t s 형 식 이 바 뀌 면 서 형 식 어 서 션 도 돌 아 왔 지 만 , 그 렇 게 마 음 에 들 지 는
> 않 는 다 . 어 서 션 대 신 함 수 오 버 로 드 를 사 용 할 수 있 다 . 즉 , 사 용 자 가 사 용 할 한 개 의 함 수 정 의
> 와 우 리 가 구 현 할 함 수 용 정 의 이 렇 게 두 개 의 함 수 를 구 현 하 는 기 법 이 다 . 함 수 오 버 로 드 기 법
> 은 2 . 6 절 과 1 2 . 7 절 에 서 더 자 세 히 배 울 수 있 다 .
> function createElement<T extends keyof AllElements>(
> tag: T,
> props?: Partial<AllElements[T]>
> ): AllElements [T];
> function createElement(tag: string, props?: Partial<HTMLElement>): HTMLElement {
> const elem = document.createElement(tag);
> return Object.assign(elem, props);
> }
> 필 요 한 모 든 기 능 을 갖 췄 다 . 매 핑 된 형 식 과 인 덱 스 시 그 니 처 로 형 식 맵 을 정 의 했 고 , 제 네 릭 형
> 식 매 개 변 수 로 의 도 를 아 주 명 시 적 으 로 표 현 했 다 . 타 입 스 크 립 트 도 구 주 머 니 에 훌 륭 한 다 용 도
> 도 구 조 합 을 추 가 했 다 .
> 4 . 8 T h i s T y p e 으 로 객 체 의 t h i s 정 의 하 기
> 문 제 앱 에 서 여 러 메 서 드 를 포 함 하 는 복 잡 한 설 정 객 체 들 을 처 리 하 는 데 , 사 용 처 에 따 라 t h i s 의 컨 텍 스 트
> 가 달 라 진 다 .
> 해 결 내 장 제 네 릭 T h i s T y p e < T > 를 이 용 해 t h i s 를 올 바 로 정 의 한 다 .
> 논 의 V u e j S ( h t t p s : / / v u e j s . o r g / ) 같 은 프 레 임 워 크 는 많 은 팩 토 리 함 수 에 크 게 의 존 하 는 데 ,
> 이 팩 토 리 함 수 들 은 보 통 초 기 데 이 터 , 계 산 된 프 로 퍼 티 , 각 인 스 턴 스 의 메 서 드 를 정 의 하 는 복
> 잡 한 설 정 객 체 를 인 수 로 받 는 다 . 앱 의 컴 포 넌 트 에 도 이 와 비 슷 한 기 능 을 만 든 다 고 가 정 하 자 .
> 다 음 과 같 은 세 프 로 퍼 티 가 있 는 설 정 객 체 를 만 들 려 한 다 .
> 1 8 6 실 무 로 통 하 는 타 입 스 크 립 트
> d a t a 함 수
> 수 없 다 .
> 인 스 턴 스 의 초 기 데 이 터 를 반 환 한 다 . 이 함 수 에 서 는 설 정 객 체 의 다 른 프 로 퍼 티 에 접 근 할
> c o m p u t e d 프 로 퍼 티
> 초 기 데 이 터 에 기 반 해 계 산 된 프 로 퍼 티 를 저 장 한 다 . 여 러 함 수 를 이 용 해 계 산 된 프 로 퍼 티 를
> 선 언 한 다 . 이 들 함 수 는 일 반 프 로 퍼 티 에 접 근 하 듯 이 초 기 데 이 터 에 접 근 할 수 있 다 .
> m e t h o d s 프 로 퍼 티
> 메 서 드 는 호 출 할 수 있 는 대 상 이 며 , 초 기 데 이 터 와 계 산 된 프 로 퍼 티 모 두 에 접 근 할 수 있 다 .
> 메 서 드 는 일 반 프 로 퍼 티 에 접 근 하 듯 이 계 산 된 프 로 퍼 티 에 접 근 할 수 있 으 므 로 함 수 를 호 출
> 할 필 요 가 없 다 .
> 각 설 정 객 체 는 세 가 지 방 법 으 로 t h i s 를 해 석 한 다 . d a t a 에 서 t h i s 는 아 무 프 로 퍼 티 도 포 함
> 하 지 않 는 다 . c o m p u t e d 에 서 각 함 수 는 마 치 객 체 의 일 부 에 접 근 하 듯 이 t h i s 를 이 용 해 d a t a 의
> 반 환 값 에 접 근 할 수 있 다 . m e t h o d s 에 서 각 메 서 드 는 c o m p u t e d 와 같 은 방 식 으 로 t h i s 를 이 용
> 해 d a t a 와 계 산 된 프 로 퍼 티 에 접 근 할 수 있 다 .
> const instance = create({
> data() {
> return { firstName: "Stefan",
> LastName: "Baumgartner",
> } ;
> },
> c o m p u t e d ： ｛
> fullName () {
> 1 / d a t a 의 반 환 객 체 에 접 근 할 수 있 음
> return this. firstName + " " + this. lastName;
> 3,
> methods: {
> h i {
> 1 / 일 반 프 로 퍼 티 를 사 용 하 듯 이 계 산 된 프 로 퍼 티 를 사 용 함
> alert(this. fullName.toLowerCase());
> 3,
> 4 장 제 네 릭 1 8 7
> } ) ;
> 이 는 특 별 하 지 만 흔 히 볼 수 있 는 기 능 이 다 . 이 런 동 작 을 사 용 하 려 면 좋 은 형 식 이 필 요 하 다 .
> 노 트 식 에 집 중 한 다 .
> 구 현 코 드 의 세 부 사 항 은 이 장 에 서 다 루 는 주 제 와 관 련 이 없 으 므 로 이 절 에 서 는 구 현 코 드 가 아 니 라 형
> 각 프 로 퍼 티 의 형 식 을 만 들 어 보 자 . O p t i o n s 라 는 형 식 을 정 의 한 다 음 단 계 별 로 완 성 한 다 . 먼
> 저 d a t a 함 수 를 살 펴 보 자 . d a t a 는 사 용 자 가 정 의 할 수 있 으 므 로 제 네 릭 형 식 매 개 변 수 로 d a t a
> 를 지 정 한 다 . 특 히 여 기 서 는 d a t a 함 수 의 반 환 형 식 이 핵 심 이 다 .
> type Options<Data > = {
> data(this: {})?: Data;
> d a t a 함 수 의 실 제 반 환 값 을 지 정 했 으 므 로 D a t a 플 레 이 스 홀 더 는 실 제 객 체 형 식 으 로 치 환 된 다 .
> t h i s 가 빈 객 체 를 가 리 키 도 록 설 정 했 는 데 , 이 는 설 정 객 체 에 서 다 른 프 로 퍼 티 에 접 근 하 지 않
> 음 을 의 미 한 다 .
> 다 음 으 로 c o m p u t e d 를 살 펴 보 자 . c o m p u t e d 는 함 수 들 의 객 체 다 . C o m p u t e d 라 는 다 른 제 네 릭
> 형 식 매 개 변 수 를 추 가 하 고 C o m p u t e d 의 값 은 사 용 처 에 따 라 형 식 이 추 론 되 도 록 한 다 . 여 기 서
> t h i s 는 D a t a 의 모 든 프 로 퍼 티 로 바 뀐 다 . d a t a 함 수 에 서 했 듯 이 t h i s 를 설 정 하 지 않 으 므 로 내
> 자 헬 퍼 형 식 T h i s T y p e 을 이 용 할 수 있 으 며 이 를 제 네 릭 형 식 매 개 변 수 D a t a 로 설 정 한 다 .
> type Options<Data, Computed> = {
> data(this: {})?: Data;
> computed?: Computed & ThisType<Data>;
> 이 제 이 전 예 제 에 서 처 럼 t h i s . f i r s t N a m e 에 접 근 할 수 있 다 . 마 지 막 으 로 m e t h o d s 를 살 펴 보
> 자 . m e t h o d s 는 t h i s 로 D a t a 에 접 근 할 수 있 을 뿐 아 니 라 프 로 퍼 티 로 모 든 계 산 된 프 로 퍼 티 와
> 메 서 드 에 접 근 할 수 있 는 특 이 한 프 로 퍼 티 다 .
> 1 8 8 실 무 로 통 하 는 타 입 스 크 립 트
> C o m p u t e d 는 모 든 계 산 된 프 로 퍼 티 를 함 수 로 보 관 한 다 . 하 지 만 이 들 의 값 ( 즉 , 함 수 들 의 반 환
> 값 ) 이 필 요 하 다 . 프 로 퍼 티 접 근 방 식 으 로 f u l L N a m e 에 접 근 하 면 S t r i n g 일 것 이 라 예 상 한 다 .
> M a p F n T o P r o p 이 라 는 헬 퍼 형 식 을 만 든 다 . 이 형 식 은 함 수 의 객 체 형 식 을 받 아 함 수 의 반 환 값
> 형 식 으 로 매 핑 한 다 . 이 상 황 에 는 내 장 헬 퍼 형 식 R e t u r n T y p e 이 적 합 하 다 .
> 1 / 함 수 들 을 포 함 하 는 객 체 • • •
> type FnObj = Record<string, () => any>;
> 1 / . . 이 를 반 환 형 식 을 포 함 하 는 객 체 로 변 환 한 다 .
> type MapFnToProp<FunctionObj extends FnObj> = {
> [K in keyof FunctionObj]: ReturnType<FunctionObj[K]>;
> M a p F n T o P r o p 을 이 용 해 새 로 추 가 된 M e t h o d s 라 는 제 네 릭 형 식 매 개 변 수 에 T h i s T y p e
> 을 설 정 할 수 있 다 . 또 한 D a t a 와 M e t h o d s 를 혼 합 했 다 . C o m p u t e d 제 네 릭 형 식 매 개 변 수 를
> M a p F n T o P r o p 으 로 전 달 하 려 면 형 식 매 개 변 수 를 F n o b j 로 제 약 ( M a p F n T o P r o p 의 첫 매 개 변 수
> F u n c t i o n o b j 와 같 은 제 약 ) 해 야 한 다 .
> type Options‹Data, Computed extends FnObj, Methods> = {
> data ( t h i s : 15)?: Data;
> computed?: Computed & ThisType<Data>;
> methods?: Methods & ThisType<Data & MapFnToProp<Computed> & Methods>;
> 이 렇 게 형 식 을 완 성 했 다 ! 모 든 제 네 릭 형 식 프 로 퍼 티 를 가 져 다 c r e a t e 라 는 팩 토 리 함 수 에 추
> 가 한 다 .
> declare function create‹Data, Computed extends FnObj, Methods>(
> options: Options<Data, Computed, Methods>
> ) : any;
> 사 용 방 법 에 따 라 모 든 제 네 릭 형 식 매 개 변 수 가 적 절 히 치 환 된 다 . O p t i o n s 의 형 식 을 지 정 한
> 방 식 덕 분 에 [ 그 림 4 - 1 ] 과 비 슷 한 문 제 가 발 생 하 지 않 도 록 필 요 한 모 든 자 동 완 성 기 능 을 얻 을
> 수 있 다 .
> 4 장 제 네 릭 1 8 9
> 이 예 제 는 타 입 스 크 립 트 가 내 부 적 으 로 많 은 객 체 를 변 환 하 는 A P I 에 형 식 을 추 가 하 는 데 얼 마
> '
> 나 도 움 을 주 는 지 보 여 준 다 .
> 9 6 create(&
> 9 7 datal) (
> 9 8 // ets-expect-error
> 9 9 this. firstname;
> 1 0 0 / / ets-expect-error
> 1 0 1 this.getRandomC);
> 1 0 2 / / @ts-expect-error
> 1 0 3 this.data);
> 1 0 4
> 1 0 5 r e t u r n
> 106 firstName: "Stefan",
> 107 lastName: "Baumgartner",
> 1 0 8 2, 90: 40,1 0 9
> 1 1 0
> 1 1 1 computed: 1
> 1 1 2 fullNamel) (
> 1 1 3 | return '${this.firstName} $(this.lastName}';
> 1 1 4
> 1 1 5
> 1 1 6
> 1 1 7
> 1 1 8
> 1 1 9
> 1 2 0
> 1 2 1
> 1 2 2
> 1 2 3
> 1 2 4
> 1 2 5
> 1 2 6
> 1 2 7
> 1 2 8
> 1 2 9
> 1 3
> } ,
> } , methods: (
> getRandom {
> return Math. random):
> } ,
> © age
> hi() ( @ firstName
> alert(this. LastNa D fulName
> alert(this. fullNa ® getRandom
> alert(this.getRan Ohi
> } ,
> @ LastName
> testO) ( ① t e s t
> | console. log(this.)
> } .
> (property) age: number
> } ,
> 그 림 4 - 1 팩 토 리 함 수 의 m e t h o d s 설 정 은 이 제 모 든 올 바 른 프 로 퍼 티 에 접 근 할 수 있 다 .
> 1 훌 륭 한 예 제 를 제 공 한 타 입 챌 린 지 ( T y p e C h a l l e n g e s , h t t p s : / / o r e i l . L y / p H c 9 j ) 의 저 자 들 에 게 감 사 한 다 .
> 1 9 0 실 무 로 통 하 는 타 입 스 크 립 트
> 4 . 9 제 네 릭 형 식 매 개 변 수 에 c o n s t 컨 텍 스 트 추 가 하 기
> 문 제 복 잡 한 리 터 럴 값 을 함 수 로 전 달 할 때 , 타 입 스 크 립 트 는 형 식 을 일 반 적 인 방 향 으 로 확 장 한 다 . 대 부 분
> 상 황 에 서 는 도 움 을 주 는 동 작 이 지 만 , 때 로 는 넓 어 진 형 식 대 신 리 터 럴 형 식 그 대 로 가 필 요 하 다 .
> 해 결 제 네 릭 형 식 매 개 변 수 앞 에 c o n s t 변 경 자 를 붙 여 전 달 된 값 이 c o n s t 컨 텍 스 트 에 서 유
> 지 되 게 한 다 .
> 논 의 싱 글 페 이 지 애 플 리 케 이 션 i n g l e - p a g e a p p l i c a t i o n ( S P A ) 프 레 임 워 크 는 브 라 우 저 의 많 은 기 능 을
> 자 바 스 크 립 트 로 재 구 현 하 는 경 향 이 있 다 . 예 를 들 어 H i s t o r y A P T ( h t t p s : / / o r e i l . y / W B g j ) 는
> 일 반 탐 색 동 작 을 오 버 라 이 드 하 도 록 허 용 하 므 로 S P A 프 레 임 워 크 는 이 를 이 용 해 페 이 지 를 다
> 시 불 러 오 지 않 고 도 페 이 지 의 콘 텐 츠 와 브 라 우 저 의 U I R L 을 바 꾼 다 .
> 페 이 지 간 을 이 동 하 는 라 우 터 r o u c r 라 는 기 능 을 이 용 하 는 간 단 한 S P A 프 레 임 워 크 가 있 다 고 가 정
> 하 자 . 컴 포 넌 트 c o m p o n e m 로 페 이 지 를 정 의 하 며 C o m p o n e n t C o n s t r u c t o r 인 터 페 이 스 는 웹 사 이 트
> 의 새 요 소 를 인 스 턴 스 화 하 고 렌 더 링 하 는 방 법 을 안 다 .
> i n t e r f a c e n e w ) : ComponentConstructor {
> Component;
> }
> interface Component {
> render ( : HTMLElement;
> }
> 라 우 터 는 컴 포 넌 트 목 록 과 관 련 경 로 를 받 아 s t r i n g 으 로 저 장 한 다 . r o u t e r 함 수 로 라 우 터 를
> 만 들 때 원 하 는 경 로 를 탐 색 할 수 있 도 록 n a v i g a t e 라 는 객 체 를 반 환 한 다 .
> type Route = {
> path: string;
> component: ComponentConstructor;
> function router(routes: Route[]) {
> return {
> navigate(path: s t r i n g ) {
> 4 장 제 네 릭 1 9 1
> 1 1 . . .
> } ,
> ｝ ；
> }
> 현 재 관 심 사 는 탐 색 을 어 떻 게 구 현 하 는 지 가 아 니 라 함 수 인 터 페 이 스 의 형 식 을 어 떻 게 구 성 하
> 는 지 다 .
> 라 우 터 는 의 도 한 대 로 동 작 한 다 . 즉 , 라 우 터 는 R o u t e 객 체 배 열 을 받 아 n a v i g a t e 함 수 를 포 함
> 하 는 객 체 를 반 환 한 다 . 이 객 체 를 이 용 해 한 U R L 에 서 다 른 U R L 로 탐 색 할 수 있 으 며 이 때 마 다
> 새 컴 포 넌 트 를 그 린 다 .
> const r t r = router([
> {
> path: "/",
> component: Main,
> } ,
> {
> path: "/about",
> component: About,
> ふ
> rtr.navigate("/faq");
> 이 들 형 식 은 너 무 넓 다 는 사 실 을 한 눈 에 알 수 있 다 . 모 든 가 능 한 문 자 열 을 탐 색 하 도 록 허 용 하
> 므 로 아 무 데 도 연 결 되 지 않 는 가 짜 경 로 를 사 용 하 지 못 하 게 막 을 수 없 다 . 이 미 준 비 되 어 있 고
> 사 용 할 수 있 는 정 보 에 대 한 일 종 의 오 류 처 리 를 구 현 해 야 한 다 .
> 우 선 제 네 릭 형 식 매 개 변 수 를 구 체 적 형 식 으 로 바 꾼 다 . 리 터 럴 형 식 이 있 으 면 타 입 스 크 립
> 트 는 하 위 형 식 을 만 드 는 방 식 으 로 제 네 릭 치 환 을 처 리 한 다 . R o u t e 대 신 T , s t r i n g 대 신
> T [ " p a t h " ] 를 사 용 하 면 원 하 는 바 에 근 접 한 동 작 을 구 현 할 수 있 다 .
> function router<T extends Route>(routes: T[]) {
> return {
> navigate(path: T["path"]) {
> / / . . .
> },
> 1 9 2 실 무 로 통 하 는 타 입 스 크 립 트
> 이 론 적 으 로 이 코 드 는 동 작 한 다 . 예 제 에 서 는 기 본 형 식 을 리 터 럴 로 수 있 다 .
> 타 입 스 크 립 트 가 리 터 럴 을 어 떻 게 처 리 하 는 지 떠 올 려 보 자 . 이
> 사 용 했 는 데 , 이 값 은 리 터 럴 형 식 으 로 좁 혀 질 것 임 을 기 대 할
> function getPath<T extends string>(route: T): T
> return route;
> }
> const path = getPath("/"); // "/"
> 4 . 3 절 에 서 이 동 작 을 더 자 세 히 확 인 할 수 있 다 . 이 전 예 제 에 서 반 환 값 이 불 변 형 s a b i c 이 므 로
> p a t h 는 c o n s t 컨 텍 스 트 였 음 을 눈 여 겨 보 자 .
> 객 체 와 배 열 을 처 리 할 때 한 가 지 문 제 가 있 다 . 타 입 스 크 립 트 는 객 체 의 형 식 을 넓 히 고 , 배 열 의
> 값 은 변 할 수 있 으 므 로 배 열 의 형 식 은 더 폭 넓 게 일 반 화 한 다 는 점 이 다 . 중 첩 된 객 체 로 이 와 비
> 슷 한 예 제 를 살 펴 보 자 . 여 기 서 타 입 스 크 립 트 는 더 넓 은 형 식 을 대 신 취 한 다 .
> type Routes = {
> paths: string[];
> function getPaths<T extends Routes>(routes: T): T["paths"] {
> r e t u r n r o u t e s . p a t h s ;
> const paths = getPaths({ paths: ["/", "/about"] }); / / string[]
> 객 체 에 서 p a t h s 의 c o n s t 컨 텍 스 트 는 콘 텐 츠 가 아 니 라 변 수 바 인 딩 전 용 이 다 . 이 때 문 에
> n a v i g a t e 의 형 식 을 올 바 로 정 의 하 는 데 필 요 한 일 부 정 보 를 잃 게 된 다 .
> 상 호 적 으 로 c o n s t 컨 텍 스 트 를 적 용 해 이 제 한 을 피 할 수 있 다 . 그 러 려 면 입 력 매 개 변 수 를
> r e a d o n L y 로 재 정 의 한 다 .
> 4 장 제 네 릭 1 9 3
> function router<T extends Route>(routes: readonly T[]) 1
> return {
> navigate(path: T["path"]) {
> history.pushState(t}, ", path);
> }
> const r t r = r o u t e r ( [
>
> > {
> > path: "/"
> > component: Main,
> > } ,
> > {
> > path: "/about",
> > component: About,
> > ] as const);
> > rtr. navigate("/about");
> > 이 코 드 는 동 작 하 지 만 , 코 딩 시 아 주 중 요 한 세 부 사 항 을 잊 으 면 안 된 다 는 단 점 이 있 다 . 이 렇
> > 게 무 엇 인 가 를 기 억 해 야 한 다 는 사 실 은 언 젠 가 반 드 시 문 제 를 일 으 킨 다 .
> > 다 행 히 도 타 입 스 크 립 트 는 제 네 릭 형 식 매 개 변 수 에 서 c o n s t 컨 텍 스 트 를 요 청 하 도 록 허 용 한 다 .
> > 값 에 c o n s t 컨 텍 스 트 를 적 용 하 는 대 신 , 제 네 릭 형 식 매 개 변 수 를 구 체 적 인 값 으 로 치 환 할 때 제
> > 네 릭 형 식 매 개 변 수 에 c o n s t 변 경 자 를 추 가 해 서 이 동 작 이 c o n s t 컨 텍 스 트 에 서 발 생 하 도 록
> > 강 제 한 다 .
> > function router<const T extends Route>(routes: T[]) {
> > return {
> > navigate(path: T["path"]) {
> > / / 구 현 중
> > } ,
> > 3;
> > }
> > 이 제 라 우 터 를 기 존 처 럼 사 용 할 수 있 으 며 가 능 한 경 로 값 을 자 동 완 성 기 능 으 로 얻 을 수 있 다 .
> > 1 9 4 실 무 로 통 하 는 타 입 스 크 립 트
> > const r t r = router([
> > {
> > path: "/",
> > component: Main,
> > {
> > path: "/about",
> > component: About,
> > 3
> > n
> > rtr. navigate("/about");
> > 심 지 어 존 재 하 지 않 는 값 을 전 달 하 려 하 면 오 류 가 발 생 한 다 .
> > const rtr = router([
> >
> > > > {
> > > > path: "/",
> > > > component: Main,
> > > > } ,
> > > > {
> > > > path: "/about",
> > > > component: About,
> > > > ] )
> > > > rtr.navigate("/faq");
> > > > 1 / " / f a q " ' 형 식 의 인 수 는 " / " " / a b o u t " ' 형 식 의 매 개 변 수 에
> > > > 1 / 할 당 될 수 없 습 니 다 . t s ( 2 3 4 5 )
> > > > 함 수 의 A P I 에 서 는 이 모 든 세 부 내 용 이 숨 겨 진 다 는 점 이 특 히 훌 륭 하 다 . 원 하 는 바 를 더 명 확
> > > > 하 게 전 달 할 수 있 고 , 인 터 페 이 스 는 제 약 이 무 엇 인 지 알 려 주 며 , r o u t e r 를 이 용 해 형 식 안 전 성
> > > > 을 확 보 하 면 서 도 추 가 작 업 이 필 요 하 지 않 다 .
> > > > 4 장 제 네 릭 1 9 5
